 1/1:
from Tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)

button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)

label = Label(root)
label.pack()

root.mainloop()
 1/2:
from Tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)

button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)

label = Label(root)
label.pack()

root.mainloop()
 1/3:
from Tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)

button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)

label = Label(root)
label.pack()

root.mainloop()
 1/4:
from Tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)

button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)

label = Label(root)
label.pack()

root.mainloop()
 1/5:
from Tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)

button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)

label = Label(root)
label.pack()

root.mainloop()
 1/6:
from Tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)

button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)

label = Label(root)
label.pack()

root.mainloop()
 1/7:
from Tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)

button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)

label = Label(root)
label.pack()

root.mainloop()
 1/8:
from Tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)

button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)

label = Label(root)
label.pack()

root.mainloop()
 2/1:
from Tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)

button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)

label = Label(root)
label.pack()

root.mainloop()
 3/1:
from Tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)

button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)

label = Label(root)
label.pack()

root.mainloop()
 3/2:
from Tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)

button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)

label = Label(root)
label.pack()

root.mainloop()
 3/3:
from Tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)

button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)

label = Label(root)
label.pack()

root.mainloop()
 3/4:
from Tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)

button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)

label = Label(root)
label.pack()

root.mainloop()
 3/5:
from Tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)

button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)

label = Label(root)
label.pack()

root.mainloop()
 3/6:
from Tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)

button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)

label = Label(root)
label.pack()

root.mainloop()
 3/7:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)

button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)

label = Label(root)
label.pack()

root.mainloop()
 3/8:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)

button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)

label = Label(root)
label.pack()

root.mainloop()
 3/9:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale_1 = Scale( root, variable = var )
scale_1.pack(anchor=CENTER)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=CENTER)



label = Label(root)
label.pack()

root.mainloop()
3/10:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale_1 = Scale( root, variable = var )
scale_1.pack(anchor=N)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=S)



label = Label(root)
label.pack()

root.mainloop()
3/11:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale_1 = Scale( root, variable = var )
scale_1.pack(anchor=N)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=S)



label = Label(root)
label.pack()

root.mainloop()
3/12:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale_1 = Scale( root, variable = var )
scale_1.pack(anchor=N)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)



label = Label(root)
label.pack()

root.mainloop()
3/13:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale_1 = Scale( root, variable = var )
scale_1.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)



label = Label(root)
label.pack()

root.mainloop()
3/14:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)



label = Label(root)
label.pack()

root.mainloop()
3/15:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

“”“
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
”“”

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)


label_text = Tkinter.Label(root, text = '文本');
label_text.pack()


label = Label(root)
label.pack()

root.mainloop()
3/16:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

"""
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
"""

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)


label_text = Tkinter.Label(root, text = '文本');
label_text.pack()


label = Label(root)
label.pack()

root.mainloop()
3/17:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

"""
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
"""

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)

s = tk.Scale(window, label='try me', from_=0, to=100, orient=tk.HORIZONTAL, length=200, showvalue=0,tickinterval=20, resolution=0.1, command=print1)

label = Label(root)
label.pack()

root.mainloop()
3/18:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

"""
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
"""

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)

s = Scale(window, label='try me', from_=0, to=100, orient=tk.HORIZONTAL, length=200, showvalue=0,tickinterval=20, resolution=0.1, command=print1)

label = Label(root)
label.pack()

root.mainloop()
3/19:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

"""
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
"""

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)

def print1(i):
    l.config(text='you have selected ' + i)
    
s = Scale(root,label='try me', from_=0, to=100, orient=tk.HORIZONTAL, length=200, showvalue=0,tickinterval=20, resolution=0.1, command=print1)
s.pack()

root.mainloop()
3/20:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

"""
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
"""

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)

def print1(i):
    l.config(text='you have selected ' + i)
    
s = Scale(root,label='try me', from_=0, to=100, orient=HORIZONTAL, length=200, showvalue=0,tickinterval=20, resolution=0.1, command=print1)
s.pack()

root.mainloop()
 5/1:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

"""
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
"""

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)

def print1(i):
    print i
    
s = Scale(root,label='try me', from_=0, to=100, orient=HORIZONTAL, length=200, showvalue=0,tickinterval=20, resolution=0.1, command=print1)
s.pack()

root.mainloop()
 5/2:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

"""
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
"""

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)

def print1(i):
    print(i)
    
s = Scale(root,label='try me', from_=0, to=100, orient=HORIZONTAL, length=200, showvalue=0,tickinterval=20, resolution=0.1, command=print1)
s.pack()

root.mainloop()
 6/1:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

"""
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
"""

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)

def print1(i):
    print(i)
    
s = Scale(root,label='try me', from=0, to=100, orient=HORIZONTAL, length=200, showvalue=0,tickinterval=20, resolution=0.1, command=print1)
s.pack()

root.mainloop()
 7/1:
import os
from scipy import misc
path = 'LFdata/toyLF/'
image= misc.imread(os.path.join(path,'lowtoys225.bmp'), flatten= 0)
 7/2:
import os
from scipy import misc
path = 'LFdata/toyLF/'
image= misc.imread(os.path.join(path,'lowtoys225.bmp'), flatten= 0)
 8/1:
import os
from scipy import misc
path = 'LFdata/toyLF/'
image= misc.imread(os.path.join(path,'lowtoys225.bmp'), flatten= 0)
 8/2:
import os
from scipy import misc
path = 'LFdata/toyLF/'
image= misc.imread(os.path.join(path,'lowtoys225.bmp'), flatten= 0)
 8/3:
import os
from scipy import misc
path = 'LFdata/toyLF/'
image= misc.imread(os.path.join(path,'lowtoys225.bmp'), flatten= 0)
 8/4:
import os
from scipy import misc
 8/5: import imageio
 8/6: image = imageio.imread(os.path.join(path,'lowtoys225.bmp')
 8/7: image = imageio.imread(os.path.join(path,'lowtoys225.bmp'))
 8/8: image
 8/9:
from PIL import Image 
im=Image.fromarray(image)
8/10: im.show()
8/11: image.shape
8/12: im,shape
8/13: im.shape
8/14: im.show()
8/15: im.show()
8/16:
import numpy as np
from scipy.interpolate import LinearNDInterpolator

lats = np.arange(-90,90.5,0.5)
lons = np.arange(-180,180,0.5)
alts = np.arange(1,1000,21.717)
time = np.arange(8)
data = np.random.rand(len(lats)*len(lons)*len(alts)*len(time)).reshape((len(lats),len(lons),len(alts),len(time)))

interpolatedData = np.array([None, None, None, None])
interpolatedData[0] = interp1d(lats,data,axis=0)
interpolatedData[1] = interp1d(lons,data,axis=1)
interpolatedData[2] = interp1d(alts,data,axis=2)
interpolatedData[3] = interp1d(time,data,axis=3)
8/17:
    import numpy as np
    from Scientific.Functions.Interpolation import InterpolatingFunction

    lats = np.arange(-90,90.5,0.5)
    lons = np.arange(-180,180,0.5)
    alts = np.arange(1,1000,21.717)
    time = np.arange(8)
    data = np.random.rand(len(lats)*len(lons)*len(alts)*len(time)).reshape((len(lats),len(lons),len(alts),len(time)))

    axes = (lats, lons, alts, time)
    f = InterpolatingFunction(axes, data)
8/18:
from itertools import product

def interpolator(coords, data, point) :
    dims = len(point)
    indices = []
    sub_coords = []
    for j in xrange(dims) :
        idx = np.digitize([point[j]], coords[j])[0]
        indices += [[idx - 1, idx]]
        sub_coords += [coords[j][indices[-1]]]
    indices = np.array([j for j in product(*indices)])
    sub_coords = np.array([j for j in product(*sub_coords)])
    sub_data = data[list(np.swapaxes(indices, 0, 1))]
    li = LinearNDInterpolator(sub_coords, sub_data)
    return li([point])[0]
8/19: point = np.array([12.3,-4.2, 500.5, 2.5])
8/20: interpolator((a, b, c, d),[1,2,3,4],[2,2])
8/21:
point = np.array([12.3,-4.2, 500.5, 2.5])
a=[4,4]
b=[0,0]
c=[0,2]
d=[4,2]
8/22: interpolator((a, b, c, d),[1,2,3,4],[2,2])
8/23:
from itertools import product

def interpolator(coords, data, point) :
    dims = len(point)
    indices = []
    sub_coords = []
    for j in range(dims) :
        idx = np.digitize([point[j]], coords[j])[0]
        indices += [[idx - 1, idx]]
        sub_coords += [coords[j][indices[-1]]]
    indices = np.array([j for j in product(*indices)])
    sub_coords = np.array([j for j in product(*sub_coords)])
    sub_data = data[list(np.swapaxes(indices, 0, 1))]
    li = LinearNDInterpolator(sub_coords, sub_data)
    return li([point])[0]
8/24: interpolator((a, b, c, d),[1,2,3,4],[2,2])
10/1:
import os
import imageio
path = 'LFdata/toyLF/'
image = imageio.imread(os.path.join(path,'lowtoys225.bmp'))
10/2:
from PIL import Image 
im=Image.fromarray(image) 
im.show()
10/3:
import os
import imageio
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,256):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))
10/4:
from PIL import Image 
im=Image.fromarray(Temp[3]) 
im.show()
10/5:
from PIL import Image 
im=Image.fromarray(Temp[19]) 
im.show()
10/6: import numpy as np
10/7: Temp[1][1][1]
10/8:
def Get_N_ij(i,j):
    N = []
    for in range(1,256):
        print(i)
10/9:
def Get_N_ij(i,j):
    N = []
    for i in range(1,256):
        print(i)
Get_N_ij(1,2)
10/10:
def Get_N_ij(P,h,w):
    N = []
    for i in range(h):
        for j in range(w)
            N_ij = []
            for p in P:
                N_ij.append(p[i+1][j+1])
            N.append(N_ij)
    return N
N = Get_N_ij(Temp,16,16)
10/11:
def Get_N_ij(P,h,w):
    N = []
    for i in range(h):
        for j in range(w):
            N_ij = []
            for p in P:
                N_ij.append(p[i+1][j+1])
            N.append(N_ij)
    return N
N = Get_N_ij(Temp,16,16)
10/12: N
10/13: N.shape()
10/14: len(N)
10/15:
print(len(N))
print(N[0])
10/16:
print(len(N))
print(N[0].shape())
10/17: N[0]
10/18: len(N[0])
10/19:
def 4_interpolator()：
    return
10/20:
a = [0,1]
x,y = (a[0],a[1])
10/21: x,y
10/22: x
10/23:
def normalize(v):
    norm=np.linalg.norm(v, ord=1)
    if norm==0:
        norm=np.finfo(v.dtype).eps
    return v/norm
10/24: normalize([1,1,1])
10/25: normalize([0,1,1])
10/26:
import numpy as np
import math
10/27:
def Q_interpolator(coords,Data)：
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    return x_,y_
10/28:
def Q_interpolator(coords,Data):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    return x_,y_
10/29: Q_interpolator([0.2,0.7],0)
10/30:
def Q_interpolator(coords,Data):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y-y_
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    return normalize(w)
10/31: Q_interpolator([0.5,0.5],0)
10/32:
def Q_interpolator(coords,Data):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    print(x_,y_)
    d1 = x-x_
    d2 = y-y_
    print(d1,d2)
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    return normalize(w)
10/33: Q_interpolator([0.5,0.5],0)
10/34:
def Q_interpolator(coords,Data):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    print(x_,y_)
    d1 = x-x_
    d2 = y_-y
    print(d1,d2)
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    return normalize(w)
10/35: Q_interpolator([0.5,0.5],0)
10/36:
def Q_interpolator(coords,Data):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    return normalize(w)
10/37: Q_interpolator([0.2,0.3],0)
10/38: print(Q_interpolator)
10/39:
import inspect
lines = inspect.getsource(Q_interpolator)
print(lines)
11/1:
import os
import imageio
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))
11/2:
import numpy as np
import math
11/3: Temp[0]
11/4: Temp[0].shape
11/5: Temp[0].reshape(1,:,3)
11/6: Temp[0].reshape(1,,3)
11/7: Temp[0].reshape(1,320*240,3)
11/8: TT = Temp[0].reshape(1,320*240,3)
11/9: TT
11/10: TT.shape()
11/11: TT.shape
11/12: TT[0]
11/13: TT = Temp[0].reshape(320*240,3)
11/14: TT
11/15: TT.shape()
11/16: TT.shape
11/17: TT.shape
11/18: TT
11/19: Temp[0].shape()
11/20: Temp[0].shape
11/21: Temp[0][0]
11/22: TT
11/23: Temp[0][0].shape
11/24: Temp[0][1].shape
11/25: TT
11/26: TT.shape()
11/27: TT.shape
11/28: Temp[0].shape
11/29: TT.reshape(240,320,3)
11/30:
im=Image.fromarray(TT.reshape(240,320,3)) 
im.show()
11/31: from PIL import Image
11/32:
im=Image.fromarray(TT.reshape(240,320,3)) 
im.show()
11/33:
def img_2_matrix(img):
    return image.reshape(320*240,3)
def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
11/34:
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
11/35:
def img_2_matrix(img):
    return img.reshape(320*240,3)
def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
11/36:
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
11/37: np.array(Data)
11/38:
D = np.array(Data)
D.shape
11/39:
D = np.array(Data)
np.concatenate(D,axis=0)
11/40:
D = np.array(Data)
X = np.concatenate(D,axis=0)
X.shape
11/41:
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.concatenate(np.array(Data),axis=0)
11/42: Data.shape
11/43:
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
11/44: Data
11/45: Data.shape()
11/46: Data.shape
11/47: Data[16*16]
11/48: Data[16*16-1]
11/49:
#get the photo [320*240] as a vector with the uv coord(x,y)
def get_photo(x,y,Data):
    index = 156-x-16*y
    return Data[index]
11/50:
from PIL import Image 
def show_img(img):
    im=Image.fromarray(TT.reshape(240,320,3)) 
    im.show()
11/51:
#get the photo [320*240] as a vector with the uv coord(x,y)
def get_photo(x,y,Data):
    index = 156-x-16*y
    return Data[index]
11/52:
p = get_photo(0,0,Data)
show_img(p)
11/53:
#get the photo [320*240] as a vector with the uv coord(x,y)
def get_photo(x,y,Data):
    index = 256-x-16*y
    return Data[index]
11/54:
p = get_photo(0,0,Data)
show_img(p)
11/55:
#get the photo [320*240] as a vector with the uv coord(x,y)
def get_photo(x,y,Data):
    index = 255-x-16*y
    return Data[index]
11/56:
p = get_photo(0,0,Data)
show_img(p)
11/57: show_img(Temp[0])
11/58: show_img(Temp[256])
11/59: show_img(Temp[255])
11/60:
import os
import imageio
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    print(name)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))
11/61:
import os
import imageio
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))
11/62: Temp[0]
11/63: Temp[1]
11/64: Temp[2]
11/65: show_img(Temp[255])
11/66: show_img(Temp[0])
11/67: show_img(Temp[1])
11/68: show_img(Temp[10])
11/69:
from PIL import Image 
def show_img(img):
    im=Image.fromarray(img) 
    im.show()
11/70:
p = get_photo(0,0,Data)
show_img(p)
11/71: p
11/72: show_img(p)
11/73:
im=Image.fromarray(img) 
im.show()
11/74:
im=Image.fromarray(p) 
im.show()
11/75:
p = get_photo(0,0,Data)
p.shape
11/76:
p = get_photo(0,0,Data)
show_img(matrix_2_img(p))
11/77:
p = get_photo(15,0,Data)
show_img(matrix_2_img(p))
11/78:
p = get_photo(15,15,Data)
show_img(matrix_2_img(p))
11/79:
#get the photo [320*240] as a vector with the uv coord(x,y)
def get_photo(x,y):
    index = 255-x-16*y
    return Data[index]
11/80: get_photo(2,2)
11/81: show_img(img_2_matrix(get_photo(2,2)))
11/82: show_img(matrix_2_img(get_photo(2,2)))
11/83: show_img(matrix_2_img(get_photo(2,2))*0.1)
11/84: get_photo(2,2))
11/85: get_photo(2,2)
11/86: get_photo(2,2)*0.2
11/87: show_img(matrix_2_img(get_photo(2,2)*0.2))
11/88: int(get_photo(2,2)*0.2)
11/89: (get_photo(2,2)*0.2).astype(np.int)
11/90:
x = (get_photo(2,2)*0.2).astype(np.int)
show_img(matrix_2_img(x))
11/91:
x = (get_photo(2,2)*0.2).astype(np.int)
x
11/92:
x = (get_photo(2,2)*0.2).astype(np.int)
x.shape
11/93:
x = (get_photo(2,2)*0.2).astype(np.int)
x = matrix_2_img(x)
11/94:
x = (get_photo(2,2)*0.2).astype(np.int)
x = matrix_2_img(x)
x.shape
11/95:
x = (get_photo(2,2)*0.2).astype(np.int)
x = matrix_2_img(x)
show_img(x)
11/96:
x = (get_photo(2,2)*0.2).astype(np.int)
x = matrix_2_img(x)
x
11/97:
x = (get_photo(2,2)*0.2).astype(np.uint8)
x = matrix_2_img(x)
x
11/98:
x = (get_photo(2,2)*0.2).astype(np.uint8)
x = matrix_2_img(x)
show_img(x)
11/99:
x = (get_photo(2,2)*0.2).np.floor(np.uint8)
x = matrix_2_img(x)
show_img(x)
11/100:
x = (get_photo(2,2)*0.2).floor(np.uint8)
x = matrix_2_img(x)
show_img(x)
11/101: x = np.floor(get_photo(2,2)*0.2)
11/102:
x = x.astype(uint8)
x = matrix_2_img(x)
show_img(x)
11/103:
x = x.astype(uint)
x = matrix_2_img(x)
show_img(x)
11/104:
x = np.floor(get_photo(2,2)*0.2)
x = x.astype(np.uint8)
x = matrix_2_img(x)
show_img(x)
11/105: type(x)
11/106:
x = np.floor(get_photo(2,2)*0.2)
x = x.astype(np.uint8)
y = np.ndarray()
y = y+x
x = matrix_2_img(y)
show_img(x)
11/107:
x = np.floor(get_photo(2,2)*0.2)
x = x.astype(np.uint8)
x.shape
11/108:
x = np.floor(get_photo(2,2)*0.2)
x = x.astype(np.uint8)
y = np.ndarray(76800,3)
y = y+x
x = matrix_2_img(y)
show_img(x)
11/109:
x = np.floor(get_photo(2,2)*0.2)
x = x.astype(np.uint8)
y = np.ndarray(76800,3,dtype=np.uint8)
y = y+x
x = matrix_2_img(y)
show_img(x)
11/110:
x = np.floor(get_photo(2,2)*0.2)
x = x.astype(np.uint8)
y = np.ndarray(76800,3,dtype=uint8)
y = y+x
x = matrix_2_img(y)
show_img(x)
11/111:
x = np.floor(get_photo(2,2)*0.2)
x = x.astype(np.uint8)
y = np.ndarray((76800,3),dtype=np.uint8)
y = y+x
x = matrix_2_img(y)
show_img(x)
11/112:
x = np.floor(get_photo(2,2)*0.2)
x = x.astype(np.uint8)
y = np.zeros((76800,3),dtype=np.uint8)
y = y+x
x = matrix_2_img(y)
show_img(x)
11/113:
x = np.floor(get_photo(2,2)*0.2)
x = x.astype(np.uint8)
y = np.zeros((76800,3),dtype=np.uint8)
y = y+5*x
x = matrix_2_img(y)
show_img(x)
11/114:
def Blend_4(P,w):
    Image = np.zeros((76800,3),dtype=np.uint8)
    for i in range(P):
        Temp = (np.floor(P[i]*w[i])).astype(np.uint8)
        Image = Image + Temp
    return matrix_2_img(Image)
11/115:
#x(0,15),y(0,15)
def Q_interpolator(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo(x_,y_)
    p2 = get_photo(x_+1,y_)
    p3 = get_photo(x_,y_-1)
    p4 = get_photo(x_+1,y_-1)
    return Blend_4([p1,p2,p3,p4],normalize(w))
11/116: I = Q_interpolator([0.2,0.3])
11/117:
def normalize(v):
    norm=np.linalg.norm(v, ord=1)
    if norm==0:
        norm=np.finfo(v.dtype).eps
    return v/norm
11/118:
#x(0,15),y(0,15)
def Q_interpolator(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo(x_,y_)
    p2 = get_photo(x_+1,y_)
    p3 = get_photo(x_,y_-1)
    p4 = get_photo(x_+1,y_-1)
    return Blend_4([p1,p2,p3,p4],normalize(w))
11/119: I = Q_interpolator([0.2,0.3])
11/120:
def Blend_4(P,w):
    Image = np.zeros((76800,3),dtype=np.uint8)
    for i in range(len(P):
        Temp = (np.floor(P[i]*w[i])).astype(np.uint8)
        Image = Image + Temp
    return matrix_2_img(Image)
11/121:
def Blend_4(P,w):
    Image = np.zeros((76800,3),dtype=np.uint8)
    for i in range(len(P)):
        Temp = (np.floor(P[i]*w[i])).astype(np.uint8)
        Image = Image + Temp
    return matrix_2_img(Image)
11/122: I = Q_interpolator([0.2,0.3])
11/123:
I = Q_interpolator([0.2,0.3])
show_img(I)
11/124:
I = Q_interpolator([1,1])
show_img(I)
11/125:
I = Q_interpolator([0.3,0.8])
show_img(I)
12/1: coords = [[1,1],[2,2],[3,3],[4,4]]
12/2:
np
\
12/3: np.nda
12/4: import numpy as np
12/5:
import numpy as np
cc = np.ndarray(coords)
12/6: import numpy as np
12/7: coords
12/8: coords = [np.ndarry(i)] for i in coords]
12/9: coords = [np.ndarry(i) for i in coords]
12/10: coords = [np.ndarray(i) for i in coords]
12/11: coords
12/12: coords = [[1,1],[2,2],[3,3],[4,4]]
12/13: np.array(coords)
12/14:
coords = [[1,1],[2,2],[3,3],[4,4]]
coords = np.array(coords)
12/15:
coords = [[1,2],[2,2],[1,1],[2,1]]
coords = np.array(coords)
basic_coord = np.array([1.5,1.5])
12/16: coords-basic_coord
12/17: I
12/18:
import os
import imageio
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))
12/19:
import numpy as np
import math
12/20:
def img_2_matrix(img):
    return img.reshape(320*240,3)
def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
12/21:
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
12/22:
from PIL import Image 
def show_img(img):
    im=Image.fromarray(img) 
    im.show()
12/23:
#get the photo [320*240] as a vector with the uv coord(x,y)
def get_photo(x,y):
    index = 255-x-16*y
    return Data[index]
12/24:
def Blend_4(P,w):
    Image = np.zeros((76800,3),dtype=np.uint8)
    for i in range(len(P)):
        Temp = (np.floor(P[i]*w[i])).astype(np.uint8)
        Image = Image + Temp
    return matrix_2_img(Image)
12/25:
def normalize(v):
    norm=np.linalg.norm(v, ord=1)
    if norm==0:
        norm=np.finfo(v.dtype).eps
    return v/norm
12/26:
#x(0,15),y(0,15)
def Q_interpolator(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo(x_,y_)
    p2 = get_photo(x_+1,y_)
    p3 = get_photo(x_,y_-1)
    p4 = get_photo(x_+1,y_-1)
    return Blend_4([p1,p2,p3,p4],normalize(w))
12/27:
I = Q_interpolator([0.3,0.8])
show_img(I)
12/28: I
12/29: I.shape
12/30: I[0]
12/31: I[0].shape
12/32: I[0][0]
12/33: I[0][0] = [0,0,0]
12/34: I[0][0]
12/35: def disparity_matrix():
12/36: def disparity_matrix():
12/37:
def disparity_matrix():
    return
12/38: x,y = [1,2]
12/39:
x,y = [1,2]
x
12/40: h = np.zeros((2,2,3),dtype=np.uint8)
12/41: h
12/42: h = np.zeros((2,2),dtype=np.uint8)
12/43: h
12/44: h+[1,1]
12/45: h+[1,2]
12/46: [1,2]+[0.3,0.4]
12/47: np.array([1,2])+[0.3,0.4]
12/48: np.array([1,2])+[0.3,0.4]
12/49: F = np.array([1,2])+[0.3,0.4]
12/50:
F = np.array([1,2])+[0.3,0.4]
np.floor(F)
12/51: I
12/52: I.shape
12/53: I[0]
12/54: I[0][320]
12/55: I[0][319]
12/56:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w),dtype=np.uint8)
    for i in range(w):
        for j in range(h):
            Coord = np.array([i,j])+disparity
            if Coord[0]>w-1:
                Coord[0] = w
            if Coord[1]>h-1:
                Coord[1] = h
            White_image[i][j] = np.floor(Coord)
    return White_image
12/57:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Image,w,h):
    #White Image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    Bias_map = np.zeros(h,w,3),dtype=np.uint8)
    for i in range(w):
        for j in range(h):
            u,v = Bias_map[i][j]
            White_image[i][j] = Image[u][v]
    return image
12/58:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Image,w,h):
    #White Image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    Bias_map = np.zeros((h,w,3),dtype=np.uint8)
    for i in range(w):
        for j in range(h):
            u,v = Bias_map[i][j]
            White_image[i][j] = Image[u][v]
    return image
12/59:
x_,y_ = [2,0]
[[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
12/60:
x_,y_ = [1,2]
[[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
12/61:
def Q_interpolator2(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    Bias = np.array([[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]])-[x,y]
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo(x_,y_)
    p2 = get_photo(x_+1,y_)
    p3 = get_photo(x_,y_-1)
    p4 = get_photo(x_+1,y_-1)
    return Blend_4([p1,p2,p3,p4],normalize(w))
12/62:
I = Q_interpolator2([0.3,0.8])
show_img(I)
12/63:
def Q_interpolator2(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    Bias = np.array([[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]])-[x,y]
    print(Bias)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo(x_,y_)
    p2 = get_photo(x_+1,y_)
    p3 = get_photo(x_,y_-1)
    p4 = get_photo(x_+1,y_-1)
    return Blend_4([p1,p2,p3,p4],normalize(w))
12/64:
I = Q_interpolator2([0.3,0.8])
show_img(I)
13/1:
import os
import imageio
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))
13/2:
import numpy as np
import math
13/3:
def img_2_matrix(img):
    return img.reshape(320*240,3)
def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
13/4:
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
13/5:
from PIL import Image 
def show_img(img):
    im=Image.fromarray(img) 
    im.show()
13/6:
from PIL import Image 
def show_img(img):
    im=Image.fromarray(img) 
    im.show()
13/7:
#get the photo [320*240] as a vector with the uv coord(x,y)
def get_photo(x,y):
    index = 255-x-16*y
    return Data[index]
13/8:
def Blend_4(P,w):
    Image = np.zeros((76800,3),dtype=np.uint8)
    for i in range(len(P)):
        Temp = (np.floor(P[i]*w[i])).astype(np.uint8)
        Image = Image + Temp
    return matrix_2_img(Image)
13/9:
def normalize(v):
    norm=np.linalg.norm(v, ord=1)
    if norm==0:
        norm=np.finfo(v.dtype).eps
    return v/norm
13/10:
#x(0,15),y(0,15)
def Q_interpolator(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo(x_,y_)
    p2 = get_photo(x_+1,y_)
    p3 = get_photo(x_,y_-1)
    p4 = get_photo(x_+1,y_-1)
    return Blend_4([p1,p2,p3,p4],normalize(w))
13/11:
I = Q_interpolator([0.3,0.8])
show_img(I)
13/12:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w),dtype=np.uint8)
    for i in range(w):
        for j in range(h):
            Coord = np.array([i,j])+disparity
            if Coord[0]>w-1:
                Coord[0] = w
            if Coord[1]>h-1:
                Coord[1] = h
            White_image[i][j] = np.floor(Coord)
    return White_image
13/13:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for i in range(w):
        for j in range(h):
            u,v = Bias_map[i][j]
            White_image[i][j] = Image[u][v]
    return White_image
13/14:
def Q_interpolator2(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
    Bias = np.array(Square)-[x,y]
    #The bais for 4 photo
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    P = [get_photo(Square[i]) for i in range(len(Square))]
    #get the Bias matrix
    Bias_M = disparity_matrix(Bias[0],240,320)#(disparity,h,w)
    redo_image = re_image(get_photo(P[0]),Bias_M,320,240)
    return redo_image
13/15:
I = Q_interpolator2([0.3,0.8])
show_img(I)
13/16:
def Q_interpolator2(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
    Bias = np.array(Square)-[x,y]
    #The bais for 4 photo
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    P = [get_photo(Square[i][0],Square[i][1]) for i in range(len(Square))]
    #get the Bias matrix
    Bias_M = disparity_matrix(Bias[0],240,320)#(disparity,h,w)
    redo_image = re_image(get_photo(P[0]),Bias_M,320,240)
    return redo_image
13/17:
I = Q_interpolator2([0.3,0.8])
show_img(I)|
13/18:
I = Q_interpolator2([0.3,0.8])
show_img(I)
13/19:
def Q_interpolator2(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
    Bias = np.array(Square)-[x,y]
    #The bais for 4 photo
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    P = [get_photo(Square[i][0],Square[i][1]) for i in range(len(Square))]
    #get the Bias matrix
    print (Bias[0])
    Bias_M = disparity_matrix(Bias[0],240,320)#(disparity,h,w)
    redo_image = re_image(get_photo(P[0]),Bias_M,320,240)
    return redo_image
13/20:
I = Q_interpolator2([0.3,0.8])
show_img(I)
13/21: disparity_matrix([-0.3,0.2])
13/22: disparity_matrix([-0.3,0.2],240,320)
13/23:
def Q_interpolator2(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
    Bias = np.array(Square)-[x,y]
    #The bais for 4 photo
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    P = [get_photo(Square[i][0],Square[i][1]) for i in range(len(Square))]
    '''
    #get the Bias matrix
    print (Bias[0])
    Bias_M = disparity_matrix(Bias[0],240,320)#(disparity,h,w)
    redo_image = re_image(get_photo(P[0]),Bias_M,320,240)
    '''
    return Bias
13/24:
I = Q_interpolator2([0.3,0.8])
I
13/25:
x_bias,y_bias = I[0]
White_image = np.zeros((h,w),dtype=np.uint8)
for i in range(w):
    for j in range(h):
        Coord = np.array([i,j])+disparity
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
13/26:
x_bias,y_bias = I[0]
h = 240
w = 320
White_image = np.zeros((h,w),dtype=np.uint8)
for i in range(w):
    for j in range(h):
        Coord = np.array([i,j])+disparity
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
13/27: [1,2]*[2,3]
13/28:
x_bias,y_bias = I[0]
h = 240
w = 320

White_image = np.zeros((h,w),dtype=np.uint8)
for i in range(w):
    for j in range(h):
        Coord = np.array([i,j])+[disparity[0]*x_bias,disparity[1]*y_bias]
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
13/29:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w),dtype=np.uint8)
for i in range(w):
    for j in range(h):
        Coord = np.array([i,j])+[disparity[0]*x_bias,disparity[1]*y_bias]
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
13/30:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w),dtype=np.uint8)
for i in range(w):
    for j in range(h):
        Coord = np.array([i,j])+[disparity[0]*x_bias,disparity[1]*y_bias]
        print (Coord)
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
13/31: Coord
13/32: np.floor(Coord)
13/33:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for i in range(w):
    for j in range(h):
        Coord = np.array([i,j])+[disparity[0]*x_bias,disparity[1]*y_bias]
        print (Coord)
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
13/34:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for i in range(w):
    for j in range(h):
        Coord = np.array([i,j])+[disparity[0]*x_bias,disparity[1]*y_bias]
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
13/35: White_image
13/36: White_image.shape
13/37: White_image[0]
13/38: White_image[0].shape
13/39: White_image[0][0].shape
13/40: White_image[0][0]
13/41:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for i in range(w):
    for j in range(h):
        Coord = np.array([i,j])+[disparity[0]*x_bias,disparity[1]*y_bias]
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
        break
13/42:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for i in range(w):
    for j in range(h):
        Coord = np.array([i,j])+[disparity[0]*x_bias,disparity[1]*y_bias]
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        print Coord
        White_image[i][j] = np.floor(Coord)
        break
13/43:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for i in range(w):
    for j in range(h):
        Coord = np.array([i,j])+[disparity[0]*x_bias,disparity[1]*y_bias]
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        print (Coord)
        White_image[i][j] = np.floor(Coord)
        break
13/44:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for i in range(w):
    for j in range(h):
        Coord = np.array([i,j])+[disparity[0]*x_bias,disparity[1]*y_bias]
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        print (i,j)
        White_image[i][j] = np.floor(Coord)
        break
13/45:
for i in range(3):
    print (i)
13/46: White_image[0][239]
13/47:
for i in range(10):
    for j in range(10,20):
        print (i,j)
13/48:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for i in range(w):
    for j in range(h):
        print (i,j)
        Coord = np.array([i,j])+[disparity[0]*x_bias,disparity[1]*y_bias]
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
        break
13/49:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for i in range(w):
    for j in range(h):
        print (i,j)
        Coord = np.array([i,j])+[disparity[0]*x_bias,disparity[1]*y_bias]
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
        break
13/50:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        print (x,y)
        '''
        Coord = np.array([i,j])+[disparity[0]*x_bias,disparity[1]*y_bias]
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
        break
        '''
13/51:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+[disparity[0]*x_bias,disparity[1]*y_bias]
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        White_image[x][y] = np.floor(Coord)
        break
        '''
13/52:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+[disparity[0]*x_bias,disparity[1]*y_bias]
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        White_image[x][y] = np.floor(Coord)
        break
13/53:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+[disparity[0]*x_bias,disparity[1]*y_bias]
        break
13/54:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+[disparity[0]*x_bias,disparity[1]*y_bias]
        break
        print (Coord)
13/55:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+[disparity[0]*x_bias,disparity[1]*y_bias]
        print (Coord)
    break
13/56:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+[disparity[0]*x_bias,disparity[1]*y_bias]
        print np.floor(Coord)
13/57:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+[disparity[0]*x_bias,disparity[1]*y_bias]
        print (np.floor(Coord))
13/58:
x_bias,y_bias = I[0]
print*()
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+[disparity[0]*x_bias,disparity[1]*y_bias]
        break
13/59:
x_bias,y_bias = I[0]
print (x_bias,y_bias)
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+[disparity[0]*x_bias,disparity[1]*y_bias]
        break
13/60:
x_bias,y_bias = I[0]
print (x_bias,y_bias)
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+[disparity[0]*x_bias,disparity[1]*y_bias]
        break
13/61:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    print(x)
    for y in range(h):
        Coord = np.array([x,y])+[disparity[0]*x_bias,disparity[1]*y_bias]
        break
13/62:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    print(x)
13/63:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        print(x,y)
        Coord = np.array([x,y])+[disparity[0]*x_bias,disparity[1]*y_bias]
        break
13/64:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        print(x,y)
        break
13/65:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        print(x,y)
            break
13/66:
x_bias,y_bias = I[0]
h = 240
w = 320
disparity = [0.2,0.1]
White_image = np.zeros((h,w,2),dtype=np.uint8)
13/67:
for x in range(w):
    for y in range(h):
        print(x,y)
        Coord = np.array([x,y])+[disparity[0]*x_bias,disparity[1]*y_bias]
        break
13/68:
for x in range(w):
    for y in range(h):
        print(x,y)
        break
13/69:
for x in range(320):
    for y in range(240):
        print(x,y)
        Coord = np.array([x,y])+[disparity[0]*x_bias,disparity[1]*y_bias]
        break
14/1:
for x in range(320):
    for y in range(240):
        print(x,y)
        break
14/2:
for y in range(320):
    for x in range(240):
        print(x,y)
        Coord = np.array([x,y])+[disparity[0]*x_bias,disparity[1]*y_bias]
        break
14/3:
for y in range(240):
    for x in range(320):
        print(x,y)
        Coord = np.array([x,y])+[disparity[0]*x_bias,disparity[1]*y_bias]
        break
14/4:
for y in range(240):
    for x in range(320):
        print(x,y)
        break
14/5:
for x in range(320):
    for y in range(240):
        print(x,y)
        Coord = np.array([x,y])+[disparity[0]*x_bias,disparity[1]*y_bias]
14/6: X = [[[i,j] for i in range(320)] for j in range(240)]
14/7: import numpy as np
14/8: X = np.array(X)
14/9: X.shape
14/10: X[0]
14/11: X[0][0]
14/12: X[0][1]
14/13: X = [[[j,i] for i in range(320)] for j in range(240)]
14/14: X = np.array(X)
14/15: X[0][1]
14/16: X.shape
14/17: X[0]
14/18: X[0].shape
15/1:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

"""
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
"""

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)

def print1(i):
    print(i)
    
s = Scale(root,label='try me', from=0, to=100, orient=HORIZONTAL, length=200, showvalue=0,tickinterval=20, resolution=0.1, command=print1)
s.pack()

root.mainloop()
15/2:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

"""
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
"""

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)
    
s = Scale(root,label='try me', from=0, to=100, orient=HORIZONTAL, length=200, showvalue=0,tickinterval=20, resolution=0.1, command=print1)
s.pack()

root.mainloop()
15/3:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

"""
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
"""

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)
    
s = Scale(root,label='try me', from=0, to=100, orient=HORIZONTAL, length=200, showvalue=0,tickinterval=20, resolution=0.1, command=print)
s.pack()

root.mainloop()
15/4:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

"""
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
"""

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)

def print1(i):
    print(i)
    
s = Scale(root,label='try me', from=0, to=100, orient=HORIZONTAL, length=200, showvalue=0,tickinterval=20, resolution=0.1, command=print1)
s.pack()

root.mainloop()
15/5:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

"""
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
"""

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)

def print1(i):
    print(i)
    
s = Scale(root,label='try me', from=0, to=100, orient=HORIZONTAL, length=200, showvalue=0,tickinterval=20, resolution=0.1, command = print1)
s.pack()

root.mainloop()
15/6:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

"""
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
"""

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)

def print1(i):
    print(i)
    
s = Scale(root,label='try me', from=0, to=100, orient=HORIZONTAL, length=200, showvalue=0,tickinterval=20, resolution=0.1, command = print1(i))
s.pack()

root.mainloop()
15/7:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

"""
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
"""

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)

def print1(i):
    print(i)
    
s = Scale(root,label='try me', from=0, to=100, orient=HORIZONTAL, length=200, showvalue=0,tickinterval=20, resolution=0.1, command = print1(1))
s.pack()

root.mainloop()
15/8:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

"""
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
"""

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)

def print1(i):
    print(i)
    
s = Scale(root,label='try me', from=0, to=100, 
          orient=HORIZONTAL, length=200, showvalue=0,tickinterval=20, resolution=0.1, command=print1(1))
s.pack()

root.mainloop()
15/9:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

"""
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
"""

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)

def print1(i):
    print(i)
    
s = Scale(root,label='try me', from=0, to=100, 
          orient=HORIZONTAL, length=200, showvalue=0,tickinterval=20, resolution=0.1)
s.pack()

root.mainloop()
15/10:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

"""
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
"""

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)

root.mainloop()
15/11:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()

"""
#Image Display
img_png = Tkinter.PhotoImage(file = 'img_png.png')
label_img = Tkinter.Label(root, image = img_png)
label_img.pack()
"""

var = DoubleVar()
Disparity = Scale(root, variable = var )
Disparity.pack(side = LEFT)

var = DoubleVar()
scale_2 = Scale( root, variable = var )
scale_2.pack(anchor=W)

root.mainloop()
15/12:
import tkinter as tk
 
root = tk.Tk()

tk.Scale(root, from_=0, to=42, tickinterval=5, length=200, \
      resolution=5, orient="vertical").pack()
tk.Scale(root, from_=0, to=200, tickinterval=10, length=600, \
      orient="horizontal").pack()
 
root.mainloop()
15/13:
import tkinter as tk
 
root = tk.Tk()

tk.Scale(root, from_=0, to=16, tickinterval=0.1, length=640, \
      resolution=5, orient="vertical").pack()
tk.Scale(root, from_=0, to=16, tickinterval=10, length=480, \
      orient="horizontal").pack()
 
root.mainloop()
15/14:
import tkinter as tk
 
root = tk.Tk()

tk.Scale(root, from_=0, to=16, tickinterval=0.1, length=640, \
      resolution=5, orient="vertical").pack()
tk.Scale(root, from_=0, to=16, tickinterval=0.1, length=480, \
      orient="horizontal").pack()
 
root.mainloop()
15/15:
import tkinter as tk
 
root = tk.Tk()

tk.Scale(root, from_=0, to=16, tickinterval=0.1, length=640, \
      resolution=0.1, orient="vertical").pack()
tk.Scale(root, from_=0, to=16, tickinterval=0.1, length=480, \
      orient="horizontal").pack()
 
root.mainloop()
15/16:
import tkinter as tk
 
root = tk.Tk()

tk.Scale(root, from_=0, to=16, tickinterval=0.1, length=480, \
      resolution=0.1, orient="vertical").pack()
tk.Scale(root, from_=0, to=16, tickinterval=0.1, length=640, \
      resolution=0.1,orient="horizontal").pack()
 
root.mainloop()
15/17:
import tkinter as tk
 
root = tk.Tk()

tk.Scale(root, from_=0, to=16, tickinterval=0.1, length=480, \
       orient="vertical").pack()
tk.Scale(root, from_=0, to=16, tickinterval=0.1, length=640, \
      resolution=0.1,orient="horizontal").pack()
 
root.mainloop()
15/18:
import tkinter as tk
 
root = tk.Tk()

tk.Scale(root, from_=0, to=16.0, tickinterval=0.1, length=480, \
       orient="vertical").pack()
tk.Scale(root, from_=0, to=16, tickinterval=0.1, length=640, \
      resolution=0.1,orient="horizontal").pack()
 
root.mainloop()
15/19:
import tkinter as tk
 
root = tk.Tk()

tk.Scale(root, from_=0, to=16，length=480, \
      resolution=0.1, orient="vertical").pack()
tk.Scale(root, from_=0, to=16, tickinterval=0.1, length=640, \
      resolution=0.1,orient="horizontal").pack()

def show():
        print(s1.get(), s2.get())
 
root.mainloop()
15/20:
import tkinter as tk
 
root = tk.Tk()

tk.Scale(root, from_=0, to=16 ，length=480, \
      resolution=0.1, orient="vertical").pack()
tk.Scale(root, from_=0, to=16, tickinterval=0.1, length=640, \
      resolution=0.1,orient="horizontal").pack()

def show():
        print(s1.get(), s2.get())
 
root.mainloop()
15/21:
import tkinter as tk
 
root = tk.Tk()

tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical").pack()
tk.Scale(root, from_=0, to=16, tickinterval=0.1, length=640, \
      resolution=0.1,orient="horizontal").pack()

def show():
        print(s1.get(), s2.get())
 
root.mainloop()
15/22:
import tkinter as tk
 
root = tk.Tk()

tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical").pack()
tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal").pack()

def show():
        print(s1.get(), s2.get())
 
root.mainloop()
15/23:
import tkinter as tk
 
root = tk.Tk()

tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical").pack(side = LEFT)
tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal").pack()

def show():
        print(s1.get(), s2.get())
 
root.mainloop()
15/24:
import tkinter as tk
 
root = tk.Tk()

X = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical").pack(side = LEFT)
Y = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal").pack()

def show():
        print(s1.get(), s2.get())
 
root.mainloop()
15/25:
import tkinter as tk
 
root = tk.Tk()

X = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical").pack(ipady=10)
Y = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal").pack()

def show():
        print(s1.get(), s2.get())
 
root.mainloop()
15/26:
import tkinter as tk
 
root = tk.Tk()

X = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical").pack(ipady=10)
Y = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal").pack(ipadx=10)

def show():
        print(s1.get(), s2.get())
 
root.mainloop()
15/27:
import tkinter as tk
 
root = tk.Tk()

X = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical").pack(ipady=10)
Y = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal").pack(ipadx=10)

def show():
        print(s1.get(), s2.get())
 
root.mainloop()
15/28:
import tkinter as tk
 
root = tk.Tk()

X = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical").pack(ipady=10)
Y = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal").pack(ipadx=10)

def show():
        print(s1.get(), s2.get())
 
root.mainloop()
15/29:
import tkinter as tk
 
root = tk.Tk()

X = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical").pack(ipady=30)
Y = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal").pack(ipadx=10)

def show():
        print(s1.get(), s2.get())
 
root.mainloop()
15/30:
import tkinter as tk
 
root = tk.Tk()

X = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical").pack(ipadx =1)
Y = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal").pack(ipadx=10)

def show():
        print(s1.get(), s2.get())
 
root.mainloop()
15/31:
import tkinter as tk
 
root = tk.Tk()

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical").pack(side = left)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal").pack(side = bottom)

def show():
        print(s1.get(), s2.get())
 
root.mainloop()
15/32:
import tkinter as tk
 
root = tk.Tk()

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical").pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal").pack(side = BOTTOM)

def show():
        print(s1.get(), s2.get())
 
root.mainloop()
15/33:
import tkinter as tk
 
root = tk.Tk()

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical").pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal").pack(side = BOTTOM)
X = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal").pack(side = BOTTOM)

def show():
        print(s1.get(), s2.get())
 
root.mainloop()
15/34:
import tkinter as tk
 
root = tk.Tk()

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",text = "Y").pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal").pack(side = BOTTOM)
X = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal").pack(side = BOTTOM)

def show():
        print(s1.get(), s2.get())
 
root.mainloop()
15/35:
import tkinter as tk
 
root = tk.Tk()

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y").pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal").pack(side = BOTTOM)
X = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal").pack(side = BOTTOM)

def show():
        print(s1.get(), s2.get())
 
root.mainloop()
15/36:
import tkinter as tk
 
root = tk.Tk()

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z").pack(side = BOTTOM)

def display():
        print(Y.get())
root.mainloop()
15/37:
import tkinter as tk
 
root = tk.Tk()

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=640, \
      resolution=0.1,orient="horizontal",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=640, \
      resolution=0.1,orient="horizontal",label = "D_y",command = display).pack(side = RIGHT)

def display():
        print(Y.get())
root.mainloop()
15/38:
import tkinter as tk
 
root = tk.Tk()

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)

def display():
        print(Y.get())
root.mainloop()
15/39:
import tkinter as tk
 
root = tk.Tk()

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)

def display():
        print(Y.get())
root.mainloop()
15/40:
import tkinter as tk
 
root = tk.Tk()

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)

def display():
        print(Y.get())
root.mainloop()
15/41:
import tkinter as tk
 
root = tk.Tk()

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = ).pack(side = LEFT)'''
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''
root.mainloop()
15/42:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = lambda para['Y'] = Y.get()).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''
root.mainloop()
15/43:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = lambda :para['Y'] = Y.get()).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''
root.mainloop()
15/44:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = lambda:para['Y'] = Y.get()).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''
root.mainloop()
15/45:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = update_Y).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''
root.mainloop()
15/46:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = update_Y).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''

def display():
    print(Y.get())
root.mainloop()
15/47:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''

def display():
    print(Y.get())
root.mainloop()
15/48:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display()).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''

def display():
    print(Y.get())
root.mainloop()
15/49:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display(self)).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''

def display():
    print(Y.get())
root.mainloop()
15/50:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display.pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''

def display():
    print(Y.get())
root.mainloop()
15/51:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''

def display():
    print(Y.get())
root.mainloop()
15/52:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''

def display(self):
    print(Y.get())
root.mainloop()
15/53:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''

def display():
    print Y.get()
root.mainloop()
15/54:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''

def display():
    print (Y.get())
root.mainloop()
15/55:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''

def display():
    a = Y.get()
    print(a)
root.mainloop()
15/56:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''

def display():
    a = Y.get()
    print(a)
root.mainloop()
15/57:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display(Y.get())).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''

def display(s):
    print(s)
root.mainloop()
15/58:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display(self.get())).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''

def display(s):
    print()
root.mainloop()
15/59:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''

def sel():
    print Y.get()
    
root.mainloop()
15/60:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''

def sel():
    print Y.get()
root.mainloop()
15/61:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''

def sel():
    print (Y.get())
root.mainloop()
15/62:
import tkinter as tk
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''

def display():
    print (Y.get())
    
root.mainloop()
15/63:
import tkinter as tk
 
root = tk.Tk()
para = {}


Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''

    
root.mainloop()
15/64:
import tkinter as tk
 
root = tk.Tk()
para = {}

def display():
    print (Y.get())
Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.1,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''

    
root.mainloop()
15/65: def aperture_size(coord,r):
15/66:
def aperture_size(coord,r):
    return
15/67:
def aperture_size(coord,r):
    Max = coord+r
    Min = coord-r
    return print(Max)
15/68: aperture_size([0.5,0.5],2)
15/69:
def aperture_size(coord,r):
    Max = np.array(coord)+r
    Min = np.array(coord)-r
    return print(Max)
15/70: aperture_size([0.5,0.5],2)
15/71: import numpy as np
15/72:
def aperture_size(coord,r):
    Max = np.array(coord)+r
    Min = np.array(coord)-r
    return print(Max)
15/73: aperture_size([0.5,0.5],2)
15/74:
def scale_by_z(Z_,image):
    W = 320
    h = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    print(W*Range)
    print(H*Range)
15/75: scale_by_z(0.8,0)
15/76:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    print(W*Range)
    print(H*Range)
15/77:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    print(W*Range)
    print(H*Range)
15/78: scale_by_z(0.8,0)
15/79: a = [[1,2],[3,4]]
15/80: a = [[1,2,3],[3,4,5],[5,6,7]]
15/81: a= np.array(a)
15/82: a[1:2][1:2]
15/83: a
15/84: a[0]
15/85: a[1:2]
15/86: a[1:]
15/87:
import os
import imageio
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))
15/88:
import numpy as np
import math
15/89:
def img_2_matrix(img):
    return img.reshape(320*240,3)
def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
15/90:
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
15/91: Data[0]
15/92: Data[0].shape
15/93: matrix_2_img(Data[0])
15/94:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    print(W*Range)
    print(H*Range)
15/95: scale_by_z(0.9,0)
15/96: matrix_2_img(Data[0])[16:304][12:228]
15/97:
from PIL import Image 
def show_img(img):
    im=Image.fromarray(img) 
    im.show()
15/98:
#get the photo [320*240] as a vector with the uv coord(x,y)
def get_photo(x,y):
    index = 255-x-16*y
    return Data[index]
15/99: show_img(matrix_2_img(Data[0])[16:304][12:228])
15/100: scale_by_z(0.5,0)
15/101:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    #print(H*Range
    return W*Range
15/102: scale_by_z(0.5,0)
15/103: Index = scale_by_z(0.5,0)
15/104: Index[0]
15/105: Index
15/106: Data[0][Index][:]
15/107: list(Index)
15/108:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    y = H*Range
    x = W*Range
    image[x[0]:x[1]][y[0]:y[1]]
    return image
15/109: image = matrix_2_img(Data[0])
15/110:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    y = H*Range
    x = W*Range
    image = image[x[0]:x[1]][y[0]:y[1]]
    return image
15/111: I = show_img(scale_by_z(0.5,image))
15/112:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    y = int(H*Range)
    x = W*Range
    image = image[x[0]:x[1]][y[0]:y[1]]
    return image
15/113:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    y = int(H*Range)
    x = W*Range
    image = image[x[0]:x[1]][y[0]:y[1]]
    return image
15/114:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    y = int(H*Range)
    print (y)
    x = W*Range
    image = image[x[0]:x[1]][y[0]:y[1]]
    return image
15/115: I = show_img(scale_by_z(0.5,image))
15/116:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    y = H*Range
    print (y)
    x = W*Range
    image = image[x[0]:x[1]][y[0]:y[1]]
    return image
15/117: I = show_img(scale_by_z(0.5,image))
15/118:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    y = (H*Range).astype(int) 
    x = (W*Range).astype(int) 
    image = image[x[0]:x[1]][y[0]:y[1]]
    return image
15/119: I = show_img(scale_by_z(0.5,image))
15/120:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    y = (H*Range).astype(int) 
    x = (W*Range).astype(int) 
    print(x)
    print(y)
    image = image[x[0]:x[1]][y[0]:y[1]]
    return image
15/121: image = matrix_2_img(Data[0])
15/122: I = show_img(scale_by_z(0.5,image))
15/123:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    y = (H*Range).astype(int) 
    x = (W*Range).astype(int) 
    print(x)
    print(y)
    image = image[x[0]:x[1]][y[0]:y[1]]
    print (image.shape)
    return image
15/124: I = show_img(scale_by_z(0.5,image))
15/125:
image = matrix_2_img(Data[0])
image[80:240][60:180]
15/126:
image = matrix_2_img(Data[0])
image[80:240][60:180].shape
15/127:
image = matrix_2_img(Data[0])
image[80:240].shape
15/128:
image = matrix_2_img(Data[0])
image[80:240].shape
15/129:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    y = (H*Range).astype(int) 
    x = (W*Range).astype(int) 
    print(x)
    print(y)
    image = image[x[0]:x[1],y[0]:y[1]]
    print (image.shape)
    return image
15/130: I = show_img(scale_by_z(0.5,image))
15/131:
image = matrix_2_img(Data[0])
show_img(image)
15/132: I = show_img(scale_by_z(0.5,image))
15/133: I = show_img(scale_by_z(0.5,image))
15/134:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    y = (H*Range).astype(int) 
    x = (W*Range).astype(int) 
    print(x)
    print(y)
    image = image[y[0]:y[1],x[0]:x[1]]
    print (image.shape)
    return image
15/135: I = show_img(scale_by_z(0.5,image))
15/136:
image = matrix_2_img(Data[0])
show_img(image)
15/137: import Image
15/138: Image.resize(I)
15/139: Image.open(I)
15/140: im = Image.fromarray(I)
15/141: I
15/142: I
15/143: I = show_img(scale_by_z(0.5,image))
15/144:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    y = (H*Range).astype(int) 
    x = (W*Range).astype(int) 
    image = image[y[0]:y[1],x[0]:x[1]]
    return image
15/145: scale_by_z(0.5,image))
15/146: scale_by_z(0.5,image)
15/147: I = Image.fromarray(scale_by_z(0.5,image)))
15/148: I = Image.fromarray(scale_by_z(0.5,image))
15/149: T = I.resize((320,240,3))
15/150: T = I.resize((320,240))
15/151: T.show()
15/152: I
15/153: I = Image.fromarray(scale_by_z(0.5,image)).resize((320,240))
15/154: numpy.array(I)
15/155: np.array(I)
15/156: T = np.array(I)
15/157: T.shape
15/158: show_img(T)
15/159: show_img(Data[0])
15/160: show_img(Data[0])
15/161: show_img(Data[0])
15/162: show(matrix_2_img(Data[0]))
15/163: show_img(matrix_2_img(Data[0]))
15/164:
P = matrix_2_img(Data[0])
show_img(P)
Image.fromarray(scale_by_z(0.7,P)).resize((320,240)).show()
15/165:
P = matrix_2_img(Data[0])
show_img(P)
Image.fromarray(scale_by_z(0.1,P)).resize((320,240)).show()
15/166:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    y = (H*Range).astype(int) 
    x = (W*Range).astype(int) 
    image = image[y[0]:y[1],x[0]:x[1]]
    I = Image.fromarray(image).resize((320,240))
    return np.array(I)
15/167: scale_by_z(0.5,matrix_2_img(Data[0]))
15/168: scale_by_z(0.5,matrix_2_img(Data[0])).shape
15/169: I = [0.5,0.5]
15/170: np.upper([1.1,2.2])
15/171: np.np.ceil([1.1,2.2])
15/172: np.ceil([1.1,2.2])
15/173:
#Input the Coord of the adperture,get arround
def Get_arround_set(coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    print (x1y1)
    print (x4y4)
15/174: Get_arround_set([1.2,1.8],2)
15/175:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    print (x1y1)
    print (x4y4)
15/176: Get_arround_set([1.2,1.8],2)
15/177: Get_arround_set([1.2,1.8],1)
15/178:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    for i in range(x1y1[0],x4y4[0]):
        for j in range(x1y1[1],x4y4[1]):
            print (i,j)
15/179: Get_arround_set([1.2,1.8],1)
15/180:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    for i in range(x1y1[0],x4y4[0]):
        for j in range(x1y1[1],x4y4[1]):
            print (i,j)
15/181: Get_arround_set([1.2,1.8],1)
15/182:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    print(x1y1)
    for i in range(x1y1[0],x4y4[0]):
        for j in range(x1y1[1],x4y4[1]):
            print (i,j)
15/183: Get_arround_set([1.2,1.8],1)
15/184:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    print(x1y1)
    print(x4y4)
    for i in range(x1y1[0],x4y4[0]):
        for j in range(x1y1[1],x4y4[1]):
            print (i,j)
15/185: Get_arround_set([1.2,1.8],1)
15/186:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    print(x1y1[0])
    print(x4y4[0])
    for i in range(x1y1[0],x4y4[0]):
        for j in range(x1y1[1],x4y4[1]):
            print (i,j)
15/187: Get_arround_set([1.2,1.8],1)
15/188:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    print(x1y1[0])
    print(x4y4[0])
    for i in range(x1y1[0],x4y4[0]):
        for j in range(x1y1[1],x4y4[1]):
            print(i,j)
15/189: Get_arround_set([1.2,1.8],1)
15/190:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    for i in range(x1y1[0],x4y4[0]):
        print(i)
        for j in range(x1y1[1],x4y4[1]):
            print(i,j)
15/191: Get_arround_set([1.2,1.8],1)
15/192:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    for i in range(x1y1[0],x4y4[0]+1):
        print(i)
        for j in range(x1y1[1],x4y4[1]+1):
            print(j)
            print(i,j)
15/193: Get_arround_set([1.2,1.8],1)
15/194:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    for i in range(x1y1[0],x4y4[0]+1):
        print(i)
        for j in range(x1y1[1],x4y4[1]+1):
            print(j)
15/195: Get_arround_set([1.2,1.8],1)
15/196:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    for i in range(x1y1[0],x4y4[0]+1):
        print(i)
        for j in range(x4y4[1],x1y1[1]):
            print(j)
15/197: Get_arround_set([1.2,1.8],1)
15/198:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    for i in range(x1y1[0],x4y4[0]+1):
        for j in range(x4y4[1],x1y1[1]+1):
            print(i,j)
15/199: Get_arround_set([1.2,1.8],1)
15/200:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    print(Up)
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    print(Down)
    Left = [[x1y1[0],i] for i in range(x4y4[1],x1y1[1]+1)]
    print(Left)
    Right = [[x1y1[0],i] for i in range(x4y4[1],x1y1[1]+1)]
    print(Right)
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Inner.append(Temp)
15/201: Get_arround_set([1.2,1.8],1)
15/202:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    print(Up)
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    print(Down)
    Left = [[x1y1[0]+1,i] for i in range(x4y4[1],x1y1[1])]
    print(Left)
    Right = [[x1y1[0]+1,i] for i in range(x4y4[1],x1y1[1])]
    print(Right)
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Inner.append(Temp)
15/203: Get_arround_set([1.2,1.8],1)
15/204:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    print(Up)
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    print(Down)
    Left = [[x1y1[0],i+1] for i in range(x4y4[1],x1y1[1])]
    print(Left)
    Right = [[x4y4[0],i+1] for i in range(x4y4[1],x1y1[1])]
    print(Right)
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Inner.append(Temp)
15/205: Get_arround_set([1.2,1.8],1)
15/206:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    print(Up)
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    print(Down)
    Left = [[x1y1[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    print(Left)
    Right = [[x4y4[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    print(Right)
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Inner.append(Temp)
15/207: Get_arround_set([1.2,1.8],1)
15/208: Get_arround_set([2.3,2.6],1)
15/209: Get_arround_set([2.3,2.6],2)
15/210:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Left = [[x1y1[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Right = [[x4y4[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Outer = Up+Down+Left+Right
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Inner.append(Temp)
    print(Inner)
15/211: Get_arround_set([2.3,2.6],2)
15/212:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Left = [[x1y1[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Right = [[x4y4[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Outer = Up+Down+Left+Right
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Temp.append([i,j])
        Inner.append(Temp)
    print(Inner)
15/213: Get_arround_set([2.3,2.6],2)
15/214: Get_arround_set([1.3,1.6],1)
15/215: Get_arround_set([2.3,2.6],2)
15/216:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Left = [[x1y1[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Right = [[x4y4[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Outer = Up+Down+Left+Right
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Temp.append([i,j])
        Inner.append(Temp)
    return list(set(Inner))
15/217: Get_arround_set([2.3,2.6],2)
15/218:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Left = [[x1y1[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Right = [[x4y4[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Outer = Up+Down+Left+Right
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Temp.append([i,j])
        Inner.append(Temp)
    return list(set(Inner))
15/219:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Left = [[x1y1[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Right = [[x4y4[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Outer = Up+Down+Left+Right
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Temp.append([i,j])
        Inner.append(Temp)
    return set(Inner)
15/220: Get_arround_set([2.3,2.6],2)
15/221:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Left = [[x1y1[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Right = [[x4y4[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Outer = Up+Down+Left+Right
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Temp.append([i,j])
        Inner.append(Temp)
    return Inner
15/222: Get_arround_set([2.3,2.6],2)
15/223: Get_arround_set([2.0,2.0],2)
15/224: Get_arround_set([2.1,2.0],2)
15/225: Get_arround_set([2.1,2.1],2)
15/226: A = Get_arround_set([2.1,2.1],2)
15/227:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Left = [[x1y1[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Right = [[x4y4[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Outer = Up+Down+Left+Right
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Temp.append([i,j])
        Inner = Inner + Temp
    return Inner
15/228: A = Get_arround_set([2.1,2.1],2)
15/229: set(A)
15/230: A
15/231: Get_arround_set([2.1,2.6],2)
15/232: Get_arround_set([2.1,2.6],2)
15/233: A,B = Get_arround_set([2.1,2.6],2)
15/234:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Left = [[x1y1[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Right = [[x4y4[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Outer = Up+Down+Left+Right
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Temp.append([i,j])
        Inner = Inner + Temp
    return Inner,Outer
15/235: A,B = Get_arround_set([2.1,2.6],2)
15/236: A
15/237: B
15/238:
center = [2.1,2.6]
A = np.array(A)
15/239: A-center
15/240: (A-center)^2
15/241: (A-center)**2
15/242: np.sum((A-center)**2,axis=1)
15/243:
E = np.sum((A-center)**2,axis=1)
E = E**0.5
15/244:
E = np.sum((A-center)**2,axis=1)
E = E**0.5
E
15/245:
center = [2.1,2.6]
A = np.array(A)
A
E = np.sum((A-center)**2,axis=1)
E = E**0.5
E
15/246:
center = [2.1,2.6]
A = np.array(A)
A
15/247:
E = np.sum((A-center)**2,axis=1)
E
15/248:
E = (A-center)**2
E
M = np.sum(E,axis=1)
15/249:
E = (A-center)**2
E
15/250:
E = (A-center)
E
15/251:
E = (A-center)**2
E
15/252:
M = np.sum((A-center)**2,axis=1)
M**0.5
15/253: M = (np.sum((A-center)**2,axis=1))**0.5
15/254:
M = (np.sum((A-center)**2,axis=1))**0.5
M
15/255:
def Get_distence(A,center):
    return (np.sum((A-center)**2,axis=1))**0.5
15/256:
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
15/257: Inner_distence = Get_distence(A,center)
15/258: Inner_distence
15/259: B
15/260: Inner_distence = Get_distence(A,center)
15/261: Outer_distence = Get_distence(B,center)
15/262: A
15/263:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Left = [[x1y1[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Right = [[x4y4[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Outer = np.array(Up+Down+Left+Right)
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Temp.append([i,j])
        Inner = Inner + Temp
    return Inner,Outer
15/264: A,B = Get_arround_set([2.1,2.6],2)
15/265:
def Get_distence(A,center):
    return (np.sum((A-center)**2,axis=1))**0.5
15/266: Inner_distence = Get_distence(A,center)
15/267:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Left = [[x1y1[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Right = [[x4y4[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Outer = Up+Down+Left+Right
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Temp.append([i,j])
        Inner = Inner + Temp
    return Inner,Outer
15/268: A,B = Get_arround_set([2.1,2.6],2)
15/269: A
15/270: A-center
15/271: np.array(A)-center
15/272: np.array(B)-center
15/273:
def Get_distence(A,center):
    A = np.array(A)
    return (np.sum((A-center)**2,axis=1))**0.5
15/274: A,B = Get_arround_set([2.1,2.6],2)
15/275: Get_distence(A,center)
15/276: Get_distence(B,center)
15/277:
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
15/278:
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
15/279: Outer_distence
15/280: Outer_distence-2
15/281: (Outer_distence-2)/Outer_distence
15/282:
from scipy.stats import norm
dmean=0.5
norm
15/283:
from scipy.stats import norm
dmean=0.5
15/284: norm.pdf(0)
15/285:
from scipy.stats import norm
norm.pdf(0,scale=2)
15/286:
from scipy.stats import norm
norm.pdf(3,scale=2)
15/287:
from scipy.stats import norm
norm.pdf(4,scale=2)
15/288:
from scipy.stats import norm
norm.pdf(4,scale=3)
15/289:
from scipy.stats import norm
norm.pdf(4,scale=2)
15/290: import matplotlib.pyploty as plt
15/291: import matplotlib.pyplot as plt
15/292:
x = [1,2]
y = [3,4]
x = np.array(x)
y = np.array(y)
15/293: x*y
15/294:
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = norm.pdf(Out_d,scale=2)
    Weight_inner = norm.pdf(In_d,scale=2)
    print(Weight_inner)
    print(Weight_Out)
    print(Weight_Out*Out_)
15/295: make_weight(Inner_distence,Outer_distence,2)
15/296:

import matplotlib.pyplot as plt
import seaborn as sns
% matplotlib inline
 
f, (ax1,ax2) = plt.subplots(figsize = (6,4),nrows=2)
 
# cmap用matplotlib colormap
sns.heatmap(pt, linewidths = 0.05, ax = ax2, vmax=900, vmin=0, cmap='rainbow') 
# rainbow为 matplotlib 的colormap名称
ax2.set_title('matplotlib colormap')
ax2.set_xlabel('region')
15/297:

import matplotlib.pyplot as plt
import seaborn as sns
 
f, (ax1,ax2) = plt.subplots(figsize = (6,4),nrows=2)
 
# cmap用matplotlib colormap
sns.heatmap(pt, linewidths = 0.05, ax = ax2, vmax=900, vmin=0, cmap='rainbow') 
# rainbow为 matplotlib 的colormap名称
ax2.set_title('matplotlib colormap')
ax2.set_xlabel('region')
15/298:

import matplotlib.pyplot as plt
import seaborn as sns
% matplotlib inline
 
f, (ax1,ax2) = plt.subplots(figsize = (6,4),nrows=2)
 
# cmap用cubehelix map颜色
cmap = sns.cubehelix_palette(start = 1.5, rot = 3, gamma=0.8, as_cmap = True)
pt = df.corr()   # pt为数据框或者是协方差矩阵
sns.heatmap(pt, linewidths = 0.05, ax = ax1, vmax=900, vmin=0, cmap=cmap)
ax1.set_title('cubehelix map')
ax1.set_xlabel('')
ax1.set_xticklabels([]) #设置x轴图例为空值
ax1.set_ylabel('kind')
 
# cmap用matplotlib colormap
sns.heatmap(pt, linewidths = 0.05, ax = ax2, vmax=900, vmin=0, cmap='rainbow') 
# rainbow为 matplotlib 的colormap名称
ax2.set_title('matplotlib colormap')
ax2.set_xlabel('region')
15/299:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
font = FontProperties(fname='/Library/Fonts/Songti.ttc')
 
def draw():
    #定义热图的横纵坐标
    xLabel = ['A','B','C','D','E']
    yLabel = ['1','2','3','4','5']
 
    #准备数据阶段，利用random生成二维数据（5*5）
    data = []
    for i in range(5):
        temp = []
        for j in range(5):
            k = random.randint(0,100)
            temp.append(k)
        data.append(temp)
 
    #作图阶段
    fig = plt.figure()
    #定义画布为1*1个划分，并在第1个位置上进行作图
    ax = fig.add_subplot(111)
    #定义横纵坐标的刻度
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel, fontproperties=font)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    #作图并选择热图的颜色填充风格，这里选择hot
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    #增加右侧的颜色刻度条
    plt.colorbar(im)
    #增加标题
    plt.title("This is a title", fontproperties=font)
    #show
    plt.show()
 
d = draw()
15/300:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw():
    #定义热图的横纵坐标
    xLabel = ['A','B','C','D','E']
    yLabel = ['1','2','3','4','5']
 
    #准备数据阶段，利用random生成二维数据（5*5）
    data = []
    for i in range(5):
        temp = []
        for j in range(5):
            k = random.randint(0,100)
            temp.append(k)
        data.append(temp)
 
    #作图阶段
    fig = plt.figure()
    #定义画布为1*1个划分，并在第1个位置上进行作图
    ax = fig.add_subplot(111)
    #定义横纵坐标的刻度
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel, fontproperties=font)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    #作图并选择热图的颜色填充风格，这里选择hot
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    #增加右侧的颜色刻度条
    plt.colorbar(im)
    #增加标题
    plt.title("This is a title", fontproperties=font)
    #show
    plt.show()
d = draw()
15/301:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw():
    #定义热图的横纵坐标
    xLabel = ['A','B','C','D','E']
    yLabel = ['1','2','3','4','5']
 
    #准备数据阶段，利用random生成二维数据（5*5）
    data = []
    for i in range(5):
        temp = []
        for j in range(5):
            k = random.randint(0,100)
            temp.append(k)
        data.append(temp)
 
    #作图阶段
    fig = plt.figure()
    #定义画布为1*1个划分，并在第1个位置上进行作图
    ax = fig.add_subplot(111)
    #定义横纵坐标的刻度
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    #作图并选择热图的颜色填充风格，这里选择hot
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    #增加右侧的颜色刻度条
    plt.colorbar(im)
    #增加标题
    plt.title("This is a title")
    #show
    plt.show()
d = draw()
15/302: A
15/303: B
15/304: data = np.zeros((5,5))
15/305: data
15/306: len(A)
15/307: len(B)
15/308: B
15/309:
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = norm.pdf(Out_d,scale=2)
    Weight_inner = norm.pdf(In_d,scale=2)
    print(Weight_inner)
    print(Weight_Out)
    print(Weight_Out*Out_)
    return Weight_inner,Weight_Out
15/310: A_,B_ = make_weight(Inner_distence,Outer_distence,2)
15/311:
for b in range(len(B)):
    data[B[b][0]][B[b][1]]= B_[b]
15/312: data
15/313: data = np.zeros((6,6))
15/314:
for b in range(len(B)):
    data[B[b][0]][B[b][1]]= B_[b]
15/315:
for a in range(len(A)):
    data[A[a][0]][A[a][1]]= A_[a]
15/316: data
15/317:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw():
    #定义热图的横纵坐标
    xLabel = ['A','B','C','D','E',"F"]
    yLabel = ['1','2','3','4','5',"6"]
    #作图阶段
    fig = plt.figure()
    #定义画布为1*1个划分，并在第1个位置上进行作图
    ax = fig.add_subplot(111)
    #定义横纵坐标的刻度
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    #作图并选择热图的颜色填充风格，这里选择hot
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    #增加右侧的颜色刻度条
    plt.colorbar(im)
    #增加标题
    plt.title("This is a title")
    #show
    plt.show()
d = draw()
15/318:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw():
    #定义热图的横纵坐标
    xLabel = ['0','1','2','3','4',"5"]
    yLabel = ['0','1','2','3','4',"5"]
    #作图阶段
    fig = plt.figure()
    #定义画布为1*1个划分，并在第1个位置上进行作图
    ax = fig.add_subplot(111)
    #定义横纵坐标的刻度
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    #作图并选择热图的颜色填充风格，这里选择hot
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    #增加右侧的颜色刻度条
    plt.colorbar(im)
    #增加标题
    plt.title("Aperture Weight")
    #show
    plt.show()
d = draw()
15/319:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw():
    #定义热图的横纵坐标
    xLabel = ['0','1','2','3','4',"5"]
    yLabel = ['0','1','2','3','4',"5"]
    #作图阶段
    fig = plt.figure()
    #定义画布为1*1个划分，并在第1个位置上进行作图
    ax = fig.add_subplot(111)
    #定义横纵坐标的刻度
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    #作图并选择热图的颜色填充风格，这里选择hot
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    #增加右侧的颜色刻度条
    plt.colorbar(im)
    #增加标题
    plt.title("Aperture Weight(center=(2.1,2.6),d=2)")
    #show
    plt.show()
d = draw()
15/320:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw():
    #定义热图的横纵坐标
    xLabel = ['0','1','2','3','4',"5"]
    yLabel = ['0','1','2','3','4',"5"]
    #作图阶段
    fig = plt.figure()
    #定义画布为1*1个划分，并在第1个位置上进行作图
    ax = fig.add_subplot(111)
    #定义横纵坐标的刻度
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    #作图并选择热图的颜色填充风格，这里选择hot
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    #增加右侧的颜色刻度条
    plt.colorbar(im)
    #增加标题
    plt.title("Aperture Weight((s,t)=(2.1,2.6),size=2)")
    #show
    plt.show()
d = draw()
15/321:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw():
    #定义热图的横纵坐标
    xLabel = ['0','1','2','3','4',"5"]
    yLabel = ['0','1','2','3','4',"5"]
    #作图阶段
    fig = plt.figure()
    #定义画布为1*1个划分，并在第1个位置上进行作图
    ax = fig.add_subplot(111)
    #定义横纵坐标的刻度
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    #作图并选择热图的颜色填充风格，这里选择hot
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    #增加右侧的颜色刻度条
    plt.colorbar(im)
    #增加标题
    plt.title("Weight in Aperture((s,t)=(2.1,2.6),size=2)")
    #show
    plt.show()
d = draw()
15/322:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw():
    data = np.zeros((6,6))
    for b in range(len(B)):
        data[B[b][0]][B[b][1]]= B_[b]
    for a in range(len(A)):
        data[A[a][0]][A[a][1]]= A_[a]
    xLabel = ['0','1','2','3','4',"5"]
    yLabel = ['0','1','2','3','4',"5"]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    plt.colorbar(im)
    plt.title("Weight in Aperture((s,t)=(2.1,2.6),size=2)")
    #show
    plt.show()
d = draw()
15/323:
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = norm.pdf(Out_d,scale=2)
    Weight_inner = norm.pdf(In_d,scale=2)
    return Weight_inner,Weight_Out,Weight_Out*Out_
15/324: A_,B_,C= make_weight(Inner_distence,Outer_distence,2)
15/325:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw():
    data = np.zeros((6,6))
    B_ = C
    for b in range(len(B)):
        data[B[b][0]][B[b][1]]= B_[b]
    for a in range(len(A)):
        data[A[a][0]][A[a][1]]= A_[a]
    xLabel = ['0','1','2','3','4',"5"]
    yLabel = ['0','1','2','3','4',"5"]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    plt.colorbar(im)
    plt.title("Weight in Aperture((s,t)=(2.1,2.6),size=2)")
    #show
    plt.show()
d = draw()
15/326:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw():
    data = np.zeros((6,6))
    B_ = C
    for b in range(len(B)):
        data[B[b][0]][B[b][1]]= B_[b]
    for a in range(len(A)):
        data[A[a][0]][A[a][1]]= A_[a]
    xLabel = ['0','1','2','3','4',"5"]
    yLabel = ['0','1','2','3','4',"5"]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    plt.colorbar(im)
    plt.title("Weight in Aperture After Guassion((s,t)=(2.1,2.6),size=2)")
    #show
    plt.show()
d = draw()
15/327:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw():
    data = np.zeros((6,6))
    #B_ = C
    for b in range(len(B)):
        data[B[b][0]][B[b][1]]= B_[b]
    for a in range(len(A)):
        data[A[a][0]][A[a][1]]= A_[a]
    xLabel = ['0','1','2','3','4',"5"]
    yLabel = ['0','1','2','3','4',"5"]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    plt.colorbar(im)
    plt.title("Weight in Aperture After Guassion((s,t)=(2.1,2.6),size=2)")
    #show
    plt.show()
d = draw()
15/328:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw():
    data = np.zeros((6,6))
    #B_ = C
    for b in range(len(B)):
        data[B[b][0]][B[b][1]]= B_[b]
    for a in range(len(A)):
        data[A[a][0]][A[a][1]]= A_[a]
    xLabel = ['0','1','2','3','4',"5"]
    yLabel = ['0','1','2','3','4',"5"]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    plt.colorbar(im)
    plt.title("Weight in Aperture Without Guassion((s,t)=(2.1,2.6),size=2)")
    #show
    plt.show()
d = draw()
15/329: make_weight(Inner_distence,Outer_distence,2)
15/330:
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = (norm.pdf(Out_d,scale=2))*Out_
    Weight_inner = norm.pdf(In_d,scale=2)
    ALL_weight = Weight_Out+Weight_inner
    print(ALL_weight)
    return normalize(ALL_weight)
15/331: make_weight(Inner_distence,Outer_distence,2)
15/332:
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = (norm.pdf(Out_d,scale=2))*Out_
    print(Weight_Out)
    Weight_inner = norm.pdf(In_d,scale=2)
    ALL_weight = Weight_Out+Weight_inner
    return normalize(ALL_weight)
15/333: make_weight(Inner_distence,Outer_distence,2)
15/334:
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = (norm.pdf(Out_d,scale=2))*Out_
    print(Weight_Out)
    Weight_inner = norm.pdf(In_d,scale=2)
    print(Weight_inner)
    ALL_weight = Weight_Out+Weight_inner
    return normalize(ALL_weight)
15/335: make_weight(Inner_distence,Outer_distence,2)
15/336:
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = (norm.pdf(Out_d,scale=2))*Out_
    print(Weight_Out)
    Weight_inner = norm.pdf(In_d,scale=2)
    print(Weight_inner)
    ALL_weight = Weight_Out+Weight_inner
    print(ALL_weight)
    return normalize(ALL_weight)
15/337: make_weight(Inner_distence,Outer_distence,2)
15/338: Weigh_inner
15/339: Weight_inner
15/340:
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = (norm.pdf(Out_d,scale=2))*Out_
    print(Weight_Out)
    Weight_inner = norm.pdf(In_d,scale=2)
    print(Weight_inner)
    ALL_weight = np.hstack((Weight_Out，Weight_inner))
    print(ALL_weight)
    return normalize(ALL_weight)
15/341:
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = (norm.pdf(Out_d,scale=2))*Out_
    print(Weight_Out)
    Weight_inner = norm.pdf(In_d,scale=2)
    print(Weight_inner)
    ALL_weight = np.hstack((Weight_Out,Weight_inner))
    print(ALL_weight)
    return normalize(ALL_weight)
15/342: make_weight(Inner_distence,Outer_distence,2)
15/343:
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = (norm.pdf(Out_d,scale=2))*Out_
    print(Weight_Out)
    Weight_inner = norm.pdf(In_d,scale=2)
    print(Weight_inner)
    ALL_weight = np.hstack((Weight_Out,Weight_inner))
    print(ALL_weight)
    return normalizel(ALL_weight)
15/344:
def normalize(v):
    norm=np.linalg.norm(v, ord=1)
    if norm==0:
        norm=np.finfo(v.dtype).eps
    return v/norm
15/345:
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = (norm.pdf(Out_d,scale=2))*Out_
    print(Weight_Out)
    Weight_inner = norm.pdf(In_d,scale=2)
    print(Weight_inner)
    ALL_weight = np.hstack((Weight_Out,Weight_inner))
    print(ALL_weight)
    return normalize(ALL_weight)
15/346: make_weight(Inner_distence,Outer_distence,2)
15/347: make_weight(Inner_distence,Outer_distence,2)
15/348:
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = (norm.pdf(Out_d,scale=2))*Out_
    Weight_inner = norm.pdf(In_d,scale=2)
    ALL_weight = np.hstack((Weight_Out,Weight_inner))
    return normalize(ALL_weight)
15/349: make_weight(Inner_distence,Outer_distence,2)
15/350: np.sum(make_weight(Inner_distence,Outer_distence,2))
15/351:
def get_aperture_image(x,y,size):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size)
    print(A)
    return
15/352: get_aperture_image(2.2,2.3,2)
15/353: type(get_aperture_image(2.2,2.3,2))
15/354:
def get_aperture_image(x,y,size):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size)
    return A+B
15/355: type(get_aperture_image(2.2,2.3,2))
15/356: get_aperture_image(2.2,2.3,2)
15/357: len(get_aperture_image(2.2,2.3,2))
15/358:
def Blend_4(P,w):
    Image = np.zeros((76800,3),dtype=np.uint8)
    for i in range(len(P)):
        Temp = (np.floor(P[i]*w[i])).astype(np.uint8)
        Image = Image + Temp
    return matrix_2_img(Image)
15/359:
#get the photo [320*240] as a vector with the uv coord(x,y)
def get_photo(x,y):
    index = 255-x-16*y
    return Data[index]
15/360: Im = get_aperture_image(2.2,2.3,2)
15/361: show_img(Im)
15/362: Im
15/363:
def get_aperture_image(x,y,size):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size)
    ALL_set = A+B
    P = [get_photo(i[0],i[1]) for i in ALL_set]
    return Blend_4(P,Weight)
15/364: Im = get_aperture_image(2.2,2.3,2)
15/365: Im
15/366: show_img(Im)
15/367: Im = get_aperture_image(2.2,2.3,0.2)
15/368: Im = get_aperture_image(2.2,2.3,0.3)
15/369: show_img(Im)
15/370: Im = get_aperture_image(2.2,2.3,0.5)
15/371: show_img(Im)
15/372:
def get_aperture_image(x,y,size):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size)
    ALL_set = A+B
    P = [get_photo(i[0],i[1]) for i in ALL_set]
    print(Weight)
    return Blend_4(P,Weight)
15/373:
def get_aperture_image(x,y,size):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size)
    ALL_set = A+B
    P = [get_photo(i[0],i[1]) for i in ALL_set]
    print(Weight)
    return Blend_4(P,Weight)
15/374: Im = get_aperture_image(2.2,2.3,0.5)
15/375: Im = get_aperture_image(2.2,2.3,1.2)
15/376: show_img(Im)
15/377: Im = get_aperture_image(3,3,1.2)
15/378: show_img(Im)
15/379: Im = get_aperture_image(3,3,4)
15/380: Im = get_aperture_image(3,3,3)
15/381: show_img(Im)
15/382:
def get_aperture_image(x,y,size):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size)
    ALL_set = A+B
    P = [get_photo(i[0],i[1]) for i in ALL_set]
    for i in P:
        show_img(i)
    return Blend_4(P,Weight)
15/383: Im = get_aperture_image(3,3,3)
15/384: show_img(Im)
15/385:
def get_aperture_image(x,y,size):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size)
    ALL_set = A+B
    P = [get_photo(i[0],i[1]) for i in ALL_set]
    for i in P:
        show_img(i)
    return Blend_4(P,Weight)
15/386:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''
def display():
    print (Y.get())
    
root.mainloop()
15/387:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''
def display():
    print (1)
    
root.mainloop()
15/388:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''
def display:
    print (1)
    
root.mainloop()
15/389:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''
def display:
    print (1)
    
root.mainloop()
15/390:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''
Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show():
    print(s1.get(),s2.get())
 
    
root.mainloop()
15/391:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = display).pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''
Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show():
    print(Y.get())
 
    
root.mainloop()
15/392:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y").pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''
Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show():
    print(Y.get())
 
    
root.mainloop()
15/393:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y").pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''
Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show():
    print(Y.get())
 
    
root.mainloop()
15/394:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y").pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''
Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show():
    print(Y.get())
 
    
root.mainloop()
15/395:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y").pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''
Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show():
    print(Y.get())
 
mainloop()
15/396:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y_axis").pack(side = LEFT)
'''
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X",command = display).pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z",command = display).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x",command = display).pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y",command = display).pack(side = RIGHT)
'''
Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show():
    print(Y.get())
 
mainloop()
15/397:
from tkinter import *
  
root = Tk()
root.title("Jason niu工作室")
theLabel=tk.Label(root,text="进入GUI世界，请开始你的表演！\nScale组件控制滚动范围")  
theLabel.pack() 
 
s1=Scale(root,from_=0,to=100) 
s1.pack()
s2=Scale(root,from_=0,to=2018,orient=HORIZONTAL) 
s2.pack()
 
def show():
    print(s1.get(),s2.get())
 
Button(root,text="获取位置",command=show).pack()
 
 
mainloop()
15/398:
from tkinter import *
  
root = Tk()
root.title("Jason niu工作室")
theLabel=tk.Label(root,text="进入GUI世界，请开始你的表演！\nScale组件控制滚动范围")  
theLabel.pack() 
 
s1=Scale(root,from_=0,to=100) 
s1.pack()
s2=Scale(root,from_=0,to=2018,orient=HORIZONTAL) 
s2.pack()
 
def show():
    print(s1.get(),s2.get())
 
Button(root,text="获取位置",command=show).pack()
mainloop()
15/399:
from tkinter import *
  
root = Tk()
root.title("Jason niu工作室")
theLabel=tk.Label(root,text="进入GUI世界，请开始你的表演！\nScale组件控制滚动范围")  
theLabel.pack() 
 
s1=Scale(root,from_=0,to=100) 
s1.pack()
s2=Scale(root,from_=0,to=2018,orient=HORIZONTAL) 
s2.pack()
 
def show():
    print(s1.get(),s2.get())
 
Button(root,text="获取位置",command=show).pack()
mainloop()
15/400:
from tkinter import *
  
root = Tk()
root.title("Basic Light Field")

Y = Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y_axis").pack(side = LEFT)
 
s1=Scale(root,from_=0,to=100) 
s1.pack()
s2=Scale(root,from_=0,to=2018,orient=HORIZONTAL) 
s2.pack()
 
def show():
    print(s1.get(),s2.get())
 
Button(root,text="Postion",command=show).pack()
mainloop()
15/401:
from tkinter import *
  
root = Tk()
root.title("Basic Light Field")

Y = Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y_axis").pack(side = LEFT)
 
s1=Scale(root,from_=0,to=100) 
s1.pack()
s2=Scale(root,from_=0,to=2018,orient=HORIZONTAL) 
s2.pack()
 
def show():
    print(s1.get(),s2.get())
 
Button(root,text="Postion",command=show).pack()
mainloop()
15/402:
from tkinter import *
  
root = Tk()
root.title("Basic Light Field")

Y = Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y_axis").pack(side = LEFT)
 
s1=Scale(root,from_=0,to=100,command=show) 
s1.pack()
s2=Scale(root,from_=0,to=2018,orient=HORIZONTAL) 
s2.pack()
 
def show():
    print(s1.get(),s2.get())
 
mainloop()
15/403:
from tkinter import *
  
root = Tk()
root.title("Basic Light Field")

Y = Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y_axis").pack(side = LEFT)
 
s1=Scale(root,from_=0,to=100) 
s1.pack()
s2=Scale(root,from_=0,to=2018,orient=HORIZONTAL) 
s2.pack()
 
def show():
    print(s1.get(),s2.get())
 
Button(root,text="Postion",command=show).pack()
mainloop()
15/404:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y").pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z"]).pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show():
    print(Y.get())
 
mainloop()
15/405:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=0, to=16 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y").pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show():
    print(Y.get())
 
mainloop()
15/406:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=16, to=0 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y").pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show():
    print(Y.get())
 
mainloop()
15/407:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=16, to=0 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y").pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show():
    print(root.Y.get())
 
mainloop()
15/408:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=16, to=0 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y").pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show():
    print(s = Y.get())
 
mainloop()
15/409:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=16, to=0 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = show(Y.get())).pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show(i):
    print(i)
 
mainloop()
15/410:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=16, to=0 ,length=480, \
      resolution=0.1, orient="vertical",label = "Y",command = show(Y.get()))
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show(i):
    print(i)

mainloop()
15/411:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1, orient="vertical",label="Y",command = show(Y.get()))
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show(i):
    print(i)

mainloop()
15/412:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show(get()))
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show(i):
    print(i)

mainloop()
15/413:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show():
    print(1)

mainloop()
15/414:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show():
    print(1)

mainloop()
15/415:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show():
    print(1)

mainloop()
15/416:
from Tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)

button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)

label = Label(root)
label.pack()

root.mainloop()
15/417:
from tkinter import *

def sel():
   selection = "Value = " + str(var.get())
   label.config(text = selection)

root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)

button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)

label = Label(root)
label.pack()

root.mainloop()
15/418:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",variable = Y_,command = show)
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show():
    print(Y_)

mainloop()
15/419:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}
var = DoubleVar()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",variable = var,command = show)
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show():
    print(Y_)

mainloop()
15/420:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}
var = DoubleVar()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",variable = var,command = show)
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show():
    print(var.get())

mainloop()
15/421:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}
var = DoubleVar()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",variable = var,command = show)
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show():
    print(var.get())

root.mainloop()
15/422:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}
var = DoubleVar()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",variable = var,command = show)
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show(self):
    print(var.get())

root.mainloop()
15/423:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}
var = DoubleVar()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",variable = var,command = show)
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show(Y.self):
    print(var.get())

root.mainloop()
15/424:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}
var = DoubleVar()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",variable = var,command = show)
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show(Y.self):
    print(var.get())

root.mainloop()
15/425:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}
var = DoubleVar()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",variable = var,command = show)
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show(root.self):
    print(var.get())

root.mainloop()
15/426:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}
var = DoubleVar()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",variable = var,command = show)
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show(self):
    print(var.get())

root.mainloop()
15/427:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}
var = DoubleVar()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show(self):
    print(Y.get())

root.mainloop()
15/428:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}
var = DoubleVar()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show(self):
    print(Y.get())

root.mainloop()
15/429:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}
var = DoubleVar()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show(self):
    print(Y.get())

root.mainloop()
15/430:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}
var = DoubleVar()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
Get = Button(root,text="Get Photo",command=show).pack(side = BOTTOM)
def show(self):
    print(Y.get())

root.mainloop()
15/431:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}
var = DoubleVar()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(Y.get())

root.mainloop()
15/432:
import tkinter as tk
from scipy.stats import norm
 
root = tk.Tk()
para = {}
var = DoubleVar()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(Y.get())

root.mainloop()
15/433:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))
15/434:
def img_2_matrix(img):
    return img.reshape(320*240,3)
def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
15/435: print(matrix_2_img)
15/436: print(matrix_2_img.read())
15/437:
source_code = inspect. getsource(matrix_2_img)
print(source_code)
15/438:
import inspect
source_code = inspect. getsource(matrix_2_img)
print(source_code)
15/439:
import inspect
source_code = inspect. getsource(img_2_matrix)
print(source_code)
15/440:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
15/441:
root = tk.Tk()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(Y.get())

root.mainloop()
15/442:
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
15/443:
root = tk.Tk()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)
img =  ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0]))))
canvas.pack()
canvas.create_image(20,20, anchor="nw", image=img)
canvas = tk.Canvas(root,width=300,height=300)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(Y.get())

root.mainloop()
15/444:
root = tk.Tk()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)
img =  ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0]))))
canvas.create_image(20,20, anchor="nw", image=img)
canvas = tk.Canvas(root,width=300,height=300)
canvas.pack()
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(Y.get())

root.mainloop()
15/445:
root = tk.Tk()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

img =  ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0]))))

canvas = tk.Canvas(root,width=300,height=300)
canvas.create_image(20,20, anchor="nw", image=img)

canvas.pack()
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(Y.get())

root.mainloop()
15/446: image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
15/447: image
15/448: img =  ImageTk.PhotoImage(image)
15/449: canvas = tk.Canvas(root,width=300,height=300)
15/450: canvas.create_image(image=img).pack()
15/451: canvas.create_image(20,20, anchor="nw", image=img)
15/452:
image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(image)
img_panel = Label(root_panel)
img_panel.configure(image=img)
img_panel.pack(side="bottom", fill="both", expand="yes")
15/453:
image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(image)
root_panel = Frame(root)
root_panel.pack(side="bottom", fill="both", expand="yes")
img_panel = Label(root_panel)
img_panel.configure(image=img)
img_panel.pack(side="bottom", fill="both", expand="yes")
15/454:
root = tk.Tk()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

canvas = tkinter.Canvas(root, width = 320, height = 240)
canvas.pack()

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(Y.get())

root.mainloop()
15/455:
root = tk.Tk()

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

canvas = tk.Canvas(root, width = 320, height = 240)
canvas.pack()

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(Y.get())

root.mainloop()
15/456:
root = tk.Tk()
image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(image)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

canvas = tk.Canvas(root, width = 320, height = 240)
canvas.pack()
canvas.create_image(0, 0, image=img, anchor=tkinter.NW)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/457:
root = tk.Tk()

image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(image)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

canvas = tk.Canvas(root, width = 320, height = 240)
canvas.pack()
canvas.create_image(0, 0, image=img, anchor=tkinter.NW)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/458:
root = tk.Tk()

image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(image)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

canvas = tk.Canvas(root, width = 320, height = 240)
canvas.pack()
canvas.create_image(0, 0, image=img, anchor=tk.NW)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/459:
root = tk.Tk()

image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(image)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

Canvas = tk.Canvas(root, width = 320, height = 240)
canvas.pack(side = TOP)
canvas.create_image(0, 0, image=img, anchor=tk.NW)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/460:
root = tk.Tk()

image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(image)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

Canvas = tk.Canvas(root)
canvas.pack(side = TOP)
canvas.create_image(0, 0, image=img, anchor=tk.NW)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/461:
root = tk.Tk()

image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(image)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

canvas = tk.Canvas(root, width = 320, height = 240)
canvas.pack(side = TOP)
canvas.create_image(0, 0, image=img, anchor=tk.NW)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/462:
root = tk.Tk()

image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(image)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

canvas = tk.Canvas(root, width = 320, height = 240)
canvas.pack(side = TOP)
canvas.create_image(0, 0, image=img)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/463:
root = tk.Tk()

image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(image)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

w = tk.Label(root, text="Hello Tkinter!")

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/464:
root = tk.Tk()

image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(image)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

w = tk.Label(root, text="Hello Tkinter!")

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/465:
root = tk.Tk()

image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(image)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

w = tk.Label(root, text="Hello Tkinter!")
w.pack()

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/466:
root = tk.Tk()

image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(image)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

w = tk.Label(root, text="Hello Tkinter!")
logo = tk.PhotoImage(image=img)
w.pack()

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/467:
root = tk.Tk()

image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(img)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

w = tk.Label(root, text="Hello Tkinter!")
logo = tk.PhotoImage(image=img)
w.pack()

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/468:
root = tk.Tk()

image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(image)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

w = tk.Label(root, text="Hello Tkinter!")
logo = tk.PhotoImage(image=img)
w.pack()

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/469:
root = tk.Tk()

image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(image)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

w = tk.Label(root, text="Hello Tkinter!")
logo = tk.PhotoImage(img =  ImageTk.PhotoImage(image))
w.pack()

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/470:
root = tk.Tk()

image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(image)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

w = tk.Label(root, text="Hello Tkinter!")
logo = tk.PhotoImage(image)
w.pack()

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/471:
root = tk.Tk()

image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(image)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)
logo = tk.PhotoImage(image)
w = tk.Label(root, 
             compound = tk.CENTER,
             text=explanation, 
             image=logo).pack(side="right")
w.pack()

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/472:
root = tk.Tk()

image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(image)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)
logo = tk.PhotoImage(image)
w = tk.Label(root, 
             compound = tk.CENTER, 
             image=logo).pack(side="right")
w.pack()

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/473:
root = tk.Tk()

image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0])))
img =  ImageTk.PhotoImage(image)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)
logo = tk.PhotoImage(image)

w = tk.Label(root, 
             compound = tk.CENTER, 
             image=logo).pack(side="right")
w.pack()

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/474: logo
15/475:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0]))))

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)
logo = tk.PhotoImage(image)

w = tk.Label(root, 
             compound = tk.CENTER, 
             image=imgtk).pack(side="right")
w.pack()

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/476:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(matrix_2_img(Data[0]))))

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

w = tk.Label(root, 
             compound = tk.CENTER, 
             image=imgtk).pack(side="right")
w.pack()

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/477: imgtk
15/478:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

w = tk.Label(root, 
             compound = tk.CENTER, 
             image=imgtk).pack(side="right")
w.pack()

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/479:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

w = tk.Label(root,image=imgtk).pack(side="right")
w.pack()

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/480:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)

w = tk.Label(root,image=imgtk).pack(side="right")
w.pack()

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/481:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,image=imgtk).pack(side="right")
w.pack()


root.mainloop()
15/482:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,image=imgtk).pack()
w.pack()
Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/483:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,image=imgtk)
w.pack()
Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/484: matrix_2_img(Data[0])
15/485:
root = tk.Tk()

imgtk = Imagetk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,image=imgtk)
w.pack()
Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/486:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,image=imgtk)
w.pack()
Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/487: imgtk.show()
15/488:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,image=imgtk)
w.pack(side = TOP)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/489:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,text = "123")
w.pack(side = TOP)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/490:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,text = "123",fg="red")
w.pack(side = TOP)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/491:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,text = "123",fg="red",,width=50,height=50)
w.pack(side = TOP)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/492:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,text = "123",fg="red",width=50,height=50)
w.pack(side = TOP)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/493:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,image = imgtk,width=50,height=50)
w.pack(side = TOP)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/494:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,image = imgtk,width=50,height=50)
w.pack(side = TOP)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/495:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,image = imgtk,width=320,height=240)
w.pack(side = TOP)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/496:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,image = imgtk,width=320,height=240,ipady = 100)
w.pack(side = TOP)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/497:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,image = imgtk,width=320,height=240)
w.pack(side = TOP,,ipady = 100)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/498:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,image = imgtk,width=320,height=240)
w.pack(side = TOP,ipady = 100)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/499:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,image = imgtk,width=320,height=240)
w.pack(side = TOP,ipady = 10)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/500:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,image = imgtk,width=320,height=240)
w.pack(side = TOP)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/501:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,image = imgtk,width=320,height=240)
w.pack(side = TOP)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/502:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,image = imgtk,width=320,height=240)
w.pack(side = TOP)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
15/503:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,image = imgtk,width=320,height=240)
w.pack(side = TOP)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
16/1:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
16/2:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,image = imgtk,width=320,height=240)
w.pack(side = TOP)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
16/3:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
16/4:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

w = tk.Label(root,image = imgtk,width=320,height=240)
w.pack(side = TOP)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
16/5:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

W = tk.Label(root,image = imgtk,width=320,height=240)
W.pack(side=TOP)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
16/6:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

W = tk.Label(root,image = imgtk,width=10,height=10)
W.pack(side=TOP)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
16/7:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

W = tk.Label(root,image = imgtk,width=320,height=240)
W.pack(side=TOP)

def Get_image(self):
    print(1)

root.mainloop()
16/8:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

W = tk.Label(root,image = imgtk,width=320,height=240)
W.pack()

root.mainloop()
16/9:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

W = tk.Label(root,image = imgtk)
W.pack()

root.mainloop()
16/10:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

W = tk.Label(root,image = imgtk)
W.pack()
Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
16/11:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = show)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
16/12:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
16/13:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)
def Get_image(self):
    print(1)

root.mainloop()
16/14:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)

def Get_image(self):
    print(1)

root.mainloop()
17/1:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
17/2:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)

def Get_image(self):
    print(1)

root.mainloop()
17/3:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.pack(side = LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)

root.mainloop()
17/4:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.pack(side = tk.LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = RIGHT)

root.mainloop()
17/5:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.pack(side = tk.LEFT)


X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = tk.BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = tk.BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = tk.RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = tk.RIGHT)

root.mainloop()
17/6:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.pack(side = tk.LEFT)
W = tk.Label(root,image = imgtk)
W.pack(side = tk.LEFT)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = tk.BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = tk.BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = tk.RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = tk.RIGHT)

root.mainloop()
17/7:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.pack(side = tk.LEFT)
W = tk.Label(root,image = imgtk)
W.pack(side = tk.TOP)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = tk.BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = tk.BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = tk.RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = tk.RIGHT)

root.mainloop()
17/8:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.pack(side = tk.LEFT)
W = tk.Label(root,image = imgtk)
W.pack(side = tk.TOP,ipady = 10)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = tk.BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = tk.BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = tk.RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = tk.RIGHT)

root.mainloop()
17/9:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.pack(side = tk.LEFT)
W = tk.Label(root,image = imgtk)
W.pack(side = tk.TOP,ipady = 100)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = tk.BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = tk.BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = tk.RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = tk.RIGHT)

root.mainloop()
17/10:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.pack(side = tk.LEFT)
W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.pack(side = tk.TOP,ipady = 100)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = tk.BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = tk.BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = tk.RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = tk.RIGHT)

root.mainloop()
17/11:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.pack(side = tk.LEFT)
W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.pack(side = tk.TOP)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").pack(side = tk.BOTTOM)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").pack(side = tk.BOTTOM)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").pack(side = tk.RIGHT)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").pack(side = tk.RIGHT)

root.mainloop()
17/12:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

root.mainloop()
17/13:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)
W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 1, row = 1)


root.mainloop()
17/14:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)
W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)


root.mainloop()
17/15:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)
W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)
X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 1, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 1, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)


root.mainloop()
17/16:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 1, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 1, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)


root.mainloop()
17/17:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 1, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 1, row = 3)


root.mainloop()
17/18:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)



root.mainloop()
17/19:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 1, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 1, row = 3)


root.mainloop()
17/20:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 3, row = 1)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 1, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 1, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)


root.mainloop()
17/21:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 1, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 1, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)


root.mainloop()
17/22:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 2)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 1, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 1, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)


root.mainloop()
17/23:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 1, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 1, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)


root.mainloop()
17/24:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=480,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=640, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 1, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=640, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 1, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)


root.mainloop()
17/25:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 1, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 1, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)


root.mainloop()
17/26:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 1, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 1, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 2)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 2)


root.mainloop()
17/27:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)


root.mainloop()
17/28:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

tk.title("aa")

Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)


root.mainloop()
17/29:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

root.title("aa")

Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)


root.mainloop()
17/30:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

root.title('My Title')
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)


root.mainloop()
17/31:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)


root.mainloop()
17/32:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)


root.mainloop()
18/1:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
18/2:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)

Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)


root.mainloop()
18/3:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)
tk.title("a")
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)


root.mainloop()
18/4:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)
root.title("a")
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)


root.mainloop()
19/1:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
19/2:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(1)
root.title("a")
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)


root.mainloop()
19/3:
root = tk.Tk()

imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))

def Get_image(self):
    print(Y.get())
root.title("Assignment1")
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)


root.mainloop()
19/4:
root = tk.Tk()

def Get_image(self):
    
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
    print(Y.get())

    
root.title("Assignment1")
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
root.mainloop()
20/1:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
20/2:
root = tk.Tk()

def Get_image(self):
    
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
    print(Y.get())

    
root.title("Assignment1")
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
root.mainloop()
20/3:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
20/4:
root = tk.Tk()

def Get_image(self):
    
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
    print(Y.get())

root.title("Assignment1")
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
root.mainloop()
20/5:
root = tk.Tk()

def Get_image(self):
    print(Y.get())

root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
root.mainloop()
21/1:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
21/2:
root = tk.Tk()

def Get_image(self):
    print(Y.get())

root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
root.mainloop()
21/3:
def show_img(img):
    im=Image.fromarray(img) 
    im.show()
21/4:
#get the photo [320*240] as a vector with the uv coord(x,y)
def get_photo(x,y):
    index = 255-x-16*y
    return Data[index]
21/5:
def Blend_4(P,w):
    Image = np.zeros((76800,3),dtype=np.uint8)
    for i in range(len(P)):
        Temp = (np.floor(P[i]*w[i])).astype(np.uint8)
        Image = Image + Temp
    return matrix_2_img(Image)
21/6:
#Input:photos like as(wh,3)*n,and the weight
#Output:photos*weight
def Blend_4(P,w):
    Image = np.zeros((76800,3),dtype=np.uint8)
    for i in range(len(P)):
        Temp = (np.floor(P[i]*w[i])).astype(np.uint8)
        Image = Image + Temp
    return matrix_2_img(Image)
21/7:
def normalize(v):
    norm=np.linalg.norm(v, ord=1)
    if norm==0:
        norm=np.finfo(v.dtype).eps
    return v/norm
def show_img(img):
    im=Image.fromarray(img) 
    im.show()
#get the photo [320*240] as a vector with the uv coord(x,y)
def get_photo(x,y):
    index = 255-x-16*y
    return Data[index]
#Input:photos like as(wh,3)*n,and the weight
#Output:photos*weight
def Blend_by_weight(P,w):
    Image = np.zeros((76800,3),dtype=np.uint8)
    for i in range(len(P)):
        Temp = (np.floor(P[i]*w[i])).astype(np.uint8)
        Image = Image + Temp
    return matrix_2_img(Image)
21/8:
#x(0,15),y(0,15)
def Q_interpolator(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo(x_,y_)
    p2 = get_photo(x_+1,y_)
    p3 = get_photo(x_,y_-1)
    p4 = get_photo(x_+1,y_-1)
    return Blend_by_weight([p1,p2,p3,p4],normalize(w))
21/9:
I = Q_interpolator([0.3,0.8])
show_img(I)
21/10:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w),dtype=np.uint8)
    for i in range(w):
        for j in range(h):
            Coord = np.array([i,j])+disparity
            if Coord[0]>w-1:
                Coord[0] = w
            if Coord[1]>h-1:
                Coord[1] = h
            White_image[i][j] = np.floor(Coord)
    return White_image
21/11:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for i in range(w):
        for j in range(h):
            u,v = Bias_map[i][j]
            White_image[i][j] = Image[u][v]
    return White_image
21/12: disparity_matrix(1.1,1.2,240,320)
21/13: disparity_matrix([1.1,1.2],240,320)
21/14:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w))
    for i in range(w):
        for j in range(h):
            Coord = np.array([i,j])+disparity
            if Coord[0]>w-1:
                Coord[0] = w
            if Coord[1]>h-1:
                Coord[1] = h
            White_image[i][j] = np.floor(Coord)
    return White_image
21/15: disparity_matrix([1.1,1.2],240,320)
21/16:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w),dtype=np.uint8)
    for i in range(w):
        for j in range(h):
            Coord = np.array([i,j])+disparity
            if Coord[0]>w-1:
                Coord[0] = w
            if Coord[1]>h-1:
                Coord[1] = h
            White_image[i][j] = list(np.floor(Coord)
    return White_image
21/17:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w),dtype=np.uint8)
    for i in range(w):
        for j in range(h):
            Coord = np.array([i,j])+disparity
            if Coord[0]>w-1:
                Coord[0] = w
            if Coord[1]>h-1:
                Coord[1] = h
            White_image[i][j] = list(np.floor(Coord))
    return White_image
21/18: disparity_matrix([1.1,1.2],240,320)
21/19:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w),dtype=np.uint8)
    for i in range(w):
        for j in range(h):
            Coord = np.array([i,j])+disparity
            if Coord[0]>w-1:
                Coord[0] = w
            if Coord[1]>h-1:
                Coord[1] = h
            print(np.floor(Coord))
            White_image[i][j] = list(np.floor(Coord))
    return White_image
21/20: disparity_matrix([1.1,1.2],240,320)
21/21:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint8)
    for i in range(w):
        for j in range(h):
            Coord = np.array([i,j])+disparity
            if Coord[0]>w-1:
                Coord[0] = w
            if Coord[1]>h-1:
                Coord[1] = h
            print(np.floor(Coord))
            White_image[i][j] = np.floor(Coord)
    return White_image
21/22: disparity_matrix([1.1,1.2],240,320)
21/23:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint8)
    for i in range(w):
        for j in range(h):
            Coord = np.array([i,j])+disparity
            if Coord[0]>w-1:
                Coord[0] = w
            if Coord[1]>h-1:
                Coord[1] = h
            White_image[i][j] = np.floor(Coord)
    return White_image
21/24: disparity_matrix([1.1,1.2],240,320)
21/25:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint8)
    for i in range(w):
        prirnt(i)
        for j in range(h):
            Coord = np.array([i,j])+disparity
            if Coord[0]>w-1:
                Coord[0] = w
            if Coord[1]>h-1:
                Coord[1] = h
            White_image[i][j] = np.floor(Coord)
    return White_image
21/26: disparity_matrix([1.1,1.2],240,320)
21/27:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint8)
    for i in range(w):
        print(i)
        for j in range(h):
            Coord = np.array([i,j])+disparity
            if Coord[0]>w-1:
                Coord[0] = w
            if Coord[1]>h-1:
                Coord[1] = h
            White_image[i][j] = np.floor(Coord)
    return White_image
21/28: disparity_matrix([1.1,1.2],240,320)
21/29:
disparity = [1.1,1.2]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for i in range(w):
    for j in range(h):
        Coord = np.array([i,j])+disparity
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
21/30:
disparity = [1.1,1.2]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for i in range(w):
    for j in range(h):
        try:
            Coord = np.array([i,j])+disparity
            if Coord[0]>w-1:
                Coord[0] = w
            if Coord[1]>h-1:
                Coord[1] = h
            White_image[i][j] = np.floor(Coord)
        except:
            print(i,j)
            exit(0)
22/1:
disparity = [1.1,1.2]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
print(White_image.shape)

for i in range(w):
    for j in range(h):
        try:
            Coord = np.array([i,j])+disparity
            if Coord[0]>w-1:
                Coord[0] = w
            if Coord[1]>h-1:
                Coord[1] = h
            White_image[i][j] = np.floor(Coord)
        except:
            print(i,j)
            exit(0)
22/2:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
22/3:
disparity = [1.1,1.2]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
print(White_image.shape)

for i in range(w):
    for j in range(h):
        try:
            Coord = np.array([i,j])+disparity
            if Coord[0]>w-1:
                Coord[0] = w
            if Coord[1]>h-1:
                Coord[1] = h
            White_image[i][j] = np.floor(Coord)
        except:
            print(i,j)
            exit(0)
23/1:
disparity = [1.1,1.2]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
print(White_image.shape)

for i in range(w):
    for j in range(h):
        print(i,j)
        Coord = np.array([i,j])+disparity
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
23/2:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
23/3:
disparity = [1.1,1.2]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
print(White_image.shape)

for i in range(w):
    for j in range(h):
        print(i,j)
        Coord = np.array([i,j])+disparity
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
23/4:
disparity = [1.1,1.2]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
print(White_image.shape)
for i in range(h):
    for j in range(w):
        print(i,j)
        Coord = np.array([i,j])+disparity
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
23/5:
disparity = [1.1,1.2]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
print(White_image.shape)
for i in range(h):
    for j in range(w):
        Coord = np.array([i,j])+disparity
        if Coord[0]>w-1:
            Coord[0] = w
        if Coord[1]>h-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
23/6: White_image[0][0]
23/7: White_image[1][2]
23/8: White_image[319][0]
23/9: White_image[239][319]
23/10:
disparity = [1.1,1.2]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
print(White_image.shape)
for i in range(h):
    for j in range(w):
        Coord = np.array([i,j])+disparity
        if Coord[0]>h-1:
            Coord[0] = w
        if Coord[1]>w-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
23/11: White_image[239][319]
23/12: White_image[238][319]
23/13:
disparity = [1.1,1.2]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
print(White_image.shape)
for i in range(h):
    for j in range(w):
        Coord = np.array([i,j])+disparity
        if Coord[0]>h-1:
            Coord[0] = w
        if Coord[1]>w-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
23/14: White_image[238][319]
23/15:
disparity = [1.1,1.2]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for i in range(h):
    for j in range(w):
        Coord = np.array([i,j])+disparity
        if Coord[0]>h-1:
            Coord[0] = w
        if Coord[1]>w-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
23/16: White_image[238][319]
23/17: White_image[238][319]
23/18:
disparity = [1.1,1.2]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for i in range(h):
    for j in range(w):
        Coord = np.array([i,j])+disparity
        if i == 238:
            print(Coord)
        if Coord[0]>h-1:
            Coord[0] = w
        if Coord[1]>w-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
23/19: White_image[238][312]
23/20: White_image[238][313]
23/21:
disparity = [1.1,1.2]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for i in range(h):
    for j in range(w):
        Coord = np.array([i,j])+disparity
        if Coord[0]>h-1:
            Coord[0] = w
        if Coord[1]>w-1:
            Coord[1] = h
        White_image[i][j] = np.floor(Coord)
        if i == 238:
            print(np.floor(Coord))
23/22:
disparity = [1.1,1.2]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for i in range(h):
    for j in range(w):
        Coord = np.array([i,j])+disparity
        if Coord[0]>h-1:
            Coord[0] = h
        if Coord[1]>w-1:
            Coord[1] = w
        White_image[i][j] = np.floor(Coord)
        if i == 238:
            print(np.floor(Coord))
23/23:
disparity = [1.1,1.2]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for i in range(h):
    for j in range(w):
        Coord = np.array([i,j])+disparity
        if Coord[0]>h-1:
            Coord[0] = h
        if Coord[1]>w-1:
            Coord[1] = w
        White_image[i][j] = np.floor(Coord)
23/24: White_image[238][313]
23/25:
disparity = [1.1,1.2]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for i in range(h):
    for j in range(w):
        Coord = np.array([j,i])+disparity
        if Coord[1]>h-1:
            Coord[1] = h
        if Coord[0]>w-1:
            Coord[0] = w
        White_image[i][j] = np.floor(Coord)
23/26: White_image[238][313]
23/27:
disparity = [1.1,1.2]
w = 32
h = 24
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for i in range(h):
    for j in range(w):
        print(j,i)
        Coord = np.array([j,i])+disparity
        if Coord[1]>h-1:
            Coord[1] = h
        if Coord[0]>w-1:
            Coord[0] = w
        White_image[i][j] = np.floor(Coord)
23/28:
disparity = [1.1,1.2]
w = 32
h = 24
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for i in range(h):
    for j in range(w):
        print(j,i)
        Coord = np.array([j,i])+disparity
        if Coord[1]>h-1:
            Coord[1] = h
        if Coord[0]>w-1:
            Coord[0] = w
        White_image[j][i] = np.floor(Coord)
23/29:
disparity = [1.1,1.2]
w = 32
h = 24
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for i in range(h):
    for j in range(w):
        Coord = np.array([j,i])+disparity
        if Coord[1]>h-1:
            Coord[1] = h
        if Coord[0]>w-1:
            Coord[0] = w
        White_image[j][i] = np.floor(Coord)
23/30:
disparity = [1.1,1.2]
w = 32
h = 24
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+disparity
        if Coord[1]>h-1:
            Coord[1] = h
        if Coord[0]>w-1:
            Coord[0] = w
        White_image[x][y] = np.floor(Coord)
23/31:
disparity = [1.1,1.2]
w = 32
h = 24
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+disparity
        if Coord[1]>h-1:
            Coord[1] = h
        if Coord[0]>w-1:
            Coord[0] = w
        White_image[y][x] = np.floor(Coord)
23/32: White_image
23/33: White_image[23][31]
23/34: White_image[23][31].all
23/35: White_image[23][31]
23/36: White_image.all
23/37: White_image
23/38: White_image[0]
23/39:
disparity = [2.1,1.2]
w = 32
h = 24
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+disparity
        if Coord[1]>h-1:
            Coord[1] = h
        if Coord[0]>w-1:
            Coord[0] = w
        White_image[y][x] = np.floor(Coord)
23/40: White_image[5][6]
23/41:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint8)
    for x in range(w):
        for y in range(h):
            Coord = np.array([x,y])+disparity
            if Coord[1]>h-1:
                Coord[1] = h
            if Coord[0]>w-1:
                Coord[0] = w
            White_image[y][x] = np.floor(Coord)
    return White_image
23/42:
disparity = [2.1,1.2]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+disparity
        if Coord[1]>h-1:
            Coord[1] = h
        if Coord[0]>w-1:
            Coord[0] = w
        White_image[y][x] = np.floor(Coord)
23/43: White_image.shape
23/44: Data[0].shape
23/45: matrix_2_img(Data[0]).shape
23/46:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for x in range(w):
        for y in range(h):
            u,v = Bias_map[y][x]
            White_image[y][x] = Image[v][u]
    return White_image
23/47:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for x in range(w):
        for y in range(h):
            u,v = Bias_map[y][x]
            White_image[y][x] = Image[v][u]
    return White_image
23/48:
disparity = [0,0]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+disparity
        if Coord[1]>h-1:
            Coord[1] = h
        if Coord[0]>w-1:
            Coord[0] = w
        White_image[y][x] = np.floor(Coord)
23/49: re_image(Data[0],White_image,320,240)
23/50: a = re_image(Data[0],White_image,320,240)
23/51:
def normalize(v):
    norm=np.linalg.norm(v, ord=1)
    if norm==0:
        norm=np.finfo(v.dtype).eps
    return v/norm
def show_img(img):
    im=Image.fromarray(img) 
    im.show()
#get the photo [320*240] as a vector with the uv coord(x,y)
def get_photo(x,y):
    index = 255-x-16*y
    return Data[index]
#Input:photos like as(wh,3)*n,and the weight
#Output:photos*weight
def Blend_by_weight(P,w):
    Image = np.zeros((76800,3),dtype=np.uint8)
    for i in range(len(P)):
        Temp = (np.floor(P[i]*w[i])).astype(np.uint8)
        Image = Image + Temp
    return matrix_2_img(Image)
23/52: show_img(a)
23/53:
disparity = [1,0]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+disparity
        if Coord[1]>h-1:
            Coord[1] = h
        if Coord[0]>w-1:
            Coord[0] = w
        White_image[y][x] = np.floor(Coord)
23/54: a = re_image(Data[0],White_image,320,240)
23/55: show_img(a)
23/56:
disparity = [3,3]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+disparity
        if Coord[1]>h-1:
            Coord[1] = h
        if Coord[0]>w-1:
            Coord[0] = w
        White_image[y][x] = np.floor(Coord)
23/57: a = re_image(Data[0],White_image,320,240)
23/58:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for x in range(w):
        for y in range(h):
            try:
                u,v = Bias_map[y][x]
                White_image[y][x] = Image[v][u]
            except:
                print(u,v)
                print(x,y)
                return 0
    return White_image
23/59: a = re_image(Data[0],White_image,320,240)
23/60:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for x in range(w):
        for y in range(h):
            try:
                u,v = Bias_map[y][x]
                White_image[y][x] = Image[v-1][u-1]
            except:
                print(u,v)
                print(x,y)
                return 0
    return White_image
23/61:
disparity = [3,3]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+disparity
        if Coord[1]>h-1:
            Coord[1] = h
        if Coord[0]>w-1:
            Coord[0] = w
        White_image[y][x] = np.floor(Coord)
23/62: a = re_image(Data[0],White_image,320,240)
23/63: show_img(a)
23/64: show_img(I)
23/65:
#x(0,15),y(0,15)
def Q_interpolator(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo(x_,y_)
    p2 = get_photo(x_+1,y_)
    p3 = get_photo(x_,y_-1)
    p4 = get_photo(x_+1,y_-1)
    return Blend_by_weight([p1,p2,p3,p4],normalize(w))
23/66:
I = Q_interpolator([0.3,0.8])
show_img(I)
23/67: show_img(I)
23/68: a = re_image(Data[0],White_image,320,240)
23/69: show_img(a)
23/70:
disparity = [0,3]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+disparity
        if Coord[1]>h-1:
            Coord[1] = h
        if Coord[0]>w-1:
            Coord[0] = w
        White_image[y][x] = np.floor(Coord)
23/71: a = re_image(Data[0],White_image,320,240)
23/72: show_img(a)
23/73:
disparity = [0,0]
w = 320
h = 240
x_bias,y_bias = disparity
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+disparity
        if Coord[1]>h-1:
            Coord[1] = h
        if Coord[0]>w-1:
            Coord[0] = w
        White_image[y][x] = np.floor(Coord)
23/74: a = re_image(Data[0],White_image,320,240)
23/75: show_img(a)
23/76: a = re_image(Data[0],White_image,320,240)
23/77: show_img(a)
23/78: a.shape
23/79: I.show
23/80:
I = Q_interpolator([0.3,0.8])
show_img(I)
23/81: matrix_2_img(Data[0])
23/82: show_img(matrix_2_img(Data[0]))
23/83: show_img(a)
23/84: a = re_image(Data[1],White_image,320,240)
23/85: show_img(matrix_2_img(Data[1]))
23/86: show_img(a)
23/87: a = re_image(Data[89],White_image,320,240)
23/88: show_img(matrix_2_img(Data[89]))
23/89: show_img(a)
23/90: a = re_image(Data[89],White_image,320,240)
23/91: show_img(a)
23/92: White_image = disparity_matrix([0,0],240,320)
23/93: a = re_image(Data[89],White_image,320,240)
23/94: show_img(a)
23/95: White_image = disparity_matrix([0,0],4,4)
23/96: White_image
23/97: White_image = disparity_matrix([0,0],2,4)
23/98: White_image
23/99: White_image[0]
23/100: a = re_image(Data[89],White_image,240,320)
23/101: show_img(matrix_2_img(Data[89]))
23/102: show_img(a)
23/103: a = re_image(Data[89],White_image,240,320)
23/104:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint8)
    for x in range(w):
        for y in range(h):
            Coord = np.array([x|,y])+disparity
            if Coord[1]>h-1:
                Coord[1] = h
            if Coord[0]>w-1:
                Coord[0] = w
            White_image[y][x] = np.floor(Coord)
    return White_image
23/105:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint8)
    for x in range(w):
        for y in range(h):
            Coord = np.array([x,y])+disparity
            if Coord[1]>h-1:
                Coord[1] = h
            if Coord[0]>w-1:
                Coord[0] = w
            White_image[y][x] = np.floor(Coord)
    return White_image
23/106:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for x in range(w):
        for y in range(h):
            try:
                u,v = Bias_map[y][x]
                White_image[y][x] = Image[v-1][u-1]
            except:
                print(u,v)
                print(x,y)
                return 0
    return White_image
23/107: a = re_image(Data[89],White_image,240,320)
24/1:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
24/2:
def normalize(v):
    norm=np.linalg.norm(v, ord=1)
    if norm==0:
        norm=np.finfo(v.dtype).eps
    return v/norm
def show_img(img):
    im=Image.fromarray(img) 
    im.show()
#get the photo [320*240] as a vector with the uv coord(x,y)
def get_photo(x,y):
    index = 255-x-16*y
    return Data[index]
#Input:photos like as(wh,3)*n,and the weight
#Output:photos*weight
def Blend_by_weight(P,w):
    Image = np.zeros((76800,3),dtype=np.uint8)
    for i in range(len(P)):
        Temp = (np.floor(P[i]*w[i])).astype(np.uint8)
        Image = Image + Temp
    return matrix_2_img(Image)
24/3:
#Input:photos like as(wh,3)*n,and the weight
#Output:photos*weight
def Blend_4(P,w):
    Image = np.zeros((76800,3),dtype=np.uint8)
    for i in range(len(P)):
        Temp = (np.floor(P[i]*w[i])).astype(np.uint8)
        Image = Image + Temp
    return matrix_2_img(Image)
24/4:
#x(0,15),y(0,15)
def Q_interpolator(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo(x_,y_)
    p2 = get_photo(x_+1,y_)
    p3 = get_photo(x_,y_-1)
    p4 = get_photo(x_+1,y_-1)
    return Blend_by_weight([p1,p2,p3,p4],normalize(w))
24/5:
I = Q_interpolator([0.3,0.8])
show_img(I)
24/6:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint8)
    for x in range(w):
        for y in range(h):
            Coord = np.array([x,y])+disparity
            if Coord[1]>h-1:
                Coord[1] = h
            if Coord[0]>w-1:
                Coord[0] = w
            White_image[y][x] = np.floor(Coord)
    return White_image
24/7:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for x in range(w):
        for y in range(h):
            try:
                u,v = Bias_map[y][x]
                White_image[y][x] = Image[v-1][u-1]
            except:
                print(u,v)
                print(x,y)
                return 0
    return White_image
24/8: White_image = disparity_matrix([0,0],240,320)
24/9: White_image[0]
24/10: White_image[0].shape
24/11: White_image = disparity_matrix([0,0],3,4)
24/12: White_image
24/13: White_image[0]
24/14:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint8)
    for x in range(w):
        for y in range(h):
            Coord = np.array([x,y])+disparity
            if Coord[1]>h-1:
                Coord[1] = h
            if Coord[0]>w-1:
                Coord[0] = w
            White_image[x][y] = np.floor(Coord)
    return White_image
24/15: White_image = disparity_matrix([0,0],3,4)
24/16:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint8)
    for x in range(w):
        for y in range(h):
            Coord = np.array([x,y])+disparity
            if Coord[1]>h-1:
                Coord[1] = h
            if Coord[0]>w-1:
                Coord[0] = w
            White_image[x-1][y-1] = np.floor(Coord)
    return White_image
24/17: White_image = disparity_matrix([0,0],3,4)
24/18: White_image[0]
24/19: print(White_image)
24/20:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint8)
    for x in range(w):
        for y in range(h):
            Coord = np.array([x,y])+disparity
            if Coord[1]>h-1:
                Coord[1] = h-1
            if Coord[0]>w-1:
                Coord[0] = w-1
            White_image[x][y] = np.floor(Coord)
    return White_image
24/21: White_image = disparity_matrix([0,0],3,4)
24/22: White_image = np.zeros((3,2,2),dtype=np.uint8)
24/23: White_image
24/24: White_image[0]
24/25: White_image[1]
24/26: White_image[2]
24/27: White_image[1][2]
24/28: White_image[1][1]
24/29:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint8)
    for x in range(w):
        for y in range(h):
            Coord = np.array([x,y])+disparity
            if Coord[1]>h-1:
                Coord[1] = h-1
            if Coord[0]>w-1:
                Coord[0] = w-1
            White_image[x][y] = np.floor(Coord)
    return White_image
24/30: White_image = disparity_matrix([0,0],3,2)
24/31:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint8)
    for x in range(w):
        for y in range(h):
            try:
                Coord = np.array([x,y])+disparity
                if Coord[1]>h-1:
                    Coord[1] = h-1
                if Coord[0]>w-1:
                    Coord[0] = w-1
                White_image[x][y] = np.floor(Coord)
            except:
                print(x,y)
    return White_image
24/32: White_image = disparity_matrix([0,0],3,2)
24/33: White_image = np.zeros((2,3),dtype=np.uint8)
24/34: White_image
24/35: White_image = np.zeros((2,3,2),dtype=np.uint8)
24/36: White_image
24/37: White_image[0][2]
24/38: White_image = disparity_matrix([0,0],3,2)
24/39:
x_bias,y_bias = [0,0]
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        try:
            Coord = np.array([x,y])+disparity
            if Coord[1]>h-1:
                Coord[1] = h-1
            if Coord[0]>w-1:
                Coord[0] = w-1
            White_image[x][y] = np.floor(Coord)
        except:
            print(x,y)
24/40:
x_bias,y_bias = [0,0]
h = 3
w = 2
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        try:
            Coord = np.array([x,y])+disparity
            if Coord[1]>h-1:
                Coord[1] = h-1
            if Coord[0]>w-1:
                Coord[0] = w-1
            White_image[x][y] = np.floor(Coord)
        except:
            print(x,y)
24/41:
x_bias,y_bias = [0,0]
h = 3
w = 2
White_image = np.zeros((h,w,2),dtype=np.uint8)
print(White_image)
for x in range(w):
    for y in range(h):
        try:
            Coord = np.array([x,y])+disparity
            if Coord[1]>h-1:
                Coord[1] = h-1
            if Coord[0]>w-1:
                Coord[0] = w-1
            White_image[x][y] = np.floor(Coord)
        except:
            print(x,y)
24/42:
x_bias,y_bias = [0,0]
h = 3
w = 2
White_image = np.zeros((h,w,2),dtype=np.uint8)
print(White_image)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])+disparity
        if Coord[1]>h-1:
            Coord[1] = h-1
        if Coord[0]>w-1:
            Coord[0] = w-1
        White_image[x][y] = np.floor(Coord)
24/43:
x_bias,y_bias = [0,0]
h = 3
w = 2
White_image = np.zeros((h,w,2),dtype=np.uint8)
print(White_image)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])
        if Coord[1]>h-1:
            Coord[1] = h-1
        if Coord[0]>w-1:
            Coord[0] = w-1
        White_image[x][y] = np.floor(Coord)
24/44:
x_bias,y_bias = [0,0]
h = 3
w = 2
White_image = np.zeros((h,w,2),dtype=np.uint8)
print(White_image)
for x in range(w):
    for y in range(h):
        print(x,y)
        Coord = np.array([x,y])
        if Coord[1]>h-1:
            Coord[1] = h-1
        if Coord[0]>w-1:
            Coord[0] = w-1
        White_image[x][y] = np.floor(Coord)
24/45: White_image[0][2]
24/46: White_image = np.zeros((h,w,2),dtype=np.uint8)
24/47: White_image
24/48:
x_bias,y_bias = [0,0]
h = 3
w = 2
White_image = np.zeros((h,w,2),dtype=np.uint8)
print(White_image)
for x in range(h):
    for y in range(w):
        print(x,y)
        Coord = np.array([x,y])
        if Coord[1]>h-1:
            Coord[1] = h-1
        if Coord[0]>w-1:
            Coord[0] = w-1
        White_image[x][y] = np.floor(Coord)
24/49: White_image
24/50:
x_bias,y_bias = [0,0]
h = 3
w = 2
White_image = np.zeros((h,w,2),dtype=np.uint8)
print(White_image)
for x in range(h):
    for y in range(w):
        Coord = np.array([x,y])
        if Coord[1]>h-1:
            Coord[1] = h
        if Coord[0]>w-1:
            Coord[0] = w
        White_image[x][y] = np.floor(Coord)
24/51:
x_bias,y_bias = [0,0]
h = 3
w = 2
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(h):
    for y in range(w):
        Coord = np.array([x,y])
        if Coord[1]>h-1:
            Coord[1] = h
        if Coord[0]>w-1:
            Coord[0] = w
        White_image[x][y] = np.floor(Coord)
24/52: White_image
24/53:
x_bias,y_bias = [0,0]
h = 3
w = 2
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(h):
    for y in range(w):
        Coord = np.array([x,y])
        if Coord[1]>h-1:
            Coord[1] = h
        if Coord[0]>w-1:
            Coord[0] = w
        White_image[y][x] = np.floor(Coord)
24/54:
x_bias,y_bias = [0,0]
h = 3
w = 2
White_image = np.zeros((h,w,2),dtype=np.uint8)
for x in range(w):
    for y in range(h):
        Coord = np.array([x,y])
        if Coord[1]>h-1:
            Coord[1] = h
        if Coord[0]>w-1:
            Coord[0] = w
        White_image[y][x] = np.floor(Coord)
24/55: White_image
24/56: White_image[2][1]
24/57:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint8)
    for x in range(w):
        for y in range(h):
            Coord = np.array([x,y])+disparity
            if Coord[1]>h-1:
                Coord[1] = h
            if Coord[0]>w-1:
                Coord[0] = w
            White_image[y][x] = np.floor(Coord)
    return White_image
24/58:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for x in range(w):
        for y in range(h):
            try:
                u,v = Bias_map[y][x]
                White_image[y][x] = Image[v][u]
            except:
                print(u,v)
                print(x,y)
                return 0
    return White_image
24/59: White_image = disparity_matrix([0,0],3,2)
24/60:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint8)
    for x in range(w):
        for y in range(h):
            Coord = np.array([x,y])+disparity
            if Coord[1]>h-1:
                Coord[1] = h
            if Coord[0]>w-1:
                Coord[0] = w
            White_image[y][x] = np.floor(Coord)
    return White_image
24/61: W = disparity_matrix([0,0],240,320)
24/62: re_image(matrix_2_img(Data[0]),W,320,240)
24/63: I = re_image(matrix_2_img(Data[0]),W,320,240)
24/64: show_img(I)
25/1:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
25/2:
def normalize(v):
    norm=np.linalg.norm(v, ord=1)
    if norm==0:
        norm=np.finfo(v.dtype).eps
    return v/norm
def show_img(img):
    im=Image.fromarray(img) 
    im.show()
#get the photo [320*240] as a vector with the uv coord(x,y)
def get_photo(x,y):
    index = 255-x-16*y
    return Data[index]
#Input:photos like as(wh,3)*n,and the weight
#Output:photos*weight
def Blend_by_weight(P,w):
    Image = np.zeros((76800,3),dtype=np.uint8)
    for i in range(len(P)):
        Temp = (np.floor(P[i]*w[i])).astype(np.uint8)
        Image = Image + Temp
    return matrix_2_img(Image)
25/3:
#Input:photos like as(wh,3)*n,and the weight
#Output:photos*weight
def Blend_4(P,w):
    Image = np.zeros((76800,3),dtype=np.uint8)
    for i in range(len(P)):
        Temp = (np.floor(P[i]*w[i])).astype(np.uint8)
        Image = Image + Temp
    return matrix_2_img(Image)
25/4:
#x(0,15),y(0,15)
def Q_interpolator(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo(x_,y_)
    p2 = get_photo(x_+1,y_)
    p3 = get_photo(x_,y_-1)
    p4 = get_photo(x_+1,y_-1)
    return Blend_by_weight([p1,p2,p3,p4],normalize(w))
25/5:
I = Q_interpolator([0.3,0.8])
show_img(I)
25/6:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint8)
    for x in range(w):
        for y in range(h):
            Coord = np.array([x,y])+disparity
            if Coord[1]>h-1:
                Coord[1] = h
            if Coord[0]>w-1:
                Coord[0] = w
            White_image[y][x] = np.floor(Coord)
    return White_image
25/7:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for x in range(w):
        for y in range(h):
            try:
                u,v = Bias_map[y][x]
                White_image[y][x] = Image[v][u]
            except:
                print(u,v)
                print(x,y)
                return 0
    return White_image
25/8: disparity_matrix([0,0],3,4)
25/9: W = disparity_matrix([0,0],3,4)
25/10: W[0][1]
25/11: W
25/12:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for x in range(w):
        for y in range(h):
            u,v = Bias_map[y][x]
            White_image[y][x] = Image[v][u]
    return White_image
25/13: I = re_image(matrix_2_img(Data[0]),W,320,240)
25/14: W = disparity_matrix([0,0],240,320)
25/15: I = re_image(matrix_2_img(Data[0]),W,320,240)
25/16: White_image = np.zeros((h,w,2),dtype=np.uint8)
25/17: show_img(I)
25/18: W = disparity_matrix([0,0],2,4)
25/19: W
25/20: a = [[1,2,3,4],[5,6,7,8]]
25/21: a = np.array(a)
25/22: a
25/23: re_image(a,W,4,2)
25/24:
Bias_map = W
Image = a
h = 2
w = 4
White_image = np.zeros((h,w,3),dtype=np.uint8)
#Based on the new,coords,get the pixels from the orginal photo
for x in range(w):
    for y in range(h):
        u,v = Bias_map[y][x]
        White_image[y][x] = Image[v][u]
25/25: White_image
25/26: W = disparity_matrix([0,0],2,4)
25/27: a = np.array(a)
25/28:
Bias_map = W
Image = a
h = 2
w = 4
White_image = np.zeros((h,w,3),dtype=np.uint8)
#Based on the new,coords,get the pixels from the orginal photo
for x in range(w):
    for y in range(h):
        u,v = Bias_map[y][x]
        White_image[y][x] = Image[v][u]
25/29: White_image
25/30:
Bias_map = W
Image = a
h = 2
w = 4
White_image = np.zeros((h,w),dtype=np.uint8)
#Based on the new,coords,get the pixels from the orginal photo
for x in range(w):
    for y in range(h):
        u,v = Bias_map[y][x]
        White_image[y][x] = Image[v][u]
25/31: White_image
25/32: a
25/33: a = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
25/34: a = np.array(a)
25/35: W = disparity_matrix([0,0],3,4)
25/36: a = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
25/37: a = np.array(a)
25/38:
Bias_map = W
Image = a
h = 3
w = 4
White_image = np.zeros((h,w),dtype=np.uint8)
#Based on the new,coords,get the pixels from the orginal photo
for x in range(w):
    for y in range(h):
        u,v = Bias_map[y][x]
        White_image[y][x] = Image[v][u]
25/39: White_image
25/40: W = disparity_matrix([0,0],240,320)
25/41: matrix_2_img(Data[0])
25/42: show_img(matrix_2_img(Data[0]))
25/43:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
25/44: show_img(matrix_2_img(Data[0]))
25/45:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for x in range(w):
        for y in range(h):
            u,v = Bias_map[y][x]
            White_image[y][x] = Image[u][v]
    return White_image
25/46: W = disparity_matrix([0,0],240,320)
25/47: I = re_image(Data[0],W,320,240)
25/48:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for x in range(w):
        for y in range(h):
            u,v = Bias_map[y][x]
            White_image[y][x] = Image[v][u]
    return White_image
25/49: W = disparity_matrix([0,0],240,320)
25/50: I = re_image(Data[0],W,320,240)
25/51: show_img(I)
25/52: W[0]
25/53:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2))
    for x in range(w):
        for y in range(h):
            Coord = np.array([x,y])+disparity
            if Coord[1]>h-1:
                Coord[1] = h
            if Coord[0]>w-1:
                Coord[0] = w
            White_image[y][x] = np.floor(Coord)
    return White_image
25/54:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for x in range(w):
        for y in range(h):
            u,v = Bias_map[y][x]
            White_image[y][x] = Image[v][u]
    return White_image
25/55: W = disparity_matrix([0,0],240,320)
25/56: I = re_image(Data[0],W,320,240)
25/57:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint16)
    for x in range(w):
        for y in range(h):
            Coord = np.array([x,y])+disparity
            if Coord[1]>h-1:
                Coord[1] = h
            if Coord[0]>w-1:
                Coord[0] = w
            White_image[y][x] = np.floor(Coord)
    return White_image
25/58: W = disparity_matrix([0,0],240,320)
25/59: W[0]
25/60:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for x in range(w):
        for y in range(h):
            u,v = Bias_map[y][x]
            White_image[y][x] = Image[v][u]
    return White_image
25/61: W = disparity_matrix([0,0],240,320)
25/62: I = re_image(Data[0],W,320,240)
25/63: show_img(I)
25/64:
a = 1
5*a,2*a = c
c
25/65:
a = 1
5+a,2+a = c
c
25/66: np.array([1,2])*[3,4]
25/67:
def get_bias(center,point_set,x_bias,y_bias):
    #Based on the center get the bias of all arround points
    Bias_all = [] 
    for i in range(len(point_set)):
        Bias = (point_set[i]-center)*[x_bias,y_bias]
        Bias_all.append(Bias)
    return Bias_all
25/68:
def Q_interpolator2(coords,x_bias,y_bias):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
    Bias_all = get_bias(coords,Square,0.3,0.2)
    #The bais for 4 photo
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    P = [get_photo(Square[i][0],Square[i][1]) for i in range(len(Square))]
    #All bias matrix
    Disparity_matrix = [disparity_matrix(B) for B in Bias_all]
    #All redo image
    Re_images = [re_image(P[i],Bias_all[i],320,240) for i in range(len(Bias_all))]
    #Blend redo image
    return Blend_by_weight(Re_images,normalize(w))
25/69:
I = Q_interpolator2([0.3,0.8])
I
25/70:
I = Q_interpolator2([0.3,0.8],0.3,0.2)
I
25/71:
def get_bias(center,point_set,x_bias,y_bias):
    #Based on the center get the bias of all arround points
    Bias_all = [] 
    for i in range(len(point_set)):
        print(point_set[i])
        print(center)
        print(point_set[i]-center)
        Bias = (point_set[i]-center)*[x_bias,y_bias]
        Bias_all.append(Bias)
    return Bias_all
25/72:
I = Q_interpolator2([0.3,0.8],0.3,0.2)
I
25/73:
def get_bias(center,point_set,x_bias,y_bias):
    #Based on the center get the bias of all arround points
    Bias_all = [] 
    for i in range(len(point_set)):
        Bias = (np.array(point_set[i])-center)*[x_bias,y_bias]
        Bias_all.append(Bias)
    return Bias_all
25/74:
I = Q_interpolator2([0.3,0.8],0.3,0.2)
I
25/75:
def Q_interpolator2(coords,x_bias,y_bias):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
    Bias_all = get_bias(coords,Square,0.3,0.2)
    #The bais for 4 photo
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    P = [get_photo(Square[i][0],Square[i][1]) for i in range(len(Square))]
    #All bias matrix
    Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
    #All redo image
    Re_images = [re_image(P[i],Bias_all[i],320,240) for i in range(len(Bias_all))]
    #Blend redo image
    return Blend_by_weight(Re_images,normalize(w))
25/76:
I = Q_interpolator2([0.3,0.8],0.3,0.2)
I
25/77:
coords = [0.3,0.8]
x,y = (coords[0],coords[1])
x_ = int(x)
y_ = math.ceil(y)
Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
Bias_all = get_bias(coords,Square,0.3,0.2)
print(Bias_all)
25/78:
coords = [2.1,3.6]
x,y = (coords[0],coords[1])
x_ = int(x)
y_ = math.ceil(y)
Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
Bias_all = get_bias(coords,Square,0.3,0.2)
print(Bias_all)
25/79:
coords = [2.1,3.6]
x,y = (coords[0],coords[1])
x_ = int(x)
y_ = math.ceil(y)
Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
Bias_all = get_bias(coords,Square,3,3)
print(Bias_all)
25/80:
#The bais for 4 photo
d1 = x-x_
d2 = y_-y
w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
P = [get_photo(Square[i][0],Square[i][1]) for i in range(len(Square))]
#All bias matrix
Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
25/81: Disparity_matrix[0]
25/82:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint16)
    for x in range(w):
        for y in range(h):
            Coord = np.array([x,y])+disparity
            if Coord[1]<0 :
                Coord[1] = 0
            if Coord[0]<0:
                Coord[0] = 0
            if Coord[1]>h-1 :
                Coord[1] = h
            if Coord[0]>w-1:
                Coord[0] = w
            White_image[y][x] = np.floor(Coord)
    return White_image
25/83:
#The bais for 4 photo
d1 = x-x_
d2 = y_-y
w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
P = [get_photo(Square[i][0],Square[i][1]) for i in range(len(Square))]
#All bias matrix
Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
25/84: Disparity_matrix[0]
25/85: Disparity_matrix[15][108]
25/86: Disparity_matrix[0]
25/87: Disparity_matrix[0][15][104]
25/88:
#All redo image
Re_images = [re_image(P[i],Bias_all[i],320,240) for i in range(len(Bias_all))]
25/89: Disparity_matrix[0][239][1]
25/90: Disparity_matrix[0][239][0]
25/91:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint16)
    for x in range(w):
        for y in range(h):
            Coord = np.array([x,y])+disparity
            if Coord[1]<0 :
                Coord[1] = 0
            if Coord[0]<0:
                Coord[0] = 0
            if Coord[1]>h-1 :
                Coord[1] = h-1
            if Coord[0]>w-1:
                Coord[0] = w-1
            White_image[y][x] = np.floor(Coord)
    return White_image
25/92:
coords = [2.1,3.6]
x,y = (coords[0],coords[1])
x_ = int(x)
y_ = math.ceil(y)
Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
Bias_all = get_bias(coords,Square,3,3)
print(Bias_all)
25/93:
#The bais for 4 photo
d1 = x-x_
d2 = y_-y
w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
P = [get_photo(Square[i][0],Square[i][1]) for i in range(len(Square))]
#All bias matrix
Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
25/94: Disparity_matrix[0][239][0]
25/95:
#All redo image
Re_images = [re_image(P[i],Bias_all[i],320,240) for i in range(len(Bias_all))]
25/96: Disparity_matrix[0][22][319]
25/97: Disparity_matrix[0][22][320]
25/98: Disparity_matrix[0][22][319]
25/99: Disparity_matrix[0][32][319]
25/100: Disparity_matrix[0][33][319]
25/101: re_image(P[0],Bias_all[0],320,240)
25/102:
#Image base
Image = matrix_2_img(P[0])
#New image
Bias_map = Bias_all[0]
h = 240
w = 320
White_image = np.zeros((h,w,3),dtype=np.uint8)
#Based on the new,coords,get the pixels from the orginal photo
for x in range(w):
    for y in range(h):
        u,v = Bias_map[y][x]
        White_image[y][x] = Image[v][u]
25/103:
#Image base
Image = matrix_2_img(P[0])
#New image
Bias_map = Bias_all[0]
h = 240
w = 320
White_image = np.zeros((h,w,3),dtype=np.uint8)
#Based on the new,coords,get the pixels from the orginal photo
for x in range(w):
    for y in range(h):
        u,v = Bias_map[y][x]
        White_image[y][x] = Image[v][u]
25/104:
#Image base
Image = matrix_2_img(P[0])
#New image
Bias_map = Bias_all[0]
h = 240
w = 320
White_image = np.zeros((h,w,3),dtype=np.uint8)
#Based on the new,coords,get the pixels from the orginal photo
for x in range(w):
    for y in range(h):
        try:
            u,v = Bias_map[y][x]
            White_image[y][x] = Image[v][u]
        except:
            print(x,y)
25/105:
#Image base
Image = matrix_2_img(P[0])
#New image
Bias_map = Bias_all[0]
h = 240
w = 320
White_image = np.zeros((h,w,3),dtype=np.uint8)
#Based on the new,coords,get the pixels from the orginal photo
for x in range(w):
    for y in range(h):
        u,v = Bias_map[y][x]
        White_image[y][x] = Image[v][u]
25/106: Bias_map[0][0]
25/107: Bias_map
25/108:
def Q_interpolator2(coords,x_bias,y_bias):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
    Bias_all = get_bias(coords,Square,0.3,0.2)
    #The bais for 4 photo
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    P = [get_photo(Square[i][0],Square[i][1]) for i in range(len(Square))]
    #All bias matrix
    Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
    #All redo image
    Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
    #Blend redo image
    return Blend_by_weight(Re_images,normalize(w))
25/109:
#All redo image
Re_images = [re_image(P[i],Bias_all[i],320,240) for i in range(len(Bias_all))]
25/110:
def Q_interpolator2(coords,x_bias,y_bias):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
    Bias_all = get_bias(coords,Square,0.3,0.2)
    #The bais for 4 photo
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    P = [get_photo(Square[i][0],Square[i][1]) for i in range(len(Square))]
    #All bias matrix
    Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
    #All redo image
    Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
    #Blend redo image
    return Blend_by_weight(Re_images,normalize(w))
25/111:
coords = [2.1,3.6]
x,y = (coords[0],coords[1])
x_ = int(x)
y_ = math.ceil(y)
Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
Bias_all = get_bias(coords,Square,3,3)
print(Bias_all)
25/112:
#The bais for 4 photo
d1 = x-x_
d2 = y_-y
w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
P = [get_photo(Square[i][0],Square[i][1]) for i in range(len(Square))]
#All bias matrix
Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
25/113:
#All redo image
Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
25/114: Blend_by_weight(re_image,normalize(w))
25/115: Blend_by_weight(Re_images,normalize(w))
25/116:
R = [img_2_matrix(pp) for pp in Re_images]
Blend_by_weight(R,normalize(w))
25/117:
R = [img_2_matrix(pp) for pp in Re_images]
X = Blend_by_weight(R,normalize(w))
25/118: show_img(X)
25/119: show_img(X)
25/120: X.shape
25/121: X[0][0]
25/122: X
25/123: show_img(X)
25/124:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
25/125: show_img(X)
25/126: Q_interpolator2([2.1,3.6],3,4)
25/127:
def Q_interpolator2(coords,x_bias,y_bias):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
    Bias_all = get_bias(coords,Square,0.3,0.2)
    #The bais for 4 photo
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    P = [get_photo(Square[i][0],Square[i][1]) for i in range(len(Square))]
    #All bias matrix
    Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
    #All redo image
    Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
    #Blend redo image
    R = [img_2_matrix(pp) for pp in Re_images]
    return Blend_by_weight(R,normalize(w))
25/128: Q_interpolator2([2.1,3.6],3,4)
25/129: X = Q_interpolator2([2.1,3.6],3,4)
25/130: show_img(X)
25/131: X = Q_interpolator([2.1,3.6])
25/132: show_img(X)
25/133: X = Q_interpolator2([2.1,3.6],3,4)
25/134: show_img(X)
25/135: X = Q_interpolator2([2.1,3.6],2,4)
25/136: show_img(X)
25/137: X = Q_interpolator2([2.1,3.6],2,4)
25/138: show_img(X)
25/139:
Y = Q_interpolator([2.1,3.6])
show_img(X)
25/140: X = Q_interpolator2([2.1,3.6],2,4)
25/141: show_img(X)
25/142:
Y = Q_interpolator([2.1,3.6])
show_img(X)
25/143:
Y = Q_interpolator([2.1,3.6])
show_img(Y)
25/144: X = Q_interpolator2([2.1,3.6],6,7)
25/145: show_img(X)
25/146:
Y = Q_interpolator([2.1,3.6])
show_img(Y)
25/147: show_img(X)
25/148: X = Q_interpolator2([2.1,3.6],10,7)
25/149: show_img(X)
25/150: X = Q_interpolator2([2.1,3.6],2,2)
25/151: show_img(X)
25/152:
Y = Q_interpolator([2.1,3.6])
show_img(Y)
25/153: X = Q_interpolator2([8,8],3,3)
25/154: show_img(X)
25/155: X = Q_interpolator2([8.4,8.6],3,3)
25/156: show_img(X)
25/157: X
25/158:
Y = Q_interpolator([8,8])
show_img(Y)
25/159:
Y = Q_interpolator([8.4,8.6])
show_img(Y)
25/160: X = Q_interpolator2([8.4,8.6],3,3)
25/161: show_img(X)
25/162: X = Q_interpolator2([8.4,8.6],5,5)
25/163: show_img(X)
25/164: X = Q_interpolator2([8.4,8.6],2,2)
25/165: show_img(X)
25/166: X = Q_interpolator2([8.4,8.6],2)
25/167: X = Q_interpolator2([8.4,8.6],2,6)
25/168: show_img(X)
25/169: X = Q_interpolator2([8.4,8.6],4,6)
25/170: X = Q_interpolator2([8.4,8.6],4,6)
25/171: show_img(X)
25/172: X = Q_interpolator2([8.4,8.6],15,17)
25/173: show_img(X)
25/174:
def Q_interpolator2(coords,x_bias,y_bias):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
    Bias_all = get_bias(coords,Square,x_bias,y_bias)
    #The bais for 4 photo
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    P = [get_photo(Square[i][0],Square[i][1]) for i in range(len(Square))]
    #All bias matrix
    Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
    #All redo image
    Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
    #Blend redo image
    R = [img_2_matrix(pp) for pp in Re_images]
    return Blend_by_weight(R,normalize(w))
25/175: X = Q_interpolator2([8.4,8.6],3,3)
25/176: show_img(X)
25/177: X = Q_interpolator2([8.4,8.6],5,3)
25/178: show_img(X)
25/179: X = Q_interpolator2([8.4,8.6],2,2)
25/180: show_img(X)
25/181: X = Q_interpolator2([8.4,8.6],7,7)
25/182: show_img(X)
25/183: X = Q_interpolator2([8.4,8.6],10,10)
25/184: show_img(X)
25/185: X = Q_interpolator2([8.4,8.6],3,4)
25/186: show_img(X)
25/187:
X = Q_interpolator2([8.4,8.6],3,4)
show_img(X)
25/188:
X = Q_interpolator2([8.4,8.6],3.5,4)
show_img(X)
25/189:
X = Q_interpolator2([8.4,8.6],2,4)
show_img(X)
25/190:
X = Q_interpolator2([8.4,8.6],1.5,4)
show_img(X)
25/191:
X = Q_interpolator2([8.4,8.6],1.5,3.8)
show_img(X)
25/192:
X = Q_interpolator2([8.4,8.6],2.5,3.8)
show_img(X)
25/193:
X = Q_interpolator2([8.4,8.6],4.5,3.8)
show_img(X)
25/194:
X = Q_interpolator2([8.4,8.6],4.5,3.8)
im=Image.fromarray(X)
X
25/195:
X = Q_interpolator2([8.4,8.6],4.5,3.8)
im=Image.fromarray(X)
im
25/196:
Y = Q_interpolator([8.4,8.6])
im=Image.fromarray(Y)
im
25/197:
X = Q_interpolator2([8.4,8.6],5,3.8)
im=Image.fromarray(X)
im
25/198:
X = Q_interpolator2([8.4,8.6],6,3.8)
im=Image.fromarray(X)
im
25/199:
X = Q_interpolator2([8.4,8.6],5,5)
im=Image.fromarray(X)
im
25/200:
X = Q_interpolator2([8.4,8.6],6,6)
im=Image.fromarray(X)
im
25/201:
X = Q_interpolator2([8.4,8.6],7,7)
im=Image.fromarray(X)
im
25/202:
X = Q_interpolator2([8.4,8.6],8,7)
im=Image.fromarray(X)
im
25/203:
X = Q_interpolator2([8.4,8.6],10,7)
im=Image.fromarray(X)
im
25/204:
X = Q_interpolator2([8.4,8.6],2,2)
im=Image.fromarray(X)
im
25/205:
X = Q_interpolator2([8.4,8.6],0.8,0.5)
im=Image.fromarray(X)
im
25/206:
X = Q_interpolator2([8.4,8.6],1.2,1.3)
im=Image.fromarray(X)
im
25/207:
X = Q_interpolator2([8.4,8.6],1.2,2)
im=Image.fromarray(X)
im
25/208:
Y = Q_interpolator([8.4,8.6])
im=Image.fromarray(Y)
im
25/209:
X = Q_interpolator2([8.4,8.6],1.2,3)
im=Image.fromarray(X)
im
25/210:
X = Q_interpolator2([8.4,8.6],1.2,3.5)
im=Image.fromarray(X)
im
25/211:
X = Q_interpolator2([8.4,8.6],1.2,3.)7
im=Image.fromarray(X)
im
25/212:
X = Q_interpolator2([8.4,8.6],1.2,3.7)
im=Image.fromarray(X)
im
25/213:
X = Q_interpolator2([8.4,8.6],1.2,3.9)
im=Image.fromarray(X)
im
25/214:
X = Q_interpolator2([8.4,8.6],1.8,3.9)
im=Image.fromarray(X)
im
25/215:
X = Q_interpolator2([8.4,8.6],2.2,3.9)
im=Image.fromarray(X)
im
25/216:
X = Q_interpolator2([8.4,8.6],2.9,3.9)
im=Image.fromarray(X)
im
25/217:
X = Q_interpolator2([8.4,8.6],-0.8,3.9)
im=Image.fromarray(X)
im
25/218:
X = Q_interpolator2([8.4,8.6],-1.2,3.9)
im=Image.fromarray(X)
im
25/219:
X = Q_interpolator2([8.4,8.6],-1.5,3.9)
im=Image.fromarray(X)
im
25/220:
X = Q_interpolator2([8.4,8.6],-1.9,3.9)
im=Image.fromarray(X)
im
25/221:
X = Q_interpolator2([8.4,8.6],-2.2,3.9)
im=Image.fromarray(X)
im
25/222:
X = Q_interpolator2([8.4,8.6],-2.6,3.9)
im=Image.fromarray(X)
im
25/223:
X = Q_interpolator2([8.4,8.6],-2.9,3.9)
im=Image.fromarray(X)
im
25/224:
X = Q_interpolator2([8.4,8.6],-3.1,4.2)
im=Image.fromarray(X)
im
25/225:
X = Q_interpolator2([8.4,8.6],-3.5,4.5)
im=Image.fromarray(X)
im
25/226:
def get_aperture_image(x,y,size):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size)
    ALL_set = A+B
    P = [get_photo(i[0],i[1]) for i in ALL_set]
    return Blend_by_weight(P,Weight)
25/227:
def aperture_size(coord,r):
    Max = np.array(coord)+r
    Min = np.array(coord)-r
    return print(Max)
25/228:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    y = (H*Range).astype(int) 
    x = (W*Range).astype(int) 
    image = image[y[0]:y[1],x[0]:x[1]]
    I = Image.fromarray(image).resize((320,240))
    return np.array(I)
25/229:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Left = [[x1y1[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Right = [[x4y4[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Outer = Up+Down+Left+Right
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Temp.append([i,j])
        Inner = Inner + Temp
    return Inner,Outer
25/230:
def Get_distence(A,center):
    A = np.array(A)
    return (np.sum((A-center)**2,axis=1))**0.5
25/231:
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = (norm.pdf(Out_d,scale=2))*Out_
    Weight_inner = norm.pdf(In_d,scale=2)
    ALL_weight = np.hstack((Weight_Out,Weight_inner))
    return normalize(ALL_weight)
25/232:
def get_aperture_image(x,y,size):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size)
    ALL_set = A+B
    P = [get_photo(i[0],i[1]) for i in ALL_set]
    return Blend_by_weight(P,Weight)
25/233: get_aperture_image(8.4,8.6,2)
25/234: I = get_aperture_image(8.4,8.6,2)
25/235: show_img(i)
25/236: show_img(I)
26/1:
root = tk.Tk()

def Get_image(self):
    print(Y.get())

root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
root.mainloop()
26/2:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
26/3:
root = tk.Tk()

def Get_image(self):
    print(Y.get())

root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
root.mainloop()
26/4:
root = tk.Tk()

def Get_image(self):
    print(Y.get())

root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)

If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1).grid(column=3,row = 2,sticky=W)
var2 = IntVar()
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2).grid(column =3, row=3, sticky=W)
var1 = IntVar()
root.mainloop()
26/5:
root = tk.Tk()

def Get_image(self):
    print(Y.get())

root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
var1 = IntVar()
var2 = IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1).grid(column=3,row = 2,sticky=W)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2).grid(column =3, row=3, sticky=W)
root.mainloop()
27/1:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
27/2:
root = tk.Tk()

def Get_image(self):
    print(Y.get())

root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
var1 = IntVar()
var2 = IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1).grid(column=3,row = 2,sticky=W)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2).grid(column =3, row=3, sticky=W)
root.mainloop()
27/3:
root = tk.Tk()

def Get_image(self):
    print(Y.get())

root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
var1 = IntVar()
var2 = IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1).grid(column=3,row = 2,sticky=W)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2).grid(column =3, row=3, sticky=W)

root.mainloop()
28/1:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
28/2:
root = tk.Tk()

def Get_image(self):
    print(Y.get())

root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
var1 = IntVar()
var2 = IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1).grid(column=3,row = 2,sticky=W)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2).grid(column =3, row=3, sticky=W)

root.mainloop()
28/3:
root = tk.Tk()

def Get_image(self):
    print(Y.get())

root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
var1 = tk.IntVar()
var2 = tk.IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1).grid(column=3,row = 2,sticky=W)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2).grid(column =3, row=3, sticky=W)

root.mainloop()
29/1:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
29/2:
root = tk.Tk()

def Get_image(self):
    print(Y.get())

root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
var1 = tk.IntVar()
var2 = tk.IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1).grid(column=3,row = 2,sticky=W)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2).grid(column =3, row=3, sticky=W)

root.mainloop()
29/3:
root = tk.Tk()

def Get_image(self):
    print(Y.get())

root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
var1 = tk.IntVar()
var2 = tk.IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1).grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2).grid(column =3, row=3)

root.mainloop()
30/1:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
30/2:
root = tk.Tk()

def Get_image(self):
    print(Y.get())

root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
var1 = tk.IntVar()
var2 = tk.IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1).grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2).grid(column =3, row=3)

root.mainloop()
30/3:
root = tk.Tk()

def Get_image(self):
    print(Y.get())

root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
var1 = tk.IntVar()
var2 = tk.IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1).grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2).grid(column =3, row=3)

Make = tk.Button(root,text="Make image").grid(column = 5,row = 3)
root.mainloop()
30/4:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    y = (H*Range).astype(int) 
    x = (W*Range).astype(int) 
    image = image[y[0]:y[1],x[0]:x[1]]
    I = Image.fromarray(image).resize((320,240))
    return np.array(I)
30/5:
I = Q_interpolator([0.3,0.8])
show_img(I)
30/6:
def normalize(v):
    norm=np.linalg.norm(v, ord=1)
    if norm==0:
        norm=np.finfo(v.dtype).eps
    return v/norm
def show_img(img):
    im=Image.fromarray(img) 
    im.show()
#get the photo [320*240] as a vector with the uv coord(x,y)
def get_photo(x,y):
    index = 255-x-16*y
    return Data[index]
#Input:photos like as(wh,3)*n,and the weight
#Output:photos*weight
def Blend_by_weight(P,w):
    Image = np.zeros((76800,3),dtype=np.uint8)
    for i in range(len(P)):
        Temp = (np.floor(P[i]*w[i])).astype(np.uint8)
        Image = Image + Temp
    return matrix_2_img(Image)
30/7:
#x(0,15),y(0,15)
def Q_interpolator(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo(x_,y_)
    p2 = get_photo(x_+1,y_)
    p3 = get_photo(x_,y_-1)
    p4 = get_photo(x_+1,y_-1)
    return Blend_by_weight([p1,p2,p3,p4],normalize(w))
30/8:
I = Q_interpolator([0.3,0.8])
show_img(I)
30/9: I = Q_interpolator([0.3,0.8])
30/10: base = Image.fromarray(I)
30/11: I
30/12: I.show()
30/13: I = Q_interpolator([0.3,0.8])
30/14: base = Image.fromarray(I)
30/15: base.show()
30/16: base
30/17: I = Q_interpolator([8.4,8.6])
30/18: base = Image.fromarray(I)
30/19: base
30/20: scale_by_z(I)
30/21: scale_by_z(0.5,I)
30/22:
k = scale_by_z(0.5,I)
Image.fromarray(k)
30/23:
k = scale_by_z(0.6,I)
Image.fromarray(k)
30/24:
k = scale_by_z(0.75,I)
Image.fromarray(k)
30/25:
k = scale_by_z(0.25,I)
Image.fromarray(k)
30/26:
k = scale_by_z(0.35,I)
Image.fromarray(k)
30/27:
k = scale_by_z(0.5,I)
Image.fromarray(k)
30/28:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint16)
    for x in range(w):
        for y in range(h):
            Coord = np.array([x,y])+disparity
            if Coord[1]<0 :
                Coord[1] = 0
            if Coord[0]<0:
                Coord[0] = 0
            if Coord[1]>h-1 :
                Coord[1] = h-1
            if Coord[0]>w-1:
                Coord[0] = w-1
            White_image[y][x] = np.floor(Coord)
    return White_image
30/29:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for x in range(w):
        for y in range(h):
            u,v = Bias_map[y][x]
            White_image[y][x] = Image[v][u]
    return White_image
30/30:
def get_bias(center,point_set,x_bias,y_bias):
    #Based on the center get the bias of all arround points
    Bias_all = [] 
    for i in range(len(point_set)):
        Bias = (np.array(point_set[i])-center)*[x_bias,y_bias]
        Bias_all.append(Bias)
    return Bias_all
30/31:
def Q_interpolator2(coords,x_bias,y_bias):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
    Bias_all = get_bias(coords,Square,x_bias,y_bias)
    #The bais for 4 photo
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    P = [get_photo(Square[i][0],Square[i][1]) for i in range(len(Square))]
    #All bias matrix
    Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
    #All redo image
    Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
    #Blend redo image
    R = [img_2_matrix(pp) for pp in Re_images]
    return Blend_by_weight(R,normalize(w))
30/32:
def normalize(v):
    norm=np.linalg.norm(v, ord=1)
    if norm==0:
        norm=np.finfo(v.dtype).eps
    return v/norm
30/33:
X = Q_interpolator2([8.4,8.6],-3.5,4.5)
im=Image.fromarray(X)
im
30/34:
X = Q_interpolator2([8.4,8.6],-4,4.5)
im=Image.fromarray(X)
im
30/35:
X = Q_interpolator2([8.4,8.6],-2.8,4.5)
im=Image.fromarray(X)
im
30/36:
X = Q_interpolator2([8.4,8.6],-3.7,4.5)
im=Image.fromarray(X)
im
30/37:
X = Q_interpolator2([8.4,8.6],-4.3,4.5)
im=Image.fromarray(X)
im
30/38:
X = Q_interpolator2([8.4,8.6],-5,4.5)
im=Image.fromarray(X)
im
30/39:
X = Q_interpolator2([8.4,8.6],-5.3,4.5)
im=Image.fromarray(X)
im
30/40:
X = Q_interpolator2([8.4,8.6],-5.3,5)
im=Image.fromarray(X)
im
30/41:
X = Q_interpolator2([8.4,8.6],-5.3,5.6)
im=Image.fromarray(X)
im
30/42:
Y = Q_interpolator([8.4,8.6])
im=Image.fromarray(Y)
im
30/43:
X = Q_interpolator2([9.4,8.6],-5.3,5.6)
im=Image.fromarray(X)
im
30/44:
X = Q_interpolator2([12.4,8.6],-5.3,5.6)
im=Image.fromarray(X)
im
30/45:
X = Q_interpolator2([13.4,12.6],-5.3,5.6)
im=Image.fromarray(X)
im
30/46:
X = Q_interpolator2([8.4,8.6],-5.3,5.6)
im=Image.fromarray(X)
im
30/47:
X = Q_interpolator2([8.4,8.6],-9.3,5.6)
im=Image.fromarray(X)
im
30/48:
X = Q_interpolator2([8.4,8.6],-14.3,5.6)
im=Image.fromarray(X)
im
30/49:
X = Q_interpolator2([8.4,8.6],-8.3,5.6)
im=Image.fromarray(X)
im
30/50:
k = scale_by_z(0.5,X)
Image.fromarray(k)
30/51:
k = scale_by_z(0.75,X)
Image.fromarray(k)
30/52:
X = Q_interpolator2([8.4,8.6],3,3)
im=Image.fromarray(X)
im
30/53:
X = Q_interpolator2([8.4,8.6],-1,1)
im=Image.fromarray(X)
im
30/54:
X = Q_interpolator2([8.4,8.6],-2,2)
im=Image.fromarray(X)
im
30/55:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Left = [[x1y1[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Right = [[x4y4[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Outer = Up+Down+Left+Right
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Temp.append([i,j])
        Inner = Inner + Temp
    return Inner,Outer
30/56:
def Get_distence(A,center):
    A = np.array(A)
    return (np.sum((A-center)**2,axis=1))**0.5
30/57:
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = (norm.pdf(Out_d,scale=2))*Out_
    Weight_inner = norm.pdf(In_d,scale=2)
    ALL_weight = np.hstack((Weight_Out,Weight_inner))
    return normalize(ALL_weight)
30/58:
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = (norm.pdf(Out_d,scale=2))*Out_
    Weight_inner = norm.pdf(In_d,scale=2)
    ALL_weight = np.hstack((Weight_Out,Weight_inner))
    return ALL_weight
30/59: I = get_aperture_image(8.4,8.6,2)
30/60:
def aperture_size(coord,r):
    Max = np.array(coord)+r
    Min = np.array(coord)-r
    return print(Max)
30/61: I = get_aperture_image(8.4,8.6,2)
30/62:
def get_aperture_image(x,y,size):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size)
    ALL_set = A+B
    P = [get_photo(i[0],i[1]) for i in ALL_set]
    return Blend_by_weight(P,Weight)
30/63: I = get_aperture_image(8.4,8.6,2)
30/64: show_img(I)
30/65:
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = (norm.pdf(Out_d,scale=2))*Out_
    Weight_inner = norm.pdf(In_d,scale=2)
    ALL_weight = np.hstack((Weight_Out,Weight_inner))
    return ALL_weight*(1.0/(len(ALL_weight)))
30/66:
def get_aperture_image(x,y,size):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size)
    ALL_set = A+B
    P = [get_photo(i[0],i[1]) for i in ALL_set]
    return Blend_by_weight(P,Weight)
30/67: I = get_aperture_image(8.4,8.6,2)
30/68: show_img(I)
30/69:
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = (norm.pdf(Out_d,scale=2))*Out_
    Weight_inner = norm.pdf(In_d,scale=2)
    ALL_weight = np.hstack((Weight_Out,Weight_inner))
    print(ALL_weight*(1.0/(len(ALL_weight))))
    return ALL_weight*(1.0/(len(ALL_weight)))
30/70:
def get_aperture_image(x,y,size):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size)
    ALL_set = A+B
    P = [get_photo(i[0],i[1]) for i in ALL_set]
    return Blend_by_weight(P,Weight)
30/71: I = get_aperture_image(8.4,8.6,2)
30/72:
x = 8.4
y = 8.6
size = 2.5
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
Weight = make_weight(Inner_distence,Outer_distence,size)
ALL_set = A+B
P = [get_photo(i[0],i[1]) for i in ALL_set]
30/73:
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = (norm.pdf(Out_d,scale=2))*Out_
    Weight_inner = norm.pdf(In_d,scale=2)
    ALL_weight = np.hstack((Weight_Out,Weight_inner))
    return ALL_weight/4
30/74:
x = 8.4
y = 8.6
size = 2.5
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
Weight = make_weight(Inner_distence,Outer_distence,size)
ALL_set = A+B
P = [get_photo(i[0],i[1]) for i in ALL_set]
30/75:
I = Blend_by_weight(P,Weight)
how_img(I)
30/76:
x = 8.4
y = 8.6
size = 2.5
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
Weight = make_weight(Inner_distence,Outer_distence,size)
ALL_set = A+B
P = [get_photo(i[0],i[1]) for i in ALL_set]
30/77:
I = Blend_by_weight(P,Weight)
show_img(I)
30/78:
x = 8.4
y = 8.6
size = 2.5
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
30/79:
#A keep 1
#B keep r/d
Out_= size/Out_d
30/80:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
30/81: Outer_distence
30/82: Out_
30/83:
x = 8.1
y = 8.1
size = 1
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
30/84:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
30/85: Out_
30/86: Inner_distence
30/87: Inner_ = Inner_/Inner_distence
30/88: Inner_ = Inner_distence/Inner_distence
30/89: Inner_distence
30/90: Inner_
30/91:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
30/92: Out_.shape
30/93: ALL_weight = np.hstack((Out_,Inner_))
30/94: ALL_weight
30/95: normalize(ALL_weight)
30/96:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
ALL_weight = normalize(np.hstack((Out_,Inner_)))
30/97:
#get weight
def make_weight(In_d,Out_d,r):
    #A keep 1
    #B keep r/d
    Out_= size/Outer_distence
    Inner_ = Inner_distence/Inner_distence
    ALL_weight = normalize(np.hstack((Out_,Inner_)))
    return ALL_weight
30/98:
def get_aperture_image(x,y,size):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size)
    ALL_set = A+B
    P = [get_photo(i[0],i[1]) for i in ALL_set]
    return Blend_by_weight(P,Weight)
30/99:
I = Blend_by_weight(P,Weight)
show_img(I)
30/100:
I = get_aperture_image(8.4,8.6,2.5)
show_img(I)
30/101:
ALL_set = A+B
P = [get_photo(i[0],i[1]) for i in ALL_set]
30/102: len(P)
30/103: ALL_weight.shape
30/104: ALL_weight.shape[0]
30/105: ALL_weight.shape[1]
30/106: ALL_weight.shape[0]
30/107: ALL_weight.shape[1]
30/108: ALL_weight.shape[0][1]
30/109: ALL_weight
30/110: ALL_weight[0]
30/111: ALL_weight[1]
30/112: ALL_weight[2]
30/113: ALL_weight[3]
30/114: ALL_weight[4]
30/115: ALL_weight[5]
30/116: ALL_weight[6]
30/117: ALL_weight[7]
30/118: ALL_weight[8]
30/119: ALL_weight[9]
30/120:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
ALL_weight = normalize(np.hstack((Inner_,Out_)))
30/121:
ALL_set = A+B
P = [get_photo(i[0],i[1]) for i in ALL_set]
30/122: Blend_by_weight(P,ALL_weight)
30/123: C = Blend_by_weight(P,ALL_weight)
30/124: show_img(C)
30/125:
X = Q_interpolator2([8.4,8.6],-8.3,5.6)
im=Image.fromarray(X)
im
30/126:
Bias_all = get_bias([8.4,8.6],ALL_set,-8.3,5.6)
Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
30/127: C = Blend_by_weight(Re_images,ALL_weight)
30/128: Re_images[0].shape
30/129: R = [img_2_matrix(pp) for pp in Re_images]
30/130: C = Blend_by_weight(Re_images,ALL_weight)
30/131: C = Blend_by_weight(R,ALL_weight)
30/132: C
30/133: show_img(C)
30/134: Image.fromarray(C)
30/135:
x = 8.4
y = 8.6
size = 5
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
30/136:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
ALL_weight = normalize(np.hstack((Inner_,Out_)))
30/137:
ALL_set = A+B
P = [get_photo(i[0],i[1]) for i in ALL_set]
30/138:
Bias_all = get_bias([8.4,8.6],ALL_set,-8.3,5.6)
Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
30/139:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,ALL_weight)
30/140: Image.fromarray(C)
30/141:
x = 8.4
y = 8.6
size = 2.5
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
30/142: norm.pdf(In_d,scale=2)
30/143: norm.pdf(0)
30/144: norm.pdf(0)
30/145: norm.pdf(1)
30/146: norm.pdf(0)
30/147: norm.pdf(0,scale =1)
30/148: norm.pdf(0,scale=2)
30/149: norm.pdf(0,scale=size/2)
30/150:
x = 8.4
y = 8.6
size = 2.5
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
30/151:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
ALL_weight = normalize(np.hstack((Inner_,Out_)))
30/152:
ALL_set = A+B
P = [get_photo(i[0],i[1]) for i in ALL_set]
30/153: a = norm.pdf(Inner_distence,scale=size/2)*2
30/154: a
30/155: Inner_distence
30/156:
x = 8.4
y = 8.6
size = 2.5
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
30/157: A
30/158: Outer_distence
30/159:
x = 8.4
y = 8.6
size = 2
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
30/160: Inner_distence
30/161: Outer_distence
30/162:
x = 8.4
y = 8.6
size = 1
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
30/163:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
ALL_weight = normalize(np.hstack((Inner_,Out_)))
30/164:
ALL_set = A+B
P = [get_photo(i[0],i[1]) for i in ALL_set]
30/165:
Bias_all = get_bias([8.4,8.6],ALL_set,-8.3,5.6)
Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
30/166:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,ALL_weight)
30/167: Image.fromarray(C)
30/168: Inner_distence
30/169: a = norm.pdf(Inner_distence,scale=size/2)*2
30/170: a
30/171:
def filtter(distence):
    return norm.pdf(distence,scale=size/2)*2
30/172:
x = 8.4
y = 8.6
size = 1
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
F1 = filtter(Inn)
30/173:
F1 = filtter(Inner_distence)
F2 = filtter(Outer_distence)
30/174:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
ALL_weight = normalize(np.hstack((Inner_*F1,Out_*F2)))
30/175:
ALL_set = A+B
P = [get_photo(i[0],i[1]) for i in ALL_set]
30/176:
Bias_all = get_bias([8.4,8.6],ALL_set,-8.3,5.6)
Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
30/177:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,ALL_weight)
30/178: Image.fromarray(C)
30/179:
def filtter(distence):
    return norm.pdf(distence,scale=size/4)*2
30/180:
F1 = filtter(Inner_distence)
F2 = filtter(Outer_distence)
30/181:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,ALL_weight)
30/182: Image.fromarray(C)
30/183:
x = 8.4
y = 8.6
size = 2
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
30/184:
F1 = filtter(Inner_distence)
F2 = filtter(Outer_distence)
30/185:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
ALL_weight = normalize(np.hstack((Inner_*F1,Out_*F2)))
30/186:
ALL_set = A+B
P = [get_photo(i[0],i[1]) for i in ALL_set]
30/187:
Bias_all = get_bias([8.4,8.6],ALL_set,-8.3,5.6)
Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
30/188:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,ALL_weight)
30/189: Image.fromarray(C)
30/190: F1
30/191: F1
30/192:
def filtter(distence):
    return norm.pdf(distence,scale=size/2)*2
30/193:
F1 = filtter(Inner_distence)
F2 = filtter(Outer_distence)
30/194: F1
30/195: Out_= size/Outer_distence
30/196: Out_
30/197: Out_*F2
30/198: sum(Out_*F2)
30/199:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
ALL_weight = normalize(np.hstack((Inner_,Out_)))*(np.hstack(F1,F2))
30/200: ALL_weight
30/201: ALL_weight[0]
30/202: sum(ALL_weight)
30/203: X_weight = np.hstack((Inner_,Out_)
30/204: X_weight = np.hstack(Inner_,Out_)
30/205:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Out_,scale=size/2)
Weight_inner = norm.pdf(In_,scale=size/2)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
30/206:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Out_,scale=size/2)
Weight_inner = norm.pdf(Inner_,scale=size/2)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
30/207: sum(ALL_weight)
30/208:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size/2)
Weight_inner = norm.pdf(Inner_distence,scale=size/2)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
30/209: Weight_Out
30/210: Weight_inner
30/211:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size/2)*2
Weight_inner = norm.pdf(Inner_distence,scale=size/2)*2
ALL_weight = np.hstack((Weight_Out,Weight_inner))
30/212: Weight_Out
30/213: Weight_inner
30/214: sum(Weight_inner)
30/215: sum(Weight_Out)
30/216:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size/2)*2
Weight_inner = norm.pdf(Inner_distence,scale=size/2)*2
ALL_weight = np.hstack((Weight_Out,Weight_inner))
30/217: sum(Weight_Out)
30/218: sum(Weight_inner)
30/219: Weight_inner.shape
30/220: SS = np.hstack((Inner_*Weight_Out,Out_*Weight_inner))
30/221: SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
30/222: sum(SS)
30/223: S= normalize(S)
30/224: S= normalize(SS)
30/225: SS
30/226: SS[0]
30/227: SS[1]
30/228: ALL_set[1]
30/229:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,S)
30/230: Image.fromarray(C)
30/231:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,ALL_weight)
30/232: Image.fromarray(C)
30/233:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,SS)
30/234: Image.fromarray(C)
30/235:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,SS)
30/236: Image.fromarray(C)
30/237: S= normalize(SS)
30/238:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,SS)
30/239: Image.fromarray(C)
30/240: Image.fromarray(C)
30/241:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,ALL_weight)
30/242: Image.fromarray(C)
30/243: Image.fromarray(C)
30/244:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,S)
30/245: Image.fromarray(C)
30/246:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size/2)
Weight_inner = norm.pdf(Inner_distence,scale=size/2)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
30/247: SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
30/248: S= normalize(SS)
30/249: SS[1]
30/250: S[1]
30/251:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,S)
30/252: Image.fromarray(C)
30/253: Image.fromarray(I)
30/254: Image.fromarray(X)
30/255:
X = Q_interpolator2([8.4,8.6],2,2)
im=Image.fromarray(X)
im
30/256:
X = Q_interpolator2([8.4,8.6],-3,2)
im=Image.fromarray(X)
im
30/257:
X = Q_interpolator2([8.4,8.6],-8,2)
im=Image.fromarray(X)
im
30/258:
X = Q_interpolator2([8.4,8.6],-8,5)
im=Image.fromarray(X)
im
30/259:
X = Q_interpolator2([8.4,8.6],-8,7)
im=Image.fromarray(X)
im
30/260:
X = Q_interpolator2([8.4,8.6],-9,9)
im=Image.fromarray(X)
im
30/261:
X = Q_interpolator2([8.4,8.6],-12,12)
im=Image.fromarray(X)
im
30/262:
X = Q_interpolator2([8.4,8.6],-10,10)
im=Image.fromarray(X)
im
30/263:
X = Q_interpolator2([8.4,8.6],-9,9)
im=Image.fromarray(X)
im
30/264:
X = Q_interpolator2([8.4,8.6],-3,9)
im=Image.fromarray(X)
im
30/265:
X = Q_interpolator2([8.4,8.6],-4,9)
im=Image.fromarray(X)
im
30/266:
X = Q_interpolator2([8.4,8.6],-5,6)
im=Image.fromarray(X)
im
31/1:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
31/2:
def normalize(v):
    norm=np.linalg.norm(v, ord=1)
    if norm==0:
        norm=np.finfo(v.dtype).eps
    return v/norm
def show_img(img):
    im=Image.fromarray(img) 
    im.show()
#get the photo [320*240] as a vector with the uv coord(x,y)
def get_photo(x,y):
    index = 255-x-16*y
    return Data[index]
#Input:photos like as(wh,3)*n,and the weight
#Output:photos*weight
def Blend_by_weight(P,w):
    Image = np.zeros((76800,3),dtype=np.uint8)
    for i in range(len(P)):
        Temp = (np.floor(P[i]*w[i])).astype(np.uint8)
        Image = Image + Temp
    return matrix_2_img(Image)
31/3:
#x(0,15),y(0,15)
def Q_interpolator(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo(x_,y_)
    p2 = get_photo(x_+1,y_)
    p3 = get_photo(x_,y_-1)
    p4 = get_photo(x_+1,y_-1)
    return Blend_by_weight([p1,p2,p3,p4],normalize(w))
31/4: I = Q_interpolator([8.4,8.6])
31/5: base = Image.fromarray(I)
31/6: base
31/7:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint16)
    for x in range(w):
        for y in range(h):
            Coord = np.array([x,y])+disparity
            if Coord[1]<0 :
                Coord[1] = 0
            if Coord[0]<0:
                Coord[0] = 0
            if Coord[1]>h-1 :
                Coord[1] = h-1
            if Coord[0]>w-1:
                Coord[0] = w-1
            White_image[y][x] = np.floor(Coord)
    return White_image
31/8:
def get_bias(center,point_set,x_bias,y_bias):
    #Based on the center get the bias of all arround points
    Bias_all = [] 
    for i in range(len(point_set)):
        Bias = (np.array(point_set[i])-center)*[x_bias,y_bias]
        Bias_all.append(Bias)
    return Bias_all
31/9:
def Q_interpolator2(coords,x_bias,y_bias):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
    Bias_all = get_bias(coords,Square,x_bias,y_bias)
    #The bais for 4 photo
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    P = [get_photo(Square[i][0],Square[i][1]) for i in range(len(Square))]
    #All bias matrix
    Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
    #All redo image
    Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
    #Blend redo image
    R = [img_2_matrix(pp) for pp in Re_images]
    return Blend_by_weight(R,normalize(w))
31/10:
def normalize(v):
    norm=np.linalg.norm(v, ord=1)
    if norm==0:
        norm=np.finfo(v.dtype).eps
    return v/norm
31/11:
X = Q_interpolator2([8.4,8.6],-8.3,5.6)
im=Image.fromarray(X)
im
31/12:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for x in range(w):
        for y in range(h):
            u,v = Bias_map[y][x]
            White_image[y][x] = Image[v][u]
    return White_image
31/13:
X = Q_interpolator2([8.4,8.6],-8.3,5.6)
im=Image.fromarray(X)
im
31/14:
X = Q_interpolator2([8.4,8.6],-5,6)
im=Image.fromarray(X)
im
31/15:
Y = Q_interpolator([8.4,8.6])
im=Image.fromarray(Y)
im
31/16:
def aperture_size(coord,r):
    Max = np.array(coord)+r
    Min = np.array(coord)-r
    return print(Max)
31/17:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    y = (H*Range).astype(int) 
    x = (W*Range).astype(int) 
    image = image[y[0]:y[1],x[0]:x[1]]
    I = Image.fromarray(image).resize((320,240))
    return np.array(I)
31/18:
k = scale_by_z(0.5,X)
Image.fromarray(k)
31/19:
k = scale_by_z(0.75,X)
Image.fromarray(k)
31/20:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Left = [[x1y1[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Right = [[x4y4[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Outer = Up+Down+Left+Right
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Temp.append([i,j])
        Inner = Inner + Temp
    return Inner,Outer
31/21:
def Get_distence(A,center):
    A = np.array(A)
    return (np.sum((A-center)**2,axis=1))**0.5
31/22:
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = (norm.pdf(Out_d,scale=2))*Out_
    Weight_inner = norm.pdf(In_d,scale=2)
    ALL_weight = np.hstack((Weight_Out,Weight_inner))
    return ALL_weight
31/23:
def get_aperture_image(x,y,size):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size)
    ALL_set = A+B
    P = [get_photo(i[0],i[1]) for i in ALL_set]
    return Blend_by_weight(P,Weight)
31/24:
x = 8.4
y = 8.6
size = 2
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
31/25:
F1 = filtter(Inner_distence)
F2 = filtter(Outer_distence)
31/26:
def filtter(distence):
    return norm.pdf(distence,scale=size/2)*2
31/27:
x = 8.4
y = 8.6
size = 4
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
31/28:
F1 = filtter(Inner_distence)
F2 = filtter(Outer_distence)
31/29:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size/2)
Weight_inner = norm.pdf(Inner_distence,scale=size/2)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
31/30: SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
31/31: S= normalize(SS)
31/32:
ALL_set = A+B
P = [get_photo(i[0],i[1]) for i in ALL_set]
31/33: ALL_set.shape
31/34: len(ALL_set)
31/35:
Bias_all = get_bias([8.4,8.6],ALL_set,-8.3,5.6)
Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
31/36:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,S)
31/37: Image.fromarray(C)
31/38: import matplotlib.pyplot as plt
31/39: plt.plot(norm.pdf)
31/40: l = [i*0.01 for i in range(200)]
31/41: plt.plot(norm.pdf(l))
31/42: plt.plot(norm.pdf(l,size/4))
31/43: plt.plot(norm.pdf(l,scale = size/4))
31/44: plt.plot(norm.pdf(l,scale = 1))
31/45: plt.plot(norm.pdf(l,scale = 0.5))
31/46:
def filtter(distence):
    return norm.pdf(distence,scale=0.5)
31/47:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size/2)
Weight_inner = norm.pdf(Inner_distence,scale=size/2)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
31/48: SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
31/49: S= normalize(SS)
31/50:
x = 8.4
y = 8.6
size = 4
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
31/51:
F1 = filtter(Inner_distence)
F2 = filtter(Outer_distence)
31/52:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size/2)
Weight_inner = norm.pdf(Inner_distence,scale=size/2)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
31/53: SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
31/54: S= normalize(SS)
31/55:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,S)
31/56: Image.fromarray(C)
31/57:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,S*1.2)
31/58: Image.fromarray(C)
31/59:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,S*1.1)
31/60: Image.fromarray(C)
31/61:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,S*1.12)
31/62: Image.fromarray(C)
31/63: plt.plot(norm.pdf(l,scale = 2))
31/64:
def filtter(distence):
    return norm.pdf(distence,scale=0.2)
31/65:
x = 8.4
y = 8.6
size = 4
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
31/66:
F1 = filtter(Inner_distence)
F2 = filtter(Outer_distence)
31/67:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size/2)
Weight_inner = norm.pdf(Inner_distence,scale=size/2)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
31/68: SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
31/69:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,S*1.12)
31/70: Image.fromarray(C)
31/71: S= normalize(SS)
31/72:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,S*1.12)
31/73: Image.fromarray(C)
31/74: plt.plot(S)
31/75: plt.scatter(S)
31/76: plt.scatter([i for i in range(len(S))],S)
31/77:
def filtter(distence):
    return norm.pdf(distence,scale=2)
31/78:
F1 = filtter(Inner_distence)
F2 = filtter(Outer_distence)
31/79:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size/2)
Weight_inner = norm.pdf(Inner_distence,scale=size/2)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
31/80: SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
31/81: S= normalize(SS)
31/82: plt.scatter([i for i in range(len(S))],S)
31/83:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,S*1.2)
31/84: Image.fromarray(C)
31/85:
R = [img_2_matrix(pp) for pp in Re_images]
C = Blend_by_weight(R,S)
31/86: Image.fromarray(C)
31/87: Image.fromarray(Y)
31/88:
x = 8.4
y = 8.6
size = 6
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
31/89:
F1 = filtter(Inner_distence)
F2 = filtter(Outer_distence)
31/90:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size/2)
Weight_inner = norm.pdf(Inner_distence,scale=size/2)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
31/91: SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
31/92: S= normalize(SS)
31/93:
ALL_set = A+B
P = [get_photo(i[0],i[1]) for i in ALL_set]
31/94:
Bias_all = get_bias([8.4,8.6],ALL_set,-8.3,5.6)
Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
31/95:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R,S)
31/96: Image.fromarray(C2)
31/97:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R,S*1.5)
31/98: Image.fromarray(C2)
31/99:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R,S*2)
31/100: Image.fromarray(C2)
31/101:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R,S*1.6)
31/102: Image.fromarray(C2)
31/103:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R,S*1.5)
31/104: Image.fromarray(C2)
31/105: C3 = Blend_by_weight(P,S)
31/106:
C3 = Blend_by_weight(P,S)
Image.fromarray(C3)
31/107:
C3 = Blend_by_weight(P,S*1.5)
Image.fromarray(C3)
31/108:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R,S*1.55)
31/109: Image.fromarray(C2)
31/110:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R,S*1.57)
31/111: Image.fromarray(C2)
31/112:
Bias_all = get_bias([8.4,8.6],ALL_set,-8.3,5.6)
Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
31/113:
Bias_all = get_bias([8.4,8.6],A,-8.3,5.6)
Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
31/114:
R3 = [img_2_matrix(pp) for pp in Re_images]
S= normalize(Inner_*Weight_inner)
C3 = Blend_by_weight(R,S*1.57)
31/115:
R3 = [img_2_matrix(pp) for pp in Re_images]
S= normalize(Inner_*Weight_inner)
C3 = Blend_by_weight(R,S*1.8)
31/116: Image.fromarray(C3)
31/117:
R3 = [img_2_matrix(pp) for pp in Re_images]
S= normalize(Inner_*Weight_inner)
C3 = Blend_by_weight(R,S*1.7)
31/118: Image.fromarray(C3)
31/119:
R3 = [img_2_matrix(pp) for pp in Re_images]
S= normalize(Inner_*Weight_inner)
C3 = Blend_by_weight(R,S*1.65)
31/120: Image.fromarray(C3)
31/121:
R3 = [img_2_matrix(pp) for pp in Re_images]
S= normalize(Inner_*Weight_inner)
C3 = Blend_by_weight(R,S*1.3)
31/122: Image.fromarray(C3)
31/123:
R3 = [img_2_matrix(pp) for pp in Re_images]
S= normalize(Inner_*Weight_inner)
C3 = Blend_by_weight(R,S*1.4)
31/124: Image.fromarray(C3)
31/125: Image.fromarray(C3)
31/126:
R3 = [img_2_matrix(pp) for pp in Re_images]
S= normalize(Inner_*Weight_inner)
C3 = Blend_by_weight(R,S*1.5)
31/127: Image.fromarray(C3)
31/128:
R3 = [img_2_matrix(pp) for pp in Re_images]
S= normalize(Inner_*Weight_inner)
C3 = Blend_by_weight(R,S*1.62)
31/129: Image.fromarray(C3)
31/130:
R3 = [img_2_matrix(pp) for pp in Re_images]
S= normalize(Inner_*Weight_inner)
C3 = Blend_by_weight(R,S*1.60)
31/131: Image.fromarray(C3)
31/132:
R3 = [img_2_matrix(pp) for pp in Re_images]
S= normalize(Inner_*Weight_inner)
C3 = Blend_by_weight(R,S*1.5)
31/133: Image.fromarray(C3)
31/134:
Bias_all = get_bias([8.4,8.6],A,-8.3,7.6)
Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
R3 = [img_2_matrix(pp) for pp in Re_images]
S= normalize(Inner_*Weight_inner)
C3 = Blend_by_weight(R,S*1.5)
Image.fromarray(C3)
32/1:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
32/2:
Data_cut = []
for i in range(len(Data)):
    if i%2 != 0:
        Data_cut.append(Data[i])
32/3: len(Data_cut)
32/4:
def normalize(v):
    norm=np.linalg.norm(v, ord=1)
    if norm==0:
        norm=np.finfo(v.dtype).eps
    return v/norm
def show_img(img):
    im=Image.fromarray(img) 
    im.show()
#get the photo [320*240] as a vector with the uv coord(x,y)
def get_photo(x,y):
    index = 255-x-16*y
    return Data[index]
#Input:photos like as(wh,3)*n,and the weight
#Output:photos*weight
def Blend_by_weight(P,w):
    Image = np.zeros((76800,3),dtype=np.uint8)
    for i in range(len(P)):
        Temp = (np.floor(P[i]*w[i])).astype(np.uint8)
        Image = Image + Temp
    return matrix_2_img(Image)
32/5:
#x(0,15),y(0,15)
def Q_interpolator(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo(x_,y_)
    p2 = get_photo(x_+1,y_)
    p3 = get_photo(x_,y_-1)
    p4 = get_photo(x_+1,y_-1)
    return Blend_by_weight([p1,p2,p3,p4],normalize(w))
32/6:
def get_photo_cut(x,y):
    index = 128-x-8*y
    return Data[index]
32/7:
#x(0,15),y(0,15)
def Q_interpolator_cut(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo_cut(x_,y_)
    p2 = get_photo_cut(x_+1,y_)
    p3 = get_photo_cut(x_,y_-1)
    p4 = get_photo_cut(x_+1,y_-1)
    return Blend_by_weight([p1,p2,p3,p4],normalize(w))
32/8: cut = Q_interpolator_cut([4.25,4.25])
32/9: Image.fromarray(cut)
32/10: cut = Q_interpolator_cut([4.25,4.3])
32/11: Image.fromarray(cut)
32/12: cut = Q_interpolator_cut([4,4])
32/13: Image.fromarray(cut)
32/14:
def get_photo_cut(x,y):
    index = 128-x-8*y
    return Data_cut[index]
32/15:
#x(0,15),y(0,15)
def Q_interpolator_cut(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo_cut(x_,y_)
    p2 = get_photo_cut(x_+1,y_)
    p3 = get_photo_cut(x_,y_-1)
    p4 = get_photo_cut(x_+1,y_-1)
    return Blend_by_weight([p1,p2,p3,p4],normalize(w))
32/16: cut = Q_interpolator_cut([4,4])
32/17: Image.fromarray(cut)
32/18: cut = Q_interpolator_cut([4.25,4.3])
32/19: Image.fromarray(cut)
32/20: cut = Q_interpolator_cut([8,8])
32/21: Image.fromarray(cut)
32/22:
Data_cut = []
for i in range(len(Data)):
    if i%4 != 0:
        Data_cut.append(Data[i])
32/23: len(Data_cut)
32/24:
Data_cut = []
for i in range(len(Data)):
    if i%4 = 0:
        Data_cut.append(Data[i])
32/25:
Data_cut = []
for i in range(len(Data)):
    if i%4 == 0:
        Data_cut.append(Data[i])
32/26: len(Data_cut)
32/27:
def get_photo_cut(x,y):
    index = 128-x-8*y
    return Data_cut[index]
32/28:
#x(0,15),y(0,15)
def Q_interpolator_cut(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo_cut(x_,y_)
    p2 = get_photo_cut(x_+1,y_)
    p3 = get_photo_cut(x_,y_-1)
    p4 = get_photo_cut(x_+1,y_-1)
    return Blend_by_weight([p1,p2,p3,p4],normalize(w))
32/29: cut = Q_interpolator_cut([8,8])
32/30: cut = Q_interpolator_cut([4.25,4.3])
32/31:
def get_photo_cut(x,y):
    index = 64-x-8*y
    return Data_cut[index]
32/32: cut = Q_interpolator_cut([4.25,4.3])
32/33: Image.fromarray(cut)
32/34: cut = Q_interpolator_cut([4,4])
32/35: Image.fromarray(cut)
32/36: cut = Q_interpolator_cut([5,4])
32/37: Image.fromarray(cut)
32/38: cut = Q_interpolator_cut([4.5,4])
32/39: Image.fromarray(cut)
32/40: cut = Q_interpolator_cut([4.5,4.5])
32/41: Image.fromarray(cut)
32/42:
X = Q_interpolator2([8.4,8.6],2,6)
im=Image.fromarray(X)
im
32/43:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint16)
    for x in range(w):
        for y in range(h):
            Coord = np.array([x,y])+disparity
            if Coord[1]<0 :
                Coord[1] = 0
            if Coord[0]<0:
                Coord[0] = 0
            if Coord[1]>h-1 :
                Coord[1] = h-1
            if Coord[0]>w-1:
                Coord[0] = w-1
            White_image[y][x] = np.floor(Coord)
    return White_image
32/44:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for x in range(w):
        for y in range(h):
            u,v = Bias_map[y][x]
            White_image[y][x] = Image[v][u]
    return White_image
32/45:
def get_bias(center,point_set,x_bias,y_bias):
    #Based on the center get the bias of all arround points
    Bias_all = [] 
    for i in range(len(point_set)):
        Bias = (np.array(point_set[i])-center)*[x_bias,y_bias]
        Bias_all.append(Bias)
    return Bias_all
32/46:
def Q_interpolator2(coords,x_bias,y_bias):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
    Bias_all = get_bias(coords,Square,x_bias,y_bias)
    #The bais for 4 photo
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    P = [get_photo(Square[i][0],Square[i][1]) for i in range(len(Square))]
    #All bias matrix
    Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
    #All redo image
    Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
    #Blend redo image
    R = [img_2_matrix(pp) for pp in Re_images]
    return Blend_by_weight(R,normalize(w))
32/47:
def normalize(v):
    norm=np.linalg.norm(v, ord=1)
    if norm==0:
        norm=np.finfo(v.dtype).eps
    return v/norm
32/48:
X = Q_interpolator2([8.4,8.6],2,6)
im=Image.fromarray(X)
im
32/49:
X = Q_interpolator2([8.4,8.6],2,-4)
im=Image.fromarray(X)
im
32/50:
X = Q_interpolator2([8.4,8.6],2,10)
im=Image.fromarray(X)
im
32/51:
X = Q_interpolator2([8.4,8.6],2,8)
im=Image.fromarray(X)
im
32/52:
X = Q_interpolator2([8.4,8.6],2,7)
im=Image.fromarray(X)
im
32/53:
X = Q_interpolator2([8.4,8.6],2,3)
im=Image.fromarray(X)
im
32/54:
X = Q_interpolator2([8.4,8.6],2,-2)
im=Image.fromarray(X)
im
32/55:
X = Q_interpolator2([8.4,8.6],2,5)
im=Image.fromarray(X)
im
32/56:
X = Q_interpolator2([8.4,8.6],2,6)
im=Image.fromarray(X)
im
32/57:
X = Q_interpolator2([8.4,8.6],2,7)
im=Image.fromarray(X)
im
32/58:
X = Q_interpolator2([8.4,8.6],3,7)
im=Image.fromarray(X)
im
32/59:
X = Q_interpolator2([8.4,8.6],3,8)
im=Image.fromarray(X)
im
32/60:
X = Q_interpolator2([8.4,8.6],3,11)
im=Image.fromarray(X)
im
32/61:
X = Q_interpolator2([8.4,8.6],6,6)
im=Image.fromarray(X)
im
32/62:
X = Q_interpolator2([8.4,8.6],-3,6)
im=Image.fromarray(X)
im
32/63:
X = Q_interpolator2([8.4,8.6],-4,6)
im=Image.fromarray(X)
im
32/64:
X = Q_interpolator2([8.4,8.6],-4,7)
im=Image.fromarray(X)
im
32/65:
X = Q_interpolator2([8.4,8.6],-5,7)
im=Image.fromarray(X)
im
32/66:
X = Q_interpolator2([8.4,8.6],-3,6)
im=Image.fromarray(X)
im
32/67:
X = Q_interpolator2([8.4,8.6],-2,6)
im=Image.fromarray(X)
im
32/68:
X = Q_interpolator2([8.4,8.6],-3,6)
im=Image.fromarray(X)
im
32/69:
X = Q_interpolator2([8.4,8.6],-3。4,6)
im=Image.fromarray(X)
im
32/70:
X = Q_interpolator2([8.4,8.6],-3.4,6)
im=Image.fromarray(X)
im
32/71:
X = Q_interpolator2([8.4,8.6],-3.5,6)
im=Image.fromarray(X)
im
32/72:
X = Q_interpolator2([8.4,8.6],-3.5,7)
im=Image.fromarray(X)
im
32/73:
X = Q_interpolator2([8.4,8.6],-3.5,8)
im=Image.fromarray(X)
im
32/74:
X = Q_interpolator2([8.4,8.6],-3.5,7.2)
im=Image.fromarray(X)
im
32/75:
X = Q_interpolator2([8.4,8.6],-3.8,7.2)
im=Image.fromarray(X)
im
32/76:
X = Q_interpolator2([8.4,8.6],-3.3,7.3)
im=Image.fromarray(X)
im
32/77:
X = Q_interpolator2([8.4,8.6],-3.6,7.3)
im=Image.fromarray(X)
im
32/78:
X = Q_interpolator2([8.4,8.6],-3.6,6.5)
im=Image.fromarray(X)
im
32/79:
X = Q_interpolator2([8.4,8.6],-8.3,8.6)
im=Image.fromarray(X)
im
32/80:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Left = [[x1y1[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Right = [[x4y4[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Outer = Up+Down+Left+Right
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Temp.append([i,j])
        Inner = Inner + Temp
    return Inner,Outer
32/81:
def Get_distence(A,center):
    A = np.array(A)
    return (np.sum((A-center)**2,axis=1))**0.5
32/82:
#get weight
def make_weight(In_d,Out_d,r):
    #(D-r)/D
    Out_ = (Out_d-r)/Out_d
    Weight_Out = (norm.pdf(Out_d,scale=2))*Out_
    Weight_inner = norm.pdf(In_d,scale=2)
    ALL_weight = np.hstack((Weight_Out,Weight_inner))
    return ALL_weight
32/83:
def get_aperture_image(x,y,size):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size)
    ALL_set = A+B
    P = [get_photo(i[0],i[1]) for i in ALL_set]
    return Blend_by_weight(P,Weight)
32/84:
x = 8.4
y = 8.6
size = 6
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
32/85:
F1 = filtter(Inner_distence)
F2 = filtter(Outer_distence)
32/86:
def filtter(distence):
    return norm.pdf(distence,scale=2)
F1 = filtter(Inner_distence)
F2 = filtter(Outer_distence)
32/87:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size/2)
Weight_inner = norm.pdf(Inner_distence,scale=size/2)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
32/88: SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
32/89:
SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
S= normalize(SS)
32/90: S
32/91: len(S)
32/92:
x = 8.4
y = 8.6
size = 2
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
32/93:
def filtter(distence):
    return norm.pdf(distence,scale=2)
F1 = filtter(Inner_distence)
F2 = filtter(Outer_distence)
32/94:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size/2)
Weight_inner = norm.pdf(Inner_distence,scale=size/2)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
32/95: SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
32/96:
SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
S= normalize(SS)
32/97: len(S)
32/98:
ALL_set = A+B
P = [get_photo(i[0],i[1]) for i in ALL_set]
32/99:
Bias_all = get_bias([8.4,8.6],ALL_set,-8.3,8.6)
Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
32/100:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R,S*1.57)
32/101:
C2 = Blend_by_weight(R1,S*1.57)
Image.fromarray(C2)
32/102:
C2 = Blend_by_weight(R1,S)
Image.fromarray(C2)
32/103:
X = Q_interpolator2([8.4,8.6],-8.3,8.6)
im=Image.fromarray(X)
im
32/104:
C2 = Blend_by_weight(R1,S*0.9)
Image.fromarray(C2)
32/105:
C2 = Blend_by_weight(R1,S*0.8)
Image.fromarray(C2)
32/106:
C2 = Blend_by_weight(R1,S*0.7)
Image.fromarray(C2)
32/107:
C2 = Blend_by_weight(R1,S)
Image.fromarray(C2)
32/108: ALL_weight
32/109: S
32/110: sum(S)
32/111:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw(title,ALL_set,ALL_weight):
    data = np.zeros((6,6))
    for i in len(ALL_set):
        data[ALL_set[i][0]][ALL_set[i][1]]= ALL_weight[i]
    xLabel = ['0','1','2','3','4',"5"]
    yLabel = ['0','1','2','3','4',"5"]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    plt.colorbar(im)
    plt.title(title)
    #show
    plt.show()
32/112: draw("a",ALL_set,ALL_weight)
32/113:
data = np.zeros((6,6))
for i in len(ALL_set):
    data[ALL_set[i][0]][ALL_set[i][1]]= ALL_weight[i]
32/114:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw(title,ALL_set,ALL_weight):
    data = np.zeros((6,6))
    for i in range(len(ALL_set)):
        data[ALL_set[i][0]][ALL_set[i][1]]= ALL_weight[i]
    xLabel = ['0','1','2','3','4',"5"]
    yLabel = ['0','1','2','3','4',"5"]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    plt.colorbar(im)
    plt.title(title)
    #show
    plt.show()
32/115: draw("a",ALL_set,ALL_weight)
32/116: ALL_set[0]
32/117: ALL_set
32/118: ALL_set-[6,6]
32/119: np.array(ALL_set)-[6,6]
32/120: draw("a",np.array(ALL_set)-[6,6],ALL_weight)
32/121: np.array(ALL_set)-[8.3,8.6]
32/122: np.array(ALL_set)-[8,8]
32/123: S[5]
32/124: S[4]
32/125: S[5]
32/126: np.array(ALL_set)-[8,8]
32/127: np.array(ALL_set)-[8,8]
32/128: np.array(ALL_set)-[6,6]
32/129: np.array(ALL_set)-[5,5]
32/130: draw("a",np.array(ALL_set)-[5,5],ALL_weight)
32/131:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw(title,ALL_set,ALL_weight,h):
    data = np.zeros((6,6))
    for i in range(len(ALL_set)):
        data[ALL_set[i][0]][ALL_set[i][1]]= ALL_weight[i]
    xLabel = ['0','1','2','3','4',"5"]
    yLabel = ['0','1','2','3','4',"5"]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    plt.colorbar(im)
    plt.title(title)
    #show
    plt.show()
32/132:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw(title,ALL_set,ALL_weight,size):
    data = np.zeros((size,size))
    for i in range(len(ALL_set)):
        data[ALL_set[i][0]][ALL_set[i][1]]= ALL_weight[i]
    xLabel = ['0','1','2','3','4',"5"]
    yLabel = ['0','1','2','3','4',"5"]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    plt.colorbar(im)
    plt.title(title)
    #show
    plt.show()
32/133:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw(title,ALL_set,ALL_weight,size):
    data = np.zeros((size,size))
    for i in range(len(ALL_set)):
        data[ALL_set[i][0]][ALL_set[i][1]]= ALL_weight[i]
    xLabel = [str(i) for i in range(size)]
    yLabel = [str(i) for i in range(size)]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    plt.colorbar(im)
    plt.title(title)
    #show
    plt.show()
32/134: draw("a",np.array(ALL_set)-[5,5],ALL_weight,7)
32/135: plt.scatter(ALL_set)
32/136: plt.plot(ALL_set)
32/137: plt.scatter([i[0] for i in ALL_set],[i[1] for i in ALL_set])
32/138:
plt.scatter([i[0] for i in A],[i[1] for i in A])
plt.scatter([i[0] for i in B],[i[1] for i in B])
32/139:
plt.scatter([i[0] for i in A],[i[1] for i in A])
plt.scatter([i[0] for i in B],[i[1] for i in B])
plt.scatter(8.3,8.6)
32/140:
plt.scatter([i[0] for i in A],[i[1] for i in A])
plt.scatter([i[0] for i in B],[i[1] for i in B])
plt.scatter(8.3,8.6)
plt.Circle((8.3,8.6),size, color='g')
32/141:
plt.scatter([i[0] for i in A],[i[1] for i in A])
plt.scatter([i[0] for i in B],[i[1] for i in B])
plt.scatter(8.3,8.6)
plt.Circle((8.3,8.6),size, color='g')
32/142:
plt.scatter([i[0] for i in A],[i[1] for i in A])
plt.scatter([i[0] for i in B],[i[1] for i in B])
plt.scatter(8.3,8.6)
plt.Circle((8.3,8.6),size, color='g',fill=False)
32/143:
plt.scatter([i[0] for i in A],[i[1] for i in A])
plt.scatter([i[0] for i in B],[i[1] for i in B])
plt.scatter(8.3,8.6)
plt.Circle((8.3,8.6),size, color='g',fill=True)
32/144:
plt.scatter([i[0] for i in A],[i[1] for i in A])
plt.scatter([i[0] for i in B],[i[1] for i in B])
plt.Circle((8.3,8.6),size, color='g',fill=True)
32/145:
plt.scatter([i[0] for i in A],[i[1] for i in A])
plt.scatter([i[0] for i in B],[i[1] for i in B])
plt.scatter(8.3,8.6)
32/146: ALL_weight
32/147: SS[0]
32/148: draw("a",np.array(ALL_set)-[5,5],SS,7)
32/149: draw("",np.array(ALL_set)-[6,6],SS,7)
32/150: draw("",np.array(ALL_set)-[7,7],SS,7)
32/151: draw("",np.array(ALL_set)-[6,6],SS,7)
32/152: draw("",np.array(ALL_set)-[6,7],SS,7)
32/153: draw("",np.array(ALL_set)-[6,6],SS,7)
32/154: draw("",np.array(ALL_set)-[6,5],SS,7)
32/155: draw("",np.array(ALL_set)-[5,6],SS,7)
32/156: draw("",np.array(ALL_set)-[6,6],SS,7)
32/157:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw(title,ALL_set,ALL_weight,size,loc):
    data = np.zeros((size,size))
    for i in range(len(ALL_set)):
        data[ALL_set[i][0]][ALL_set[i][1]]= ALL_weight[i]
    xLabel = [str(i) for i in range(size)]
    yLabel = [str(i) for i in range(size)]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    plt.colorbar(im)
    plt.title(title)
    #show
    plt.show()
32/158:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw(title,ALL_set,ALL_weight,size,loc):
    data = np.zeros((size,size))
    for i in range(len(ALL_set)):
        data[ALL_set[i][0]][ALL_set[i][1]]= ALL_weight[i]
    xLabel = [str(i+loc) for i in range(size)]
    yLabel = [str(i+loc) for i in range(size)]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    plt.colorbar(im)
    plt.title(title)
    #show
    plt.show()
32/159: draw("",np.array(ALL_set)-[6,6],SS,7,loc=6)
32/160:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw(title,ALL_set,ALL_weight,size,loc):
    data = np.zeros((size,size))
    for i in range(len(ALL_set)):
        data[ALL_set[i][0]][ALL_set[i][1]]= ALL_weight[i]
    xLabel = [str(i+loc) for i in range(size)].reverse()
    yLabel = [str(i+loc) for i in range(size)]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    plt.colorbar(im)
    plt.title(title)
    #show
    plt.show()
32/161: draw("",np.array(ALL_set)-[6,6],SS,7,loc=6)
32/162:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw(title,ALL_set,ALL_weight,size,loc):
    data = np.zeros((size,size))
    for i in range(len(ALL_set)):
        data[ALL_set[i][0]][ALL_set[i][1]]= ALL_weight[i]
    xLabel = [str(size-i-loc) for i in range(size)]
    yLabel = [str(i+loc) for i in range(size)]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    plt.colorbar(im)
    plt.title(title)
    #show
    plt.show()
32/163: draw("",np.array(ALL_set)-[6,6],SS,7,loc=6)
32/164:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw(title,ALL_set,ALL_weight,size,loc):
    data = np.zeros((size,size))
    for i in range(len(ALL_set)):
        data[ALL_set[i][0]][ALL_set[i][1]]= ALL_weight[i]
    xLabel = [str(size-i+loc) for i in range(size)]
    yLabel = [str(i+loc) for i in range(size)]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    plt.colorbar(im)
    plt.title(title)
    #show
    plt.show()
32/165: draw("",np.array(ALL_set)-[6,6],SS,7,loc=6)
32/166: [1,2].reverse
32/167: [1,2].reverse()
32/168: [1,2].reverse()
32/169: a = [1,2].reverse()
32/170: a
32/171: reverse([1,2])
32/172:
a = [1,2]
a.reverse()
a
32/173:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw(title,ALL_set,ALL_weight,size,loc):
    data = np.zeros((size,size))
    for i in range(len(ALL_set)):
        data[ALL_set[i][0]][ALL_set[i][1]]= ALL_weight[i]
    xLabel = [str(i+loc) for i in range(size)]
    xLabel.reverse()
    yLabel = [str(i+loc) for i in range(size)]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    plt.colorbar(im)
    plt.title(title)
    #show
    plt.show()
32/174: draw("",np.array(ALL_set)-[6,6],SS,7,loc=6)
32/175:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw(title,ALL_set,ALL_weight,size,loc):
    data = np.zeros((size,size))
    for i in range(len(ALL_set)):
        data[ALL_set[i][0]][ALL_set[i][1]]= ALL_weight[i]
    xLabel = [str(i+loc+1) for i in range(size)]
    xLabel.reverse()
    yLabel = [str(i+loc) for i in range(size)]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    plt.colorbar(im)
    plt.title(title)
    #show
    plt.show()
32/176: draw("",np.array(ALL_set)-[6,6],SS,7,loc=6)
32/177:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw(title,ALL_set,ALL_weight,size,loc):
    data = np.zeros((size,size))
    for i in range(len(ALL_set)):
        data[ALL_set[i][0]][ALL_set[i][1]]= ALL_weight[i]
    xLabel = [str(i+loc-1) for i in range(size)]
    xLabel.reverse()
    yLabel = [str(i+loc) for i in range(size)]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    plt.colorbar(im)
    plt.title(title)
    #show
    plt.show()
32/178: draw("",np.array(ALL_set)-[6,6],SS,7,loc=6)
32/179:
plt.plot(norm.pdf(l,scale = 2))
plt.scatter([1,0.1])
32/180: l = [i*0.01 for i in range(200)]
32/181:
plt.plot(norm.pdf(l,scale = 2))
plt.scatter([1,0.1])
32/182:
plt.plot(norm.pdf(l,scale = 2))
plt.scatter(1,0.1)
32/183: plt.scatter(l,norm.pdf(l,scale = 2))
32/184:
plt.scatter(l,norm.pdf(l,scale = 2))
plt.scatter(Inner_distence,norm.pdf(Inner_distence,scale = 2))
32/185:
plt.plot(l,norm.pdf(l,scale = 2))
plt.scatter(Inner_distence,norm.pdf(Inner_distence,scale = 2))
32/186:
plt.plot(l,norm.pdf(l,scale = 2))
plt.scatter(Inner_distence,norm.pdf(Inner_distence,scale = 2))
plt.scatter(Outer_distence,norm.pdf(Outer_distence,scale = 2))
32/187:
plt.plot(l,norm.pdf(l,scale = 1))
plt.scatter(Inner_distence,norm.pdf(Inner_distence,scale = 1))
plt.scatter(Outer_distence,norm.pdf(Outer_distence,scale = 1))
32/188:
def scale_vis(s):
    l = [i*0.01 for i in range(200)]
    plt.plot(l,norm.pdf(l,scale = s))
    plt.scatter(Inner_distence,norm.pdf(Inner_distence,scale = s))
    plt.scatter(Outer_distence,norm.pdf(Outer_distence,scale = s))
32/189: scale_vis(1)
32/190:
X = Q_interpolator2([8.4,8.6],-8.3,7.6)
im=Image.fromarray(X)
im
32/191:
X = Q_interpolator2([8.4,8.6],-8.3,8.6)
im=Image.fromarray(X)
im
32/192:
import random
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import axes
from matplotlib.font_manager import FontProperties
 
def draw(title,ALL_set,ALL_weight,size,loc):
    data = np.zeros((size,size))
    for i in range(len(ALL_set)):
        data[ALL_set[i][0]][ALL_set[i][1]]= ALL_weight[i]
    xLabel = [str(i+loc-1) for i in range(size)]
    xLabel.reverse()
    yLabel = [str(i+loc) for i in range(size)]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_yticks(range(len(yLabel)))
    ax.set_yticklabels(yLabel)
    ax.set_xticks(range(len(xLabel)))
    ax.set_xticklabels(xLabel)
    im = ax.imshow(data, cmap=plt.cm.hot_r)
    plt.colorbar(im)
    plt.title(title)
    #show
    plt.show()
32/193: scale_vis(2)
32/194: Inner_
32/195: scale_vis(1)
32/196: scale_vis(2)
32/197:
def scale_vis(s):
    l = [i*0.01 for i in range(200)]
    plt.plot(l,norm.pdf(l,scale = s))
    plt.scatter(Inner_distence,norm.pdf(Inner_distence,scale = s))
    print(sum(norm.pdf(Inner_distence,scale = s)))
    plt.scatter(Outer_distence,norm.pdf(Outer_distence,scale = s))
    print(sum(norm.pdf(Outer_distence,scale = s)))
32/198: scale_vis(1)
32/199: scale_vis(2)
32/200:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size)
Weight_inner = norm.pdf(Inner_distence,scale=size)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
32/201:
x = 8.4
y = 8.6
size = 2
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
def filtter(distence):
    return norm.pdf(distence,scale=size)
F1 = filtter(Inner_distence)
F2 = filtter(Outer_distence)
32/202: SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
32/203:
SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
S= normalize(SS)
32/204: draw("",np.array(ALL_set)-[6,6],SS,7,loc=6)
32/205:
C2 = Blend_by_weight(R1,S)
Image.fromarray(C2)
32/206:
ALL_set = A+B
P = [get_photo(i[0],i[1]) for i in ALL_set]
32/207:
ALL_set = A+B
P = [get_photo(i[0],i[1]) for i in ALL_set]
32/208:
Bias_all = get_bias([8.4,8.6],ALL_set,-8.3,8.6)
Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
32/209: R1 = [img_2_matrix(pp) for pp in Re_images]
32/210:
C2 = Blend_by_weight(R1,S)
Image.fromarray(C2)
32/211: scale_vis(2)
32/212:
def scale_vis(s):
    l = [i*0.01 for i in range(200)]
    plt.plot(l,norm.pdf(l,scale = s))
    plt.scatter(Inner_distence,norm.pdf(Inner_distence,scale = s))
    plt.scatter(Outer_distence,norm.pdf(Outer_distence,scale = s))
    plt.scatter(Inner_distence,Inner_*Weight_inner)
    plt.scatter(Outer_distence,Out_*Weight_Out)
32/213: scale_vis(2)
32/214:
def scale_vis(s):
    l = [i*0.01 for i in range(200)]
    plt.plot(l,norm.pdf(l,scale = s))
    plt.scatter(Inner_distence,norm.pdf(Inner_distence,scale = s),"red")
    plt.scatter(Outer_distence,norm.pdf(Outer_distence,scale = s),"blue")
    plt.scatter(Inner_distence,Inner_*Weight_inner)
    plt.scatter(Outer_distence,Out_*Weight_Out)
32/215: scale_vis(2)
32/216:
def scale_vis(s):
    l = [i*0.01 for i in range(200)]
    plt.plot(l,norm.pdf(l,scale = s))
    plt.scatter(Inner_distence,norm.pdf(Inner_distence,scale = s),"red")
    plt.scatter(Outer_distence,norm.pdf(Outer_distence,scale = s),"blue")
    plt.scatter(Inner_distence,Inner_*Weight_inner)
32/217: scale_vis(2)
32/218:
def scale_vis(s):
    l = [i*0.01 for i in range(200)]
    plt.plot(l,norm.pdf(l,scale = s))
    plt.scatter(Inner_distence,norm.pdf(Inner_distence,scale = s))
    plt.scatter(Outer_distence,norm.pdf(Outer_distence,scale = s))
    plt.scatter(Inner_distence,Inner_*Weight_inner)
32/219: scale_vis(2)
32/220:
def scale_vis(s):
    l = [i*0.01 for i in range(200)]
    plt.plot(l,norm.pdf(l,scale = s))
    plt.scatter(Inner_distence,norm.pdf(Inner_distence,scale = s))
    plt.scatter(Outer_distence,norm.pdf(Outer_distence,scale = s))
    plt.scatter(Outer_distence,Out_*Weight_Out)
32/221: scale_vis(2)
32/222:
x = 8.4
y = 8.6
size = 4
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
def filtter(distence):
    return norm.pdf(distence,scale=size)
F1 = filtter(Inner_distence)
F2 = filtter(Outer_distence)
32/223:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size)
Weight_inner = norm.pdf(Inner_distence,scale=size)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
32/224: SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
32/225:
SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
S= normalize(SS)
32/226:
def scale_vis(s):
    l = [i*0.01 for i in range(200)]
    plt.plot(l,norm.pdf(l,scale = s))
    plt.scatter(Inner_distence,norm.pdf(Inner_distence,scale = s))
    plt.scatter(Outer_distence,norm.pdf(Outer_distence,scale = s))
    plt.scatter(Outer_distence,Out_*Weight_Out)
32/227: scale_vis(4)
32/228: len(SS)
32/229: draw("",np.array(ALL_set)-[6,6],SS,7,loc=6)
32/230: draw("",np.array(ALL_set)-[6,6],SS,10,loc=6)
32/231: draw("",np.array(ALL_set)-[6,6],SS,7,loc=6)
32/232: draw("",np.array(ALL_set)-[6,6],SS,11,loc=6)
32/233: draw("",np.array(ALL_set)-[8,8],SS,11,loc=6)
32/234: draw("",np.array(ALL_set)-[4,4],SS,11,loc=6)
32/235:
ALL_set = A+B
P = [get_photo(i[0],i[1]) for i in ALL_set]
32/236:
Bias_all = get_bias([8.4,8.6],ALL_set,-8.3,8.6)
Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
32/237: R1 = [img_2_matrix(pp) for pp in Re_images]
32/238:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
Image.fromarray(C2)
32/239:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S*1.2)
Image.fromarray(C2)
32/240:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S*1.1)
Image.fromarray(C2)
32/241:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
Image.fromarray(C2)
32/242:
x = 8.4
y = 8.6
size = 3
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
def filtter(distence):
    return norm.pdf(distence,scale=size)
F1 = filtter(Inner_distence)
F2 = filtter(Outer_distence)
32/243:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size)
Weight_inner = norm.pdf(Inner_distence,scale=size)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
32/244: SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
32/245:
SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
S= normalize(SS)
32/246: scale_vis(3)
32/247: len(SS)
32/248: len(SS)
32/249: norm.pdf(Inner_distence,scale = s)
32/250: norm.pdf(Inner_distence,scale = 4)
32/251: sum(norm.pdf(Inner_distence,scale = 4))
32/252:
x = 8.4
y = 8.6
size = 3
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
def filtter(distence):
    return norm.pdf(distence,scale=size)
F1 = filtter(Inner_distence)
F2 = filtter(Outer_distence)
32/253:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size)
Weight_inner = norm.pdf(Inner_distence,scale=size)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
32/254: SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
32/255:
SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
S= normalize(SS)
32/256:
ALL_set = A+B
P = [get_photo(i[0],i[1]) for i in ALL_set]
Bias_all = get_bias([8.4,8.6],ALL_set,-8.3,8.6)
Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
32/257:
R4 = [img_2_matrix(pp) for pp in Re_images]
C4 = Blend_by_weight(R4,S)
Image.fromarray(C4)
32/258: len(S)
32/259:
C4 = Blend_by_weight(R4,S*1.1)
Image.fromarray(C4)
32/260:
C4 = Blend_by_weight(R4,S)
Image.fromarray(C4)
32/261:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
Image.fromarray(C2)
32/262: len(C2)
32/263: len(S)
32/264:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
Image.fromarray(C2)
32/265:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S*1.1)
Image.fromarray(C2)
32/266:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S*1.2)
Image.fromarray(C2)
32/267:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S*1.1)
Image.fromarray(C2)
32/268:
x = 8.4
y = 8.6
size = 4
#Get the points
center = [x,y]
A,B = Get_arround_set([x,y],size)
Inner_distence = Get_distence(A,center)
Outer_distence = Get_distence(B,center)
def filtter(distence):
    return norm.pdf(distence,scale=size)
F1 = filtter(Inner_distence)
F2 = filtter(Outer_distence)
32/269:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size)
Weight_inner = norm.pdf(Inner_distence,scale=size)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
32/270: SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
32/271:
SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
S= normalize(SS)
32/272:
ALL_set = A+B
P = [get_photo(i[0],i[1]) for i in ALL_set]
32/273:
Bias_all = get_bias([8.4,8.6],ALL_set,-8.3,8.6)
Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
32/274:
R4 = [img_2_matrix(pp) for pp in Re_images]
C4 = Blend_by_weight(R4,S)
Image.fromarray(C4)
32/275:
R4 = [img_2_matrix(pp) for pp in Re_images]
C4 = Blend_by_weight(R4,S*1.1)
Image.fromarray(C4)
32/276:
R4 = [img_2_matrix(pp) for pp in Re_images]
C4 = Blend_by_weight(R4,S*1.2)
Image.fromarray(C4)
32/277: len(S)
32/278:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S*1.1)
Image.fromarray(C2)
32/279:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S*1.2)
Image.fromarray(C2)
32/280:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S*1.15)
Image.fromarray(C2)
32/281:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S*1.5)
Image.fromarray(C2)
32/282:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size*2)
Weight_inner = norm.pdf(Inner_distence,scale=size*2)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
32/283: SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
32/284:
SS = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
S= normalize(SS)
32/285:
def scale_vis(s):
    l = [i*0.01 for i in range(200)]
    plt.plot(l,norm.pdf(l,scale = s))
    plt.scatter(Inner_distence,norm.pdf(Inner_distence,scale = s*2))
    plt.scatter(Outer_distence,norm.pdf(Outer_distence,scale = s*2))
    plt.scatter(Outer_distence,Out_*Weight_Out)
32/286: scale_vis(4)
32/287:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S*1.5)
Image.fromarray(C2)
32/288:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
Image.fromarray(C2)
32/289:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size)
Weight_inner = norm.pdf(Inner_distence,scale=size)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
32/290:
SS1 = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
S1= normalize(SS1)
32/291: plt.plot(S1)
32/292:
plt.plot(S1)
plt.plot(S)
32/293:
plt.scatter(S1)
plt.scatter(S)
32/294: scale_vis(4)
32/295:
def scale_vis(s):
    l = [i*0.01 for i in range(200)]
    plt.plot(l,norm.pdf(l,scale = s*2))
32/296: scale_vis(4)
32/297:
def scale_vis(s):
    l = [i*0.01 for i in range(200)]
    plt.plot(l,norm.pdf(l,scale = s*2))
    plt.scatter(Inner_distence,norm.pdf(Inner_distence,scale = s*2))
32/298: scale_vis(4)
32/299:
def scale_vis(s):
    l = [i*0.01 for i in range(200)]
    plt.plot(l,norm.pdf(l,scale = s*2))
        plt.scatter(Inner_distence,norm.pdf(Inner_distence,scale = s*2))
    plt.scatter(Outer_distence,norm.pdf(Outer_distence,scale = s*2))
32/300:
def scale_vis(s):
    l = [i*0.01 for i in range(200)]
    plt.plot(l,norm.pdf(l,scale = s*2))
    plt.scatter(Inner_distence,norm.pdf(Inner_distence,scale = s*2))
    plt.scatter(Outer_distence,norm.pdf(Outer_distence,scale = s*2))
32/301: scale_vis(4)
32/302:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S1)
Image.fromarray(C2)
32/303:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
Image.fromarray(C2)
32/304:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S1)
Image.fromarray(C2)
32/305:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S2)
Image.fromarray(C2)
32/306:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S1)
Image.fromarray(C2)
32/307:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
Image.fromarray(C2)
32/308:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S1)
Image.fromarray(C2)
32/309:
plt.scatter(y=S1)
plt.scatter(y=S)
32/310:
plt.scatter([i for i in range(len(S1))],S1)
plt.scatter([i for i in range(len(S))],S)
32/311:
R4 = [img_2_matrix(pp) for pp in Re_images]
C4 = Blend_by_weight(R4,S)
Image.fromarray(C4)
32/312:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
C3 = Blend_by_weight(R1,S1)
Image.fromarray(C1-C2)
32/313:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
C3 = Blend_by_weight(R1,S1)
Image.fromarray(C3-C2)
32/314:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
C3 = Blend_by_weight(R1,S1)
Image.fromarray(C2-C3)
32/315:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
C3 = Blend_by_weight(R1,S1)
sum(C3-C2)
32/316:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
C3 = Blend_by_weight(R1,S1)
Image.fromarray(C2)
32/317:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
C3 = Blend_by_weight(R1,S1)
Image.fromarray(C3)
32/318:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size*0.3)
Weight_inner = norm.pdf(Inner_distence,scale=size*0.3)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
32/319:
SS2 = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
S2= normalize(SS2)
32/320:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
C3 = Blend_by_weight(R1,S1)
C4 = Blend_by_weight(R1,S2)
Image.fromarray(C4)
32/321:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size*0.1)
Weight_inner = norm.pdf(Inner_distence,scale=size*0.1)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
32/322:
SS2 = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
S2= normalize(SS2)
32/323:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
C3 = Blend_by_weight(R1,S1)
C4 = Blend_by_weight(R1,S2)
Image.fromarray(C4)
32/324:
#A keep 1
#B keep r/d
Out_= size/Outer_distence
Inner_ = Inner_distence/Inner_distence
Weight_Out = norm.pdf(Outer_distence,scale=size*3)
Weight_inner = norm.pdf(Inner_distence,scale=size*3)
ALL_weight = np.hstack((Weight_Out,Weight_inner))
32/325:
SS2 = np.hstack((Inner_*Weight_inner,Out_*Weight_Out))
S2= normalize(SS2)
32/326:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
C3 = Blend_by_weight(R1,S1)
C4 = Blend_by_weight(R1,S2)
Image.fromarray(C4)
32/327:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
C3 = Blend_by_weight(R1,S1)
C4 = Blend_by_weight(R1,S2*1.3)
Image.fromarray(C4)
32/328:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
C3 = Blend_by_weight(R1,S1)
C4 = Blend_by_weight(R1,S2*1.2)
Image.fromarray(C4)
32/329:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
C3 = Blend_by_weight(R1,S1)
C4 = Blend_by_weight(R1,S2*1.1)
Image.fromarray(C4)
32/330:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
C3 = Blend_by_weight(R1,S1)
C4 = Blend_by_weight(R1,S2*1.15)
Image.fromarray(C4)
32/331:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
C3 = Blend_by_weight(R1,S1)
C4 = Blend_by_weight(R1,S2*1.12)
Image.fromarray(C4)
32/332:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
C3 = Blend_by_weight(R1,S1)
C4 = Blend_by_weight(R1,S2*1.1)
Image.fromarray(C4)
32/333:
R1 = [img_2_matrix(pp) for pp in Re_images]
C2 = Blend_by_weight(R1,S)
C3 = Blend_by_weight(R1,S1)
C4 = Blend_by_weight(R1,S2*1.11)
Image.fromarray(C4)
32/334:
#get weight
def make_weight(In_d,Out_d,size,lightplus,gauss_scale):
    Out_= size/Outer_distence
    Inner_ = Inner_distence/Inner_distence
    Weight_Out = norm.pdf(Outer_distence,scale=size*gauss_scale)
    Weight_inner = norm.pdf(Inner_distence,scale=size*gauss_scale)
    ALL_weight = np.hstack((Weight_Out,Weight_inner))
    return ALL_weight*lightplus
32/335:
#get weight
def make_weight(Inner_distence,Outer_distence,size,lightplus,gauss_scale):
    Out_= size/Outer_distence
    Inner_ = Inner_distence/Inner_distence
    Weight_Out = norm.pdf(Outer_distence,scale=size*gauss_scale)
    Weight_inner = norm.pdf(Inner_distence,scale=size*gauss_scale)
    ALL_weight = np.hstack((Weight_Out,Weight_inner))
    return ALL_weight*lightplus
32/336:
#get weight
def make_weight(Inner_distence,Outer_distence,size,lightplus,gauss_scale):
    Out_= size/Outer_distence
    Inner_ = Inner_distence/Inner_distence
    Weight_Out = norm.pdf(Outer_distence,scale=size*gauss_scale)
    Weight_inner = norm.pdf(Inner_distence,scale=size*gauss_scale)
    ALL_weight = np.hstack((Weight_inner*Inner_,Weight_Out*Out_))
    return ALL_weight*lightplus
32/337: S
32/338: SS
32/339: sum(SS)
32/340: S1
32/341: sum(S1)
32/342: make_weight(Inner_distence,Outer_distence,4,1,1)
32/343: SS
32/344: make_weight(Inner_distence,Outer_distence,4,1,0.5)
32/345: make_weight(Inner_distence,Outer_distence,4,1,1)
32/346: S1
32/347: S
32/348: make_weight(Inner_distence,Outer_distence,4,1,0.5)
32/349: S1
32/350: S2
32/351: S3
32/352: a = make_weight(Inner_distence,Outer_distence,4,1,0.5)
32/353:
plt.scatter([i for i in range(len(S1))],S1)
plt.scatter([i for i in range(len(a))],a)
32/354: a = make_weight(Inner_distence,Outer_distence,4,1,1)
32/355:
plt.scatter([i for i in range(len(S1))],S1)
plt.scatter([i for i in range(len(a))],a)
32/356: plt.scatter([i for i in range(len(a))],a)
32/357: a = make_weight(Inner_distence,Outer_distence,4,1,3)
32/358: plt.scatter([i for i in range(len(a))],a)
32/359:
def get_aperture_image(x,y,size,xbias,ybias):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size,1,1)
    ALL_set = A+B
    P = [get_photo(i[0],i[1]) for i in ALL_set]
    Bias_all = get_bias([x,y],ALL_set,xbias,ybias)
    Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
    Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
    R = [img_2_matrix(pp) for pp in Re_images]
    return Blend_by_weight(R,Weight)
32/360: get_aperture_image(8.4,8.6,4,-8.3,8.6)
32/361: C = get_aperture_image(8.4,8.6,4,-8.3,8.6)
32/362: Image.fromarray(C)
32/363:
def make_bias_images(ALL_set,xbias,ybias):
    P = [get_photo(i[0],i[1]) for i in ALL_set]
    Bias_all = get_bias([x,y],ALL_set,xbias,ybias)
    Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
    Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
    R = [img_2_matrix(pp) for pp in Re_images]
    return R
32/364:
def make_bias_images(ALL_set,xbias,ybias):
    P = [get_photo(i[0],i[1]) for i in ALL_set]
    Bias_all = get_bias([x,y],ALL_set,xbias,ybias)
    Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
    Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
    R = [img_2_matrix(pp) for pp in Re_images]
    return R
32/365:
def get_aperture_image(x,y,size,R,xbias,ybias):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size,1,1)
    ALL_set = A+B
    R = make_bias_images(ALL_set,xbias,ybias)
    W = normalize(Weight)
    return Blend_by_weight(R,W)
32/366:
def get_aperture_image(x,y,size,R,xbias,ybias):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size,1,1)
    ALL_set = A+B
    R = make_bias_images(ALL_set,xbias,ybias)
    W = normalize(Weight)
    return Blend_by_weight(R,W)
32/367: C = get_aperture_image(8.4,8.6,3,-8.3,8.6)
32/368:
def get_aperture_image(x,y,size,xbias,ybias):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size,1,1)
    ALL_set = A+B
    R = make_bias_images(ALL_set,xbias,ybias)
    W = normalize(Weight)
    return Blend_by_weight(R,W)
32/369: C = get_aperture_image(8.4,8.6,3,-8.3,8.6)
32/370: Image.fromarray(C)
32/371:
root = tk.Tk()

def Get_image(self):
    print(Y.get())

root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y",command = Get_image)
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
var1 = tk.IntVar()
var2 = tk.IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1).grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2).grid(column =3, row=3)

Make = tk.Button(root,text="Make image",command=Get_image).grid(column = 5,row = 3)
root.mainloop()
32/372:
root = tk.Tk()

def Get_image(self):
    print(Y.get())

root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
var1 = tk.IntVar()
var2 = tk.IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1).grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2).grid(column =3, row=3)

Make = tk.Button(root,text="Make image",command=Get_image).grid(column = 5,row = 3)
root.mainloop()
32/373:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
var1 = tk.IntVar()
var2 = tk.IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1).grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2).grid(column =3, row=3)

def Get_image():
    print(Y.get())

Make = tk.Button(root,text="Make image",command=Get_image).grid(column = 5,row = 3)

root.mainloop()
32/374:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
var1 = tk.IntVar()
var2 = tk.IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1).grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2).grid(column =3, row=3)

def Get_image():
    z = Z.get()
    y = Y.get()
    x = X.get()
    if var1 == 0:
        print(x,y,z)
    if var1 == 1:
        print(x,y)

Make = tk.Button(root,text="Make image",command=Get_image).grid(column = 5,row = 3)

root.mainloop()
32/375:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=0, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
var1 = tk.IntVar()
var2 = tk.IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1).grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2).grid(column =3, row=3)

def Get_image(self):
    z = Z.get()
    y = Y.get()
    x = X.get()
    if var1 == 0:
        print(x,y,z)
    if var1 == 1:
        print(x,y)

Make = tk.Button(root,text="Make image",command=Get_image).grid(column = 5,row = 3)

root.mainloop()
32/376:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus").grid(column = 6, row = 1)
scaletimes = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ").grid(column = 7, row = 1)
var1 = tk.IntVar()
var2 = tk.IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1).grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2).grid(column =3, row=3)

def Get_image():
    z = Z.get()
    y = Y.get()
    x = X.get()
    if var1 == 0:
        print(x,y,z)
    if var1 == 1:
        print(x,y)

Make = tk.Button(root,text="Make image",command=Get_image).grid(column = 5,row = 3)

root.mainloop()
32/377:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus").grid(column = 6, row = 1)
scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ").grid(column = 7, row = 1)
var1 = tk.IntVar()
var2 = tk.IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1).grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2).grid(column =3, row=3)

def Get_image():
    z = Z.get()
    y = Y.get()
    x = X.get()
    if var1 == 0:
        print(x,y,z)
    if var1 == 1:
        print(x,y)

Make = tk.Button(root,text="Make image",command=Get_image).grid(column = 5,row = 3)

root.mainloop()
32/378:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X").grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z").grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x").grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y").grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size").grid(column = 5, row = 1)
lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus").grid(column = 6, row = 1)
scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ").grid(column = 7, row = 1)
var1 = tk.IntVar()
var2 = tk.IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1).grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2).grid(column =3, row=3)

def Get_image():
    z = Z.get()
    y = Y.get()
    x = X.get()
    if var1 == 0:
        print(x,y,z)
    if var1 == 1:
        print(x,y)

Make = tk.Button(root,text="Make image",command=Get_image).grid(column = 5,row = 3)

root.mainloop()
32/379:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
lightplus.grid(column = 6, row = 1)
scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
scaletimes.grid(column = 7, row = 1)
var1 = tk.IntVar()
var2 = tk.IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1)
If_aperture.grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2)
If_pinhole.grid(column =3, row=3)

def Get_image():
    z = Z.get()
    y = Y.get()
    x = X.get()
    if var1 == 0:
        print(x,y,z)
    if var1 == 1:
        print(x,y)

Make = tk.Button(root,text="Make image",command=Get_image).grid(column = 5,row = 3)

root.mainloop()
32/380:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
lightplus.grid(column = 6, row = 1)
scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
scaletimes.grid(column = 7, row = 1)
var1 = tk.IntVar()
var2 = tk.IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1)
If_aperture_aperture.grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2)
If_pinhole.grid(column =3, row=3)

def Get_image():
    z = Z.get()
    y = Y.get()
    x = X.get()
    if var1 == 0:
        print(x,y,z)
    if var1 == 1:
        print(x,y)

Make = tk.Button(root,text="Make image",command=Get_image).grid(column = 5,row = 3)

root.mainloop()
32/381:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
lightplus.grid(column = 6, row = 1)
scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
scaletimes.grid(column = 7, row = 1)
var1 = tk.IntVar()
var2 = tk.IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1)
If_aperture.grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2)
If_pinhole.grid(column =3, row=3)

def Get_image():
    z = Z.get()
    y = Y.get()
    x = X.get()
    if var1 == 0:
        print(x,y,z)
    if var1 == 1:
        print(x,y)

Make = tk.Button(root,text="Make image",command=Get_image).grid(column = 5,row = 3)

root.mainloop()
33/1:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
lightplus.grid(column = 6, row = 1)
scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
scaletimes.grid(column = 7, row = 1)
var1 = tk.IntVar()
var2 = tk.IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1)
If_aperture.grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2)
If_pinhole.grid(column =3, row=3)

def Get_image():
    z = Z.get()
    y = Y.get()
    x = X.get()
    if var1 == 0:
        print(x,y,z)
    if var1 == 1:
        print(x,y)

Make = tk.Button(root,text="Make image",command=Get_image).grid(column = 5,row = 3)

root.mainloop()
33/2:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
33/3:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
lightplus.grid(column = 6, row = 1)
scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
scaletimes.grid(column = 7, row = 1)
var1 = tk.IntVar()
var2 = tk.IntVar()
If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1)
If_aperture.grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2)
If_pinhole.grid(column =3, row=3)

def Get_image():
    z = Z.get()
    y = Y.get()
    x = X.get()
    if var1 == 0:
        print(x,y,z)
    if var1 == 1:
        print(x,y)

Make = tk.Button(root,text="Make image",command=Get_image).grid(column = 5,row = 3)

root.mainloop()
33/4:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
lightplus.grid(column = 6, row = 1)
scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
scaletimes.grid(column = 7, row = 1)

If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1)
If_aperture.grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2)
If_pinhole.grid(column =3, row=3)

def Get_image():
    z = Z.get()
    y = Y.get()
    x = X.get()
    if var1.get() == 0:
        print(x,y,z)
    if var1 == 1:
        print(x,y)

Make = tk.Button(root,text="Make image",command=Get_image).grid(column = 5,row = 3)

root.mainloop()
33/5:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
lightplus.grid(column = 6, row = 1)
scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
scaletimes.grid(column = 7, row = 1)

If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1)
If_aperture.grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2)
If_pinhole.grid(column =3, row=3)

def Get_image():
    z = Z.get()
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Q_interpolator2([8.4,8.6],-8.3,8.6))))

Make = tk.Button(root,text="Make image",command=Get_image).grid(column = 5,row = 3)

root.mainloop()
33/6:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
lightplus.grid(column = 6, row = 1)
scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
scaletimes.grid(column = 7, row = 1)

If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1)
If_aperture.grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2)
If_pinhole.grid(column =3, row=3)

def Get_image():
    z = Z.get()
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Q_interpolator2([8.4,8.6],-8.3,8.6)))

Make = tk.Button(root,text="Make image",command=Get_image).grid(column = 5,row = 3)

root.mainloop()
33/7:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
33/8:
Data_cut = []
for i in range(len(Data)):
    if i%4 == 0:
        Data_cut.append(Data[i])
33/9:
def normalize(v):
    norm=np.linalg.norm(v, ord=1)
    if norm==0:
        norm=np.finfo(v.dtype).eps
    return v/norm
def show_img(img):
    im=Image.fromarray(img) 
    im.show()
#get the photo [320*240] as a vector with the uv coord(x,y)
def get_photo(x,y):
    index = 255-x-16*y
    return Data[index]
#Input:photos like as(wh,3)*n,and the weight
#Output:photos*weight
def Blend_by_weight(P,w):
    Image = np.zeros((76800,3),dtype=np.uint8)
    for i in range(len(P)):
        Temp = (np.floor(P[i]*w[i])).astype(np.uint8)
        Image = Image + Temp
    return matrix_2_img(Image)
33/10:
#x(0,15),y(0,15)
def Q_interpolator(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo(x_,y_)
    p2 = get_photo(x_+1,y_)
    p3 = get_photo(x_,y_-1)
    p4 = get_photo(x_+1,y_-1)
    return Blend_by_weight([p1,p2,p3,p4],normalize(w))
33/11: I = Q_interpolator([8.4,8.6])
33/12:
def get_photo_cut(x,y):
    index = 64-x-8*y
    return Data_cut[index]
#x(0,15),y(0,15)
def Q_interpolator_cut(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo_cut(x_,y_)
    p2 = get_photo_cut(x_+1,y_)
    p3 = get_photo_cut(x_,y_-1)
    p4 = get_photo_cut(x_+1,y_-1)
    return Blend_by_weight([p1,p2,p3,p4],normalize(w))
cut = Q_interpolator_cut([4.5,4.5])
33/13:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint16)
    for x in range(w):
        for y in range(h):
            Coord = np.array([x,y])+disparity
            if Coord[1]<0 :
                Coord[1] = 0
            if Coord[0]<0:
                Coord[0] = 0
            if Coord[1]>h-1 :
                Coord[1] = h-1
            if Coord[0]>w-1:
                Coord[0] = w-1
            White_image[y][x] = np.floor(Coord)
    return White_image
33/14:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for x in range(w):
        for y in range(h):
            u,v = Bias_map[y][x]
            White_image[y][x] = Image[v][u]
    return White_image
33/15:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for x in range(w):
        for y in range(h):
            u,v = Bias_map[y][x]
            White_image[y][x] = Image[v][u]
    return White_image
33/16:
def get_bias(center,point_set,x_bias,y_bias):
    #Based on the center get the bias of all arround points
    Bias_all = [] 
    for i in range(len(point_set)):
        Bias = (np.array(point_set[i])-center)*[x_bias,y_bias]
        Bias_all.append(Bias)
    return Bias_all
33/17:
def Q_interpolator2(coords,x_bias,y_bias):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
    Bias_all = get_bias(coords,Square,x_bias,y_bias)
    #The bais for 4 photo
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    P = [get_photo(Square[i][0],Square[i][1]) for i in range(len(Square))]
    #All bias matrix
    Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
    #All redo image
    Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
    #Blend redo image
    R = [img_2_matrix(pp) for pp in Re_images]
    return Blend_by_weight(R,normalize(w))
33/18:
def normalize(v):
    norm=np.linalg.norm(v, ord=1)
    if norm==0:
        norm=np.finfo(v.dtype).eps
    return v/norm
33/19:
X = Q_interpolator2([8.4,8.6],-8.3,8.6)
im=Image.fromarray(X)
im
33/20:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
lightplus.grid(column = 6, row = 1)
scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
scaletimes.grid(column = 7, row = 1)

If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1)
If_aperture.grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2)
If_pinhole.grid(column =3, row=3)

def Get_image():
    z = Z.get()
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Q_interpolator2([8.4,8.6],-8.3,8.6)))

Make = tk.Button(root,text="Make image",command=Get_image).grid(column = 5,row = 3)

root.mainloop()
33/21:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
lightplus.grid(column = 6, row = 1)
scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
scaletimes.grid(column = 7, row = 1)

If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1)
If_aperture.grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2)
If_pinhole.grid(column =3, row=3)

def Get_image():
    z = Z.get()
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Q_interpolator2([8.4,8.6],-8.3,8.6)))
    W.configure(image=imgtk)
    W.image = imgtk
    


root.bind("<Return>", Get_image)

Make = tk.Button(root,text="Make image",command=Get_image).grid(column = 5,row = 3)

root.mainloop()
33/22:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
lightplus.grid(column = 6, row = 1)
scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
scaletimes.grid(column = 7, row = 1)

If_aperture = tk.Checkbutton(root, text="Aperture Model", variable=var1)
If_aperture.grid(column=3,row = 2)
If_pinhole = tk.Checkbutton(root, text="Pinhole Model", variable=var2)
If_pinhole.grid(column =3, row=3)

def Get_image():
    z = Z.get()
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = Q_interpolator2([x,y],xbias,ybias)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk
    


root.bind("<Return>", Get_image)

Make = tk.Button(root,text="Make image",command=Get_image).grid(column = 5,row = 3)

root.mainloop()
33/23:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
lightplus.grid(column = 6, row = 1)
scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
scaletimes.grid(column = 7, row = 1)


def Get_image_pinhole():
    z = Z.get()
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = Q_interpolator2([x,y],xbias,ybias)
    Scale
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

def Get_image_aperture():
    z = Z.get()
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = Q_interpolator2([x,y],xbias,ybias)
    Scale
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk


root.bind("<Return>", Get_image_pinhole)
root.bind("<Return>", Get_image_aperture)

Pinhole = tk.Button(root,text="Make Pinhole Image",command=Get_image_pinhole).grid(column = 5,row = 3)
Aperture = tk.Button(root,text="Make Aperture Image",command=Get_image_aperture).grid(column=3,row = 2)

root.mainloop()
33/24:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
lightplus.grid(column = 6, row = 1)
scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
scaletimes.grid(column = 7, row = 1)


def Get_image_pinhole():
    z = Z.get()
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = Q_interpolator2([x,y],xbias,ybias)
    Scale
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

def Get_image_aperture():
    z = Z.get()
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = Q_interpolator2([x,y],xbias,ybias)
    Scale
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk


root.bind("<Return>", Get_image_pinhole)
root.bind("<Return>", Get_image_aperture)

Pinhole = tk.Button(root,text="Make Pinhole Image",command=Get_image_pinhole).grid(column = 3,row = 3)
Aperture = tk.Button(root,text="Make Aperture Image",command=Get_image_aperture).grid(column=3,row = 2)

root.mainloop()
33/25:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
lightplus.grid(column = 6, row = 1)
scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
scaletimes.grid(column = 7, row = 1)


def Get_image_pinhole():
    z = Z.get()
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = Q_interpolator2([x,y],xbias,ybias)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

def Get_image_aperture():
    z = Z.get()
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = Q_interpolator2([x,y],xbias,ybias)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk


root.bind("<Return>", Get_image_pinhole)
root.bind("<Return>", Get_image_aperture)

Pinhole = tk.Button(root,text="Make Pinhole Image",command=Get_image_pinhole).grid(column = 3,row = 3)
Aperture = tk.Button(root,text="Make Aperture Image",command=Get_image_aperture).grid(column=3,row = 2)

root.mainloop()
33/26:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
lightplus.grid(column = 6, row = 1)
scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
scaletimes.grid(column = 7, row = 1)


def Get_image_pinhole():
    z = Z.get()
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = Q_interpolator2([x,y],xbias,ybias)
    Matrix = scale_by_z(z,Matrix)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

def Get_image_aperture():
    z = Z.get()
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = Q_interpolator2([x,y],xbias,ybias)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk


root.bind("<Return>", Get_image_pinhole)
root.bind("<Return>", Get_image_aperture)

Pinhole = tk.Button(root,text="Make Pinhole Image",command=Get_image_pinhole).grid(column = 3,row = 3)
Aperture = tk.Button(root,text="Make Aperture Image",command=Get_image_aperture).grid(column=3,row = 2)

root.mainloop()
33/27:
def aperture_size(coord,r):
    Max = np.array(coord)+r
    Min = np.array(coord)-r
    return print(Max)
33/28:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    y = (H*Range).astype(int) 
    x = (W*Range).astype(int) 
    image = image[y[0]:y[1],x[0]:x[1]]
    I = Image.fromarray(image).resize((320,240))
    return np.array(I)
33/29: aperture_size([0.5,0.5],2)
33/30:
k = scale_by_z(0.5,X)
Image.fromarray(k)
33/31:
X = Q_interpolator2([8.4,8.6],-3.6,6.5)
im=Image.fromarray(X)
im
33/32:
k = scale_by_z(0.5,X)
Image.fromarray(k)
33/33:
root = tk.Tk()


root.title("Assignment1")
imgtk = ImageTk.PhotoImage(image=Image.fromarray(matrix_2_img(Data[0])))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
lightplus.grid(column = 6, row = 1)
scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
scaletimes.grid(column = 7, row = 1)


def Get_image_pinhole():
    z = Z.get()
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = Q_interpolator2([x,y],xbias,ybias)
    Matrix = scale_by_z(z,Matrix)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

def Get_image_aperture():
    z = Z.get()
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = Q_interpolator2([x,y],xbias,ybias)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk


root.bind("<Return>", Get_image_pinhole)
root.bind("<Return>", Get_image_aperture)

Pinhole = tk.Button(root,text="Make Pinhole Image",command=Get_image_pinhole).grid(column = 3,row = 3)
Aperture = tk.Button(root,text="Make Aperture Image",command=Get_image_aperture).grid(column=3,row = 2)

root.mainloop()
33/34:
def get_aperture_image(x,y,size,xbias,ybias,light,gauss_scale):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size,light,gauss_scale)
    ALL_set = A+B
    R = make_bias_images(ALL_set,xbias,ybias)
    W = normalize(Weight)
    return Blend_by_weight(R,W)
33/35:
def make_bias_images(ALL_set,xbias,ybias):
    P = [get_photo(i[0],i[1]) for i in ALL_set]
    Bias_all = get_bias([x,y],ALL_set,xbias,ybias)
    Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
    Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
    R = [img_2_matrix(pp) for pp in Re_images]
    return R
33/36:
#get weight
def make_weight(Inner_distence,Outer_distence,size,lightplus,gauss_scale):
    Out_= size/Outer_distence
    Inner_ = Inner_distence/Inner_distence
    Weight_Out = norm.pdf(Outer_distence,scale=size*gauss_scale)
    Weight_inner = norm.pdf(Inner_distence,scale=size*gauss_scale)
    ALL_weight = np.hstack((Weight_inner*Inner_,Weight_Out*Out_))
    return ALL_weight*lightplus
33/37:
def Get_distence(A,center):
    A = np.array(A)
    return (np.sum((A-center)**2,axis=1))**0.5
33/38:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Left = [[x1y1[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Right = [[x4y4[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Outer = Up+Down+Left+Right
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Temp.append([i,j])
        Inner = Inner + Temp
    return Inner,Outer
33/39:
root = tk.Tk()


root.title("Assignment1")
Matrix = matrix_2_img(Data[0])
imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
Lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
Lightplus.grid(column = 6, row = 1)
Scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
Scaletimes.grid(column = 7, row = 1)


def Get_image_pinhole():
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = Q_interpolator2([x,y],xbias,ybias)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

def Get_image_aperture():
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    size = Aperture_size.get()
    lightplus = Lightplus.get()
    scaletimes = Scaletimes.get()
    Matrix = get_aperture_image(x,y,)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

def scale_z():
    Matrix = scale_by_z(z,Matrix)

root.bind("<Return>", Get_image_pinhole)
root.bind("<Return>", Get_image_aperture)

Pinhole = tk.Button(root,text="Make Pinhole Image",command=Get_image_pinhole).grid(column = 3,row = 3)
Aperture = tk.Button(root,text="Make Aperture Image",command=Get_image_aperture).grid(column=3,row = 2)

root.mainloop()
33/40:
root = tk.Tk()


root.title("Assignment1")
Matrix = matrix_2_img(Data[0])
imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",command = Move_z,label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
Lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
Lightplus.grid(column = 6, row = 1)
Scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
Scaletimes.grid(column = 7, row = 1)


def Get_image_pinhole():
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = Q_interpolator2([x,y],xbias,ybias)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

def Get_image_aperture():
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    size = Aperture_size.get()
    light = Lightplus.get()
    gauss_scale = Scaletimes.get()
    Matrix = get_aperture_image(x,y,size,xbias,ybias,light,gauss_scale)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

def Move_z():
    z = Z.get()
    Matrix = scale_by_z(z,Matrix)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

root.bind("<Return>", Get_image_pinhole)
root.bind("<Return>", Get_image_aperture)
root.bind("<Return>", Move_z)

Pinhole = tk.Button(root,text="Make Pinhole Image",command=Get_image_pinhole).grid(column = 3,row = 3)
Aperture = tk.Button(root,text="Make Aperture Image",command=Get_image_aperture).grid(column=3,row = 2)

root.mainloop()
33/41:
root = tk.Tk()


root.title("Assignment1")
Matrix = matrix_2_img(Data[0])
imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))

def Move_z():
    z = Z.get()
    Matrix = scale_by_z(z,Matrix)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

    
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",command = Move_z,label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
Lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
Lightplus.grid(column = 6, row = 1)
Scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
Scaletimes.grid(column = 7, row = 1)


def Get_image_pinhole():
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = Q_interpolator2([x,y],xbias,ybias)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

def Get_image_aperture():
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    size = Aperture_size.get()
    light = Lightplus.get()
    gauss_scale = Scaletimes.get()
    Matrix = get_aperture_image(x,y,size,xbias,ybias,light,gauss_scale)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk



root.bind("<Return>", Get_image_pinhole)
root.bind("<Return>", Get_image_aperture)
root.bind("<Return>", Move_z)

Pinhole = tk.Button(root,text="Make Pinhole Image",command=Get_image_pinhole).grid(column = 3,row = 3)
Aperture = tk.Button(root,text="Make Aperture Image",command=Get_image_aperture).grid(column=3,row = 2)

root.mainloop()
34/1:
import tkinter as tk
from scipy.stats import norm
from PIL import ImageTk 
from PIL import Image 
import os
import imageio
import numpy as np
import math
    
path = 'LFdata/toyLF/'
Temp = [] 
for i in range(1,257):
    if i<10:
        name = "00"+str(i)
    elif i<100:
        name = "0"+str(i)
    else:
        name = str(i)
    Temp.append(imageio.imread(os.path.join(path,'lowtoys'+name+'.bmp')))

def matrix_2_img(matrix):
    return matrix.reshape(240,320,3)
def img_2_matrix(img):
    return img.reshape(320*240,3)
Data = []
for i in range(len(Temp)):
    Data.append(img_2_matrix(Temp[i]))
Data = np.array(Data)
34/2:
def normalize(v):
    norm=np.linalg.norm(v, ord=1)
    if norm==0:
        norm=np.finfo(v.dtype).eps
    return v/norm
def show_img(img):
    im=Image.fromarray(img) 
    im.show()
#get the photo [320*240] as a vector with the uv coord(x,y)
def get_photo(x,y):
    index = 255-x-16*y
    return Data[index]
#Input:photos like as(wh,3)*n,and the weight
#Output:photos*weight
def Blend_by_weight(P,w):
    Image = np.zeros((76800,3),dtype=np.uint8)
    for i in range(len(P)):
        Temp = (np.floor(P[i]*w[i])).astype(np.uint8)
        Image = Image + Temp
    return matrix_2_img(Image)
34/3:
#x(0,15),y(0,15)
def Q_interpolator(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo(x_,y_)
    p2 = get_photo(x_+1,y_)
    p3 = get_photo(x_,y_-1)
    p4 = get_photo(x_+1,y_-1)
    return Blend_by_weight([p1,p2,p3,p4],normalize(w))
34/4:
def get_photo_cut(x,y):
    index = 64-x-8*y
    return Data_cut[index]
#x(0,15),y(0,15)
def Q_interpolator_cut(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo_cut(x_,y_)
    p2 = get_photo_cut(x_+1,y_)
    p3 = get_photo_cut(x_,y_-1)
    p4 = get_photo_cut(x_+1,y_-1)
    return Blend_by_weight([p1,p2,p3,p4],normalize(w))
cut = Q_interpolator_cut([4.5,4.5])
34/5: #I = Q_interpolator([8.4,8.6])
34/6:
'''
def get_photo_cut(x,y):
    index = 64-x-8*y
    return Data_cut[index]
#x(0,15),y(0,15)
def Q_interpolator_cut(coords):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    p1 = get_photo_cut(x_,y_)
    p2 = get_photo_cut(x_+1,y_)
    p3 = get_photo_cut(x_,y_-1)
    p4 = get_photo_cut(x_+1,y_-1)
    return Blend_by_weight([p1,p2,p3,p4],normalize(w))
cut = Q_interpolator_cut([4.5,4.5])
'''
34/7:
def disparity_matrix(disparity,h,w):
    #(u,v) = (u_,v_) + disparity(bias_x,bias_y)
    x_bias,y_bias = disparity
    White_image = np.zeros((h,w,2),dtype=np.uint16)
    for x in range(w):
        for y in range(h):
            Coord = np.array([x,y])+disparity
            if Coord[1]<0 :
                Coord[1] = 0
            if Coord[0]<0:
                Coord[0] = 0
            if Coord[1]>h-1 :
                Coord[1] = h-1
            if Coord[0]>w-1:
                Coord[0] = w-1
            White_image[y][x] = np.floor(Coord)
    return White_image
34/8:
#repreduce the image by adjust(u,v) to new (u,v)
def re_image(Matrix,Bias_map,w,h):
    #Image base
    Image = matrix_2_img(Matrix)
    #New image
    White_image = np.zeros((h,w,3),dtype=np.uint8)
    #Based on the new,coords,get the pixels from the orginal photo
    for x in range(w):
        for y in range(h):
            u,v = Bias_map[y][x]
            White_image[y][x] = Image[v][u]
    return White_image
34/9:
def get_bias(center,point_set,x_bias,y_bias):
    #Based on the center get the bias of all arround points
    Bias_all = [] 
    for i in range(len(point_set)):
        Bias = (np.array(point_set[i])-center)*[x_bias,y_bias]
        Bias_all.append(Bias)
    return Bias_all
34/10:
def Q_interpolator2(coords,x_bias,y_bias):
    x,y = (coords[0],coords[1])
    x_ = int(x)
    y_ = math.ceil(y)
    Square = [[x_,y_],[x_+1,y_],[x_,y_-1],[x_+1,y_-1]]
    Bias_all = get_bias(coords,Square,x_bias,y_bias)
    #The bais for 4 photo
    d1 = x-x_
    d2 = y_-y
    w = [(1-d1)*(1-d2),d1*(1-d2),(1-d1)*d2,d1*d2]
    P = [get_photo(Square[i][0],Square[i][1]) for i in range(len(Square))]
    #All bias matrix
    Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
    #All redo image
    Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
    #Blend redo image
    R = [img_2_matrix(pp) for pp in Re_images]
    return Blend_by_weight(R,normalize(w))
34/11:
def normalize(v):
    norm=np.linalg.norm(v, ord=1)
    if norm==0:
        norm=np.finfo(v.dtype).eps
    return v/norm
34/12:
X = Q_interpolator2([8.4,8.6],-8.3,8.6)
im=Image.fromarray(X)
im
34/13:
def aperture_size(coord,r):
    Max = np.array(coord)+r
    Min = np.array(coord)-r
    return print(Max)
34/14:
def scale_by_z(Z_,image):
    W = 320
    H = 240
    Range = np.array([0.5-Z_/2,0.5+Z_/2])
    y = (H*Range).astype(int) 
    x = (W*Range).astype(int) 
    image = image[y[0]:y[1],x[0]:x[1]]
    I = Image.fromarray(image).resize((320,240))
    return np.array(I)
34/15:
#Input the Coord of the adperture,get arround
def Get_arround_set(Coord,r):
    #In circle
    Inner = []
    #Out of circle
    Outer = []
    x,y = Coord
    x1y1 = [math.floor(x-r),math.ceil(y+r)]
    x4y4 = [math.ceil(x+r),math.floor(y-r)]
    Up = [[i,x1y1[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Down =  [[i,x4y4[1]] for i in range(x1y1[0],x4y4[0]+1)]
    Left = [[x1y1[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Right = [[x4y4[0],i+1] for i in range(x4y4[1],x1y1[1]-1)]
    Outer = Up+Down+Left+Right
    for i in range(x1y1[0]+1,x4y4[0]):
        Temp =[]
        for j in range(x4y4[1]+1,x1y1[1]):
            Temp.append([i,j])
        Inner = Inner + Temp
    return Inner,Outer
34/16:
def Get_distence(A,center):
    A = np.array(A)
    return (np.sum((A-center)**2,axis=1))**0.5
34/17:
#get weight
def make_weight(Inner_distence,Outer_distence,size,lightplus,gauss_scale):
    Out_= size/Outer_distence
    Inner_ = Inner_distence/Inner_distence
    Weight_Out = norm.pdf(Outer_distence,scale=size*gauss_scale)
    Weight_inner = norm.pdf(Inner_distence,scale=size*gauss_scale)
    ALL_weight = np.hstack((Weight_inner*Inner_,Weight_Out*Out_))
    return ALL_weight*lightplus
34/18:
def make_bias_images(ALL_set,xbias,ybias):
    P = [get_photo(i[0],i[1]) for i in ALL_set]
    Bias_all = get_bias([x,y],ALL_set,xbias,ybias)
    Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
    Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
    R = [img_2_matrix(pp) for pp in Re_images]
    return R
34/19:
def get_aperture_image(x,y,size,xbias,ybias,light,gauss_scale):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size,light,gauss_scale)
    ALL_set = A+B
    R = make_bias_images(ALL_set,xbias,ybias)
    W = normalize(Weight)
    return Blend_by_weight(R,W)
34/20: C = get_aperture_image(8.4,8.6,2,-8.3,8.6,1,2)
34/21:
def make_bias_images(x,y,ALL_set,xbias,ybias):
    P = [get_photo(i[0],i[1]) for i in ALL_set]
    Bias_all = get_bias([x,y],ALL_set,xbias,ybias)
    Disparity_matrix = [disparity_matrix(B,240,320) for B in Bias_all]
    Re_images = [re_image(P[i],Disparity_matrix[i],320,240) for i in range(len(Bias_all))]
    R = [img_2_matrix(pp) for pp in Re_images]
    return R
34/22:
def get_aperture_image(x,y,size,xbias,ybias,light,gauss_scale):
    #Get the points
    center = [x,y]
    A,B = Get_arround_set([x,y],size)
    Inner_distence = Get_distence(A,center)
    Outer_distence = Get_distence(B,center)
    Weight = make_weight(Inner_distence,Outer_distence,size,light,gauss_scale)
    ALL_set = A+B
    R = make_bias_images(x,y,ALL_set,xbias,ybias)
    W = normalize(Weight)
    return Blend_by_weight(R,W)
34/23: C = get_aperture_image(8.4,8.6,2,-8.3,8.6,1,2)
34/24: Image.fromarray(C)
34/25:
root = tk.Tk()


root.title("Assignment1")
Matrix = matrix_2_img(Data[0])
imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))

def Move_z():
    z = Z.get()
    Matrix = scale_by_z(z,Matrix)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

    
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",command = Move_z,label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
Lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
Lightplus.grid(column = 6, row = 1)
Scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
Scaletimes.grid(column = 7, row = 1)


def Get_image_pinhole():
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = Q_interpolator2([x,y],xbias,ybias)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

def Get_image_aperture():
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    size = Aperture_size.get()
    light = Lightplus.get()
    gauss_scale = Scaletimes.get()
    Matrix = get_aperture_image(x,y,size,xbias,ybias,light,gauss_scale)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk



root.bind("<Return>", Get_image_pinhole)
root.bind("<Return>", Get_image_aperture)
root.bind("<Return>", Move_z)

Pinhole = tk.Button(root,text="Make Pinhole Image",command=Get_image_pinhole).grid(column = 3,row = 3)
Aperture = tk.Button(root,text="Make Aperture Image",command=Get_image_aperture).grid(column=3,row = 2)

root.mainloop()
34/26:
root = tk.Tk()


root.title("Assignment1")
Matrix = matrix_2_img(Data[0])
imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))

def Move_z(self):
    z = Z.get()
    Matrix = scale_by_z(z,Matrix)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

    
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",command = Move_z,label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
Lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
Lightplus.grid(column = 6, row = 1)
Scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
Scaletimes.grid(column = 7, row = 1)


def Get_image_pinhole():
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = Q_interpolator2([x,y],xbias,ybias)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

def Get_image_aperture():
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    size = Aperture_size.get()
    light = Lightplus.get()
    gauss_scale = Scaletimes.get()
    Matrix = get_aperture_image(x,y,size,xbias,ybias,light,gauss_scale)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk



root.bind("<Return>", Get_image_pinhole)
root.bind("<Return>", Get_image_aperture)
root.bind("<Return>", Move_z)

Pinhole = tk.Button(root,text="Make Pinhole Image",command=Get_image_pinhole).grid(column = 3,row = 3)
Aperture = tk.Button(root,text="Make Aperture Image",command=Get_image_aperture).grid(column=3,row = 2)

root.mainloop()
34/27:
root = tk.Tk()


root.title("Assignment1")
Matrix = matrix_2_img(Data[0])
imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))

def Move_z(self):
    z = Z.get()
    Matrix = scale_by_z(z,Matrix)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

    
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",command = Move_z,label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
Lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
Lightplus.grid(column = 6, row = 1)
Scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
Scaletimes.grid(column = 7, row = 1)


def Get_image_pinhole():
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = Q_interpolator2([x,y],xbias,ybias)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

def Get_image_aperture():
    y = Y.get()
    x = X.get()
    xbias = D_x.get()
    ybias = D_y.get()
    size = Aperture_size.get()
    light = Lightplus.get()
    gauss_scale = Scaletimes.get()
    Matrix = get_aperture_image(x,y,size,xbias,ybias,light,gauss_scale)
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk



root.bind("<Return>", Get_image_pinhole)
root.bind("<Return>", Get_image_aperture)
root.bind("<Return>", Move_z)

Pinhole = tk.Button(root,text="Make Pinhole Image",command=Get_image_pinhole).grid(column = 3,row = 3)
Aperture = tk.Button(root,text="Make Aperture Image",command=Get_image_aperture).grid(column=3,row = 2)

root.mainloop()
34/28:
root = tk.Tk()


root.title("Assignment1")
Matrix = matrix_2_img(Data[0])
imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
Lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
Lightplus.grid(column = 6, row = 1)
Scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
Scaletimes.grid(column = 7, row = 1)


def Get_image_pinhole():
    y = Y.get()
    x = X.get()
    z = Z.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = scale_by_z(z,Q_interpolator2([x,y],xbias,ybias))
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

def Get_image_aperture():
    y = Y.get()
    x = X.get()
    z = Z.get()
    xbias = D_x.get()
    ybias = D_y.get()
    size = Aperture_size.get()
    light = Lightplus.get()
    gauss_scale = Scaletimes.get()
    Matrix = Matrix = scale_by_z(get_aperture_image(x,y,size,xbias,ybias,light,gauss_scale))
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk



root.bind("<Return>", Get_image_pinhole)
root.bind("<Return>", Get_image_aperture)
root.bind("<Return>", Move_z)

Pinhole = tk.Button(root,text="Make Pinhole Image",command=Get_image_pinhole).grid(column = 3,row = 3)
Aperture = tk.Button(root,text="Make Aperture Image",command=Get_image_aperture).grid(column=3,row = 2)

root.mainloop()
34/29:
root = tk.Tk()


root.title("Assignment1")
Matrix = matrix_2_img(Data[0])
imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
Lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
Lightplus.grid(column = 6, row = 1)
Scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
Scaletimes.grid(column = 7, row = 1)


def Get_image_pinhole():
    y = Y.get()
    x = X.get()
    z = Z.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = scale_by_z(z,Q_interpolator2([x,y],xbias,ybias))
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

def Get_image_aperture():
    y = Y.get()
    x = X.get()
    z = Z.get()
    xbias = D_x.get()
    ybias = D_y.get()
    size = Aperture_size.get()
    light = Lightplus.get()
    gauss_scale = Scaletimes.get()
    Matrix = scale_by_z(get_aperture_image(x,y,size,xbias,ybias,light,gauss_scale))
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk



root.bind("<Return>", Get_image_pinhole)
root.bind("<Return>", Get_image_aperture)
root.bind("<Return>", Move_z)

Pinhole = tk.Button(root,text="Make Pinhole Image",command=Get_image_pinhole).grid(column = 3,row = 3)
Aperture = tk.Button(root,text="Make Aperture Image",command=Get_image_aperture).grid(column=3,row = 2)

root.mainloop()
34/30:
root = tk.Tk()


root.title("Assignment1")
Matrix = matrix_2_img(Data[0])
imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    
Y = tk.Scale(root, from_=16, to=0 ,length=240,resolution=0.1,\
             orient="vertical",label="Y")
Y.grid(column = 1, row = 1)

W = tk.Label(root,image = imgtk,height = 240,width = 320)
W.grid(column = 2, row = 1)

X = tk.Scale(root, from_=0, to=16, length=320, \
      resolution=0.1,orient="horizontal",label = "X")
X.grid(column = 2, row = 2)
Z = tk.Scale(root, from_=1, to=0, length=320, \
      resolution=0.05,orient="horizontal",label = "Z")
Z.grid(column = 2, row = 3)
D_x = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_x")
D_x.grid(column = 3, row = 1)
D_y = tk.Scale(root, from_=-10, to=10, length=200, \
      resolution=0.1,orient="vertical",label = "D_y")
D_y.grid(column = 4, row = 1)
Aperture_size = tk.Scale(root, from_=1, to=5, length=200, \
      resolution=0.1,orient="vertical",label = "Aperture_size")
Aperture_size.grid(column = 5, row = 1)
Lightplus = tk.Scale(root, from_=1, to=2, length=200, \
      resolution=0.1,orient="vertical",label = "lightplus")
Lightplus.grid(column = 6, row = 1)
Scaletimes = tk.Scale(root, from_=0.3, to=3, length=200, \
      resolution=0.1,orient="vertical",label = "scaletimes ")
Scaletimes.grid(column = 7, row = 1)


def Get_image_pinhole():
    y = Y.get()
    x = X.get()
    z = Z.get()
    xbias = D_x.get()
    ybias = D_y.get()
    Matrix = scale_by_z(z,Q_interpolator2([x,y],xbias,ybias))
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk

def Get_image_aperture():
    y = Y.get()
    x = X.get()
    z = Z.get()
    xbias = D_x.get()
    ybias = D_y.get()
    size = Aperture_size.get()
    light = Lightplus.get()
    gauss_scale = Scaletimes.get()
    Matrix = scale_by_z(z,get_aperture_image(x,y,size,xbias,ybias,light,gauss_scale))
    imgtk = ImageTk.PhotoImage(image=Image.fromarray(Matrix))
    W.configure(image=imgtk)
    W.image = imgtk



root.bind("<Return>", Get_image_pinhole)
root.bind("<Return>", Get_image_aperture)
root.bind("<Return>", Move_z)

Pinhole = tk.Button(root,text="Make Pinhole Image",command=Get_image_pinhole).grid(column = 3,row = 3)
Aperture = tk.Button(root,text="Make Aperture Image",command=Get_image_aperture).grid(column=3,row = 2)

root.mainloop()
35/1: import numpy as np
35/2:
row1 = [1,-2,3,-1]
row2 = [0,4,1,7]
row3 = [1,-6,14,-5]
row4 = [2,0,-1,3]
35/3:
row1 = np.array([1,-2,3,-1])
row2 = np.array([0,4,1,7])
row3 = np.array([1,-6,14,-5])
row4 = np.array([2,0,-1,3])
35/4: row1+row4-row3-row2
35/5: np.matrix(row1,row2,row3,row4)
35/6: np.matrix([row1,row2,row3,row4])
35/7: A = np.matrix([row1,row2,row3,row4])
35/8: A.transpose
35/9: A
35/10: A.T
35/11: A = A.T
35/12: A[0]
36/1: import numpy as np
36/2:

from numba import jit
@jit
def get_det(mat):
    #为了节省空间，直接在输入的行列式上进行了化简，而没有使用copy
    mat = mat.astype('float')
    n = mat.shape[0]
    res = 1
    #遍历列
    for col in range(n):
        row = col
        res *= mat[row][col]
        #寻找不是0的位置row
        while mat[row][col] == 0 and row < n - 1:
            row += 1
        #化简mat[row,col]下面的每一元素为0
        for i in range(row + 1, n):
            if mat[i][col] == 0:
                pass
            else:
                k = - mat[i][col] / mat[row][col]
                for j in range(col ,n):
                    mat[i][j] += mat[row][j] * k
    return res

"""
测试：与numpy自带的计算行列式函数进行结果比较
"""
from numpy.random import rand, seed
from numpy.linalg import det
#生成随机行列式
seed(100)
n = 5
A = rand(n ** 2)
mat = A.reshape(n, n)
#打印numpy函数和自定义函数的结果
print(det(mat), get_det(mat))
#利用iPython的命令对比运行时间，猜猜谁快^
%timeit det(mat) #100000 loops, best of 3: 7.31 µs per loop
%timeit get_det(mat) #10000 loops, best of 3: 52.4 µs per loop
#jit 100000 loops, best of 3: 3.52 µs per loop
36/3:
from numba import jit
@jit
def get_det(mat):
    #为了节省空间，直接在输入的行列式上进行了化简，而没有使用copy
    mat = mat.astype('float')
    n = mat.shape[0]
    res = 1
    #遍历列
    for col in range(n):
        row = col
        res *= mat[row][col]
        #寻找不是0的位置row
        while mat[row][col] == 0 and row < n - 1:
            row += 1
        #化简mat[row,col]下面的每一元素为0
        for i in range(row + 1, n):
            if mat[i][col] == 0:
                pass
            else:
                k = - mat[i][col] / mat[row][col]
                for j in range(col ,n):
                    mat[i][j] += mat[row][j] * k
    return res

from numpy.random import rand, seed
from numpy.linalg import det
#生成随机行列式
seed(100)
n = 5
A = rand(n ** 2)
mat = A.reshape(n, n)
#打印numpy函数和自定义函数的结果
print(det(mat), get_det(mat))
#利用iPython的命令对比运行时间，猜猜谁快^
%timeit det(mat) #100000 loops, best of 3: 7.31 µs per loop
%timeit get_det(mat) #10000 loops, best of 3: 52.4 µs per loop
#jit 100000 loops, best of 3: 3.52 µs per loop
36/4:
from numba import jit
@jit
def get_det(mat):
    mat = mat.astype('float')
    n = mat.shape[0]
    res = 1
    for col in range(n):
        row = col
        res *= mat[row][col]
        while mat[row][col] == 0 and row < n - 1:
            row += 1
        for i in range(row + 1, n):
            if mat[i][col] == 0:
                pass
            else:
                k = - mat[i][col] / mat[row][col]
                for j in range(col ,n):
                    mat[i][j] += mat[row][j] * k
    return res

from numpy.random import rand, seed
from numpy.linalg import det

seed(100)
n = 5
A = rand(n ** 2)
mat = A.reshape(n, n)
print(det(mat), get_det(mat))

%timeit det(mat) #100000 loops, best of 3: 7.31 µs per loop
%timeit get_det(mat) #10000 loops, best of 3: 52.4 µs per loop
#jit 100000 loops, best of 3: 3.52 µs per loop
36/5:
from numba import jit
@jit
def get_det(mat):
    mat = mat.astype('float')
    n = mat.shape[0]
    res = 1
    for col in range(n):
        row = col
        res *= mat[row][col]
        while mat[row][col] == 0 and row < n - 1:
            row += 1
        for i in range(row + 1, n):
            if mat[i][col] == 0:
                pass
            else:
                k = - mat[i][col] / mat[row][col]
                for j in range(col ,n):
                    mat[i][j] += mat[row][j] * k
    return res

from numpy.random import rand, seed
from numpy.linalg import det

seed(100)
n = 5
A = rand(n ** 2)
mat = A.reshape(n, n)
print(det(mat), get_det(mat))
36/6:
def get_det(mat):
    mat = mat.astype('float')
    n = mat.shape[0]
    res = 1
    for col in range(n):
        row = col
        res *= mat[row][col]
        while mat[row][col] == 0 and row < n - 1:
            row += 1
        for i in range(row + 1, n):
            if mat[i][col] == 0:
                pass
            else:
                k = - mat[i][col] / mat[row][col]
                for j in range(col ,n):
                    mat[i][j] += mat[row][j] * k
    return res

from numpy.random import rand, seed
from numpy.linalg import det

seed(100)
n = 5
A = rand(n ** 2)
mat = A.reshape(n, n)
print(det(mat), get_det(mat))
36/7:
def get_det(mat):
    mat = mat.astype('float')
    n = mat.shape[0]
    res = 1
    for col in range(n):
        row = col
        res *= mat[row][col]
        while mat[row][col] == 0 and row < n - 1:
            row += 1
        for i in range(row + 1, n):
            if mat[i][col] == 0:
                pass
            else:
                k = - mat[i][col] / mat[row][col]
                for j in range(col ,n):
                    mat[i][j] += mat[row][j] * k
    return res

from numpy.random import rand, seed
from numpy.linalg import det

seed(100)
n = 10
A = rand(n ** 2)
mat = A.reshape(n, n)
print(det(mat), get_det(mat))
36/8:
def make_rand_square_matrix(seed_,n):
    seed(seed_)
    A = rand(n ** 2)
    return A.reshape(n, n)
36/9:
Matrix = make_rand_square_matrix(100,10)
print(det(mat), get_det(mat))
36/10: Matrix = make_rand_square_matrix(100,10)
36/11: print(det(mat), get_det(mat))
36/12: det(1)
36/13: get_det(1)
36/14: A = np.array(1)
36/15: A
36/16: det(1)
36/17: det(A)
36/18: A.reshape(1)
36/19: A = A.reshape(1,1)
36/20: det(A)
36/21: get_det(A)
36/22:
def get_inverse_matrix(mat):
    mat = mat.astype('float')
    n = mat.shape[0]
    Inverse_matrix = np.zeros(n*n)
    Inverse_matrix.astype('float')
    for col in range(n):
        for row in range(n):
36/23:
def cof1(M,index):
    zs = M[:index[0]-1,:index[1]-1]
    ys = M[:index[0]-1,index[1]:]
    zx = M[index[0]:,:index[1]-1]
    yx = M[index[0]:,index[1]:]
    s = np.concatenate((zs,ys),axis=1)
    x = np.concatenate((zx,yx),axis=1)
    return det(np.concatenate((s,x),axis=0))
36/24:
def alcof(M,index):
    return pow(-1,index[0]+index[1])*cof(M,index)
36/25:
def invmat(M):
    if det(M)!=0:
        return 1/det(M)*adj(M)
    else:
        print("F")
36/26:
from numpy.linalg import inv
M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
print(inv(M))
print(invmat(M))
36/27:
def adj(M):
    result = np.zeros((M.shape[0],M.shape[1]))
    for i in range(1,M.shape[0]+1):
        for j in range(1,M.shape[1]+1):
            result[j-1][i-1] = alcof(copy.deepcopy(M),[i,j])
    return result
36/28:
def alcof(M,index):
    return pow(-1,index[0]+index[1])*cof(M,index)
36/29:
def cof1(M,index):
    zs = M[:index[0]-1,:index[1]-1]
    ys = M[:index[0]-1,index[1]:]
    zx = M[index[0]:,:index[1]-1]
    yx = M[index[0]:,index[1]:]
    s = np.concatenate((zs,ys),axis=1)
    x = np.concatenate((zx,yx),axis=1)
    return det(np.concatenate((s,x),axis=0))
36/30:
from numpy.linalg import inv
M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
print(inv(M))
print(invmat(M))
36/31:
import numpy as np
import copy
from numpy.linalg import inv
from numpy.linalg import inv
M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
print(inv(M))
print(invmat(M))
36/32:
import numpy as np
import copy
from numpy.linalg import inv
M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
print(inv(M))
print(invmat(M))
36/33:
def alcof(M,index):
    return pow(-1,index[0]+index[1])*cof1(M,index)
36/34:
import numpy as np
import copy
from numpy.linalg import inv
M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
print(inv(M))
print(invmat(M))
36/35:
import numpy as np
import copy
from numpy.linalg import inv
M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
36/36: Invmat(M)
36/37: invmat(M)
36/38:
def invmat(M):
    if det(M)!=0:
        return 1/get_det(M)*adj(M)
    else:
        print("F")
36/39:
import numpy as np
import copy
from numpy.linalg import inv
M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
36/40: invmat(M)
37/1:
import numpy as np
from numpy.random import rand, seed
from func import *
37/2: M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
37/3: get_inv(M)
37/4:
import numpy as np
from numpy.random import rand, seed
from func import *
37/5: M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
37/6: get_inv(M)
37/7:
import numpy as np
from numpy.random import rand, seed
from func import *
37/8: M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
37/9: get_inv(M)
37/10:
import numpy as np
from numpy.random import rand, seed
from func import *
37/11: M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
37/12: get_inv(M)
37/13: get_inv(M)
37/14: get_inv(M)
38/1:
import numpy as np
from numpy.random import rand, seed
from func import *
38/2: M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
38/3: get_inv(M)
39/1:
import numpy as np
from numpy.random import rand, seed
from func import *
39/2: M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
39/3: get_inv(M)
41/1:
import numpy as np
from numpy.random import rand, seed
from func import *
41/2: M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
41/3: get_inv(M)
41/4: get_inv(M)
41/5: #The inverse method
41/6: #The inverse method
41/7: inv(M)
41/8:
from numpy.linalg import inv
inv(M)
41/9: K = make_rand_square_matrixa(100,5)
41/10: K = make_rand_square_matrix(100,5)
41/11:
K = make_rand_square_matrix(100,5)
get_inv(K)
inv(K)
41/12: inv(K)
41/13:
K = make_rand_square_matrix(100,5)
get_inv(K)
41/14: inv(K)
41/15:
"""
The inverse method
x=A^(-1)b
"""
def Inverse_method_solve(A,b):
    return inv*b
41/16: M*np.array([1,2,3,4])
41/17: M*np.array([1,2,3])
41/18: M*(np.array([1,2,3])).T
41/19: M*(np.array([1,2,3]))
41/20: M
41/21: M*[1,2,3]
41/22: b = np.array([1,2,3])
41/23: b
41/24: M*b
41/25: M*(b.T)
41/26: b.T
41/27: b = np.array([1,2,3]).reshape(1,3)
41/28: b
41/29: M*b
41/30: b.T
41/31: b = np.array([1,2,3]).reshape(3,1)
41/32: b
41/33: M*b
41/34: np.dot(M,b)
41/35: b = np.array([1,2,3])
41/36: np.dot(M,b)
41/37: np.dot(get_inv(A),b)
41/38: np.dot(get_inv(M),b)
41/39: b = np.array([1,2,3])
41/40:
#The inverse method
np.dot(M,b)
41/41: b = np.array([2,20,11])
41/42: np.dot(get_inv(M),b)
41/43:
#The inverse method
Inverse_method_solve(M,b)
41/44:
"""
The inverse method
x=A^(-1)b
"""
def Inverse_method_solve(A,b):
    return np.dot(get_inv(A),b)
41/45:
#The inverse method
Inverse_method_solve(M,b)
41/46:
#The inverse method
b.shape[0]
41/47:
#The inverse method
b.shape
41/48: M
41/49: M[0]
41/50: M[:index[0]-1,:index[1]-1]
41/51:
index = 1
M[:index[0]-1,:index[1]-1]
41/52:
index = 2
M[:index[0]-1,:index[1]-1]
41/53:
index = 1
M[:index-1,:index-1]
41/54:
index = 1
M[:index0,:index-1]
41/55: M
41/56: M[:,0]
41/57: M[:,2]
41/58: M[:,1]
41/59: M[:,1]=b
41/60:
M[:,1]=b
M
41/61: M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
41/62:
def replace_colum(A,index,b):
    A[:,index] = b
    return A
41/63: replace_colum(M,1,b)
41/64: M
41/65: import copy
41/66: M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
41/67: replace_colum(copy.deepcopy(M),1,b)
41/68: M
41/69: replace_colum(copy.deepcopy(M),1,b)
41/70:
def replace_colum(A,index,b):
    A[:,index] = b
    return A
41/71: replace_colum(copy.deepcopy(M),1,b)
41/72: M
41/73: replace_colum(M,1,b)
41/74: M
41/75:
def replace_colum(copy.deepcopy(A),index,b):
    A[:,index] = b
    return A
41/76:
def Cramer_rule_solve(A,b):
    F = get_det(A)
    X = np.zeros(b.shape[0])
    for i in range(b.shape[0]):
        X[i] = get_det(replace_colum(copy.deepcopy(M),i,b))/F
    return F
41/77: Cramer_rule_solve(A,b)
41/78: Cramer_rule_solve(M,b)
41/79:
def Cramer_rule_solve(A,b):
    F = get_det(A)
    X = np.zeros(b.shape[0])
    for i in range(b.shape[0]):
        X[i] = get_det(replace_colum(copy.deepcopy(M),i,b))/F
    return X
41/80: Cramer_rule_solve(M,b)
41/81: M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
41/82: b
41/83:
def Cramer_rule_solve(A,b):
    F = get_det(A)
    X = np.zeros(b.shape[0])
    for i in range(b.shape[0]):
        X[i] = get_det(replace_colum(copy.deepcopy(M),i,b))/F
    return X
41/84: Cramer_rule_solve(M,b)
41/85:
def replace_colum(A,index,b):
    A[:,index] = b
    return A
41/86: Inverse_method_solve(M,b)
41/87:
def elimination(matrix):
    row = mat.shape[0]
    #a_ii^(i-1) noeql 0
    for i in range(row):
        if not matrix[i, i]:
            for j in range(i + 1, row):
                if matrix[j, i]:
                    matrix[[i, j], :] = matrix[[j,i], :]
                    break
                
    # elimination
    for i in range(0, row - 1):
        for j in range(i + 1, row):
            matrix[j, :] = matrix[j, :] - matrix[i, :]/matrix[i, i]*matrix[j,i]
          
    return matrix


def back substitution(matrix):
    row = matrix.shape[0]
    for i in range(row - 2, -1, -1):
        for j in range(i + 1, row):
            matrix[i, :] = matrix[i, :] - matrix[j, :]/matrix[j, j]*matrix[i,j]
            
    return matrix

def Gaussian(matrix):
    return back substitution(elimination(matrix))
41/88:
def elimination(matrix):
    row = mat.shape[0]
    #a_ii^(i-1) noeql 0
    for i in range(row):
        if not matrix[i, i]:
            for j in range(i + 1, row):
                if matrix[j, i]:
                    matrix[[i, j], :] = matrix[[j,i], :]
                    break
                
    # elimination
    for i in range(0, row - 1):
        for j in range(i + 1, row):
            matrix[j, :] = matrix[j, :] - matrix[i, :]/matrix[i, i]*matrix[j,i]
          
    return matrix


def back substitution(matrix):
    row = matrix.shape[0]
    for i in range(row - 2, -1, -1):
        for j in range(i + 1, row):
            matrix[i, :] = matrix[i, :] - matrix[j, :]/matrix[j, j]*matrix[i,j]
            
    return matrix

def Gaussian(matrix):
    return back_substitution(elimination(matrix))
41/89:
def elimination(matrix):
    row = mat.shape[0]
    #a_ii^(i-1) noeql 0
    for i in range(row):
        if not matrix[i, i]:
            for j in range(i + 1, row):
                if matrix[j, i]:
                    matrix[[i, j], :] = matrix[[j,i], :]
                    break
                
    # elimination
    for i in range(0, row - 1):
        for j in range(i + 1, row):
            matrix[j, :] = matrix[j, :] - matrix[i, :]/matrix[i, i]*matrix[j,i]
          
    return matrix


def back_substitution(matrix):
    row = matrix.shape[0]
    for i in range(row - 2, -1, -1):
        for j in range(i + 1, row):
            matrix[i, :] = matrix[i, :] - matrix[j, :]/matrix[j, j]*matrix[i,j]
            
    return matrix

def Gaussian(matrix):
    return back_substitution(elimination(matrix))
41/90: np.concatenate(A,b)
41/91: np.concatenate(M,b)
41/92: np.concatenate(M,b.T)
41/93: M
41/94: T
41/95: b
41/96: M.astype('float')
41/97: b.astype("float")
41/98: np.concatenate(M,b.T)
41/99: np.concatenate(M,b)
41/100: M
41/101:
M = M.astype('float')
b = b.astype("float")
41/102: np.concatenate(M,b)
41/103: M
41/104: np.concatenate((M,b))
41/105: np.concatenate((M,b),axis = 1)
41/106: np.concatenate((M,b.T),axis = 1)
41/107: b = np.array([2,20,11])
41/108: M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
41/109: np.concatenate((M,b),axis = 1)
41/110: b
41/111: b.reshape(1,3)
41/112: c = b.reshape(1,3)
41/113: np.concatenate((M,c),axis = 1)
41/114: np.concatenate((M,c))
41/115: np.concatenate((M,c.T))
41/116: c
41/117: c = b.reshape(3,1)
41/118: c
41/119: np.concatenate((M,c), axis=1)
41/120:
def elimination(matrix):
    row = mat.shape[0]
    #a_ii^(i-1) noeql 0
    for i in range(row):
        if not matrix[i, i]:
            for j in range(i + 1, row):
                if matrix[j, i]:
                    matrix[[i, j], :] = matrix[[j,i], :]
                    break
                
    # elimination
    for i in range(0, row - 1):
        for j in range(i + 1, row):
            matrix[j, :] = matrix[j, :] - matrix[i, :]/matrix[i, i]*matrix[j,i]
          
    return matrix


def back_substitution(matrix):
    row = matrix.shape[0]
    for i in range(row - 2, -1, -1):
        for j in range(i + 1, row):
            matrix[i, :] = matrix[i, :] - matrix[j, :]/matrix[j, j]*matrix[i,j]
            
    return matrix

def Gaussian(mat,b):
    c = b.reshape(b.shape[0],1)
    np.concatenate((M,c), axis=1)
    return back_substitution(elimination(matrix))
41/121: Gaussian(A,b)
41/122: Gaussian(M,b)
41/123:
def elimination(matrix):
    row = mat.shape[0]
    #a_ii^(i-1) noeql 0
    for i in range(row):
        if not matrix[i, i]:
            for j in range(i + 1, row):
                if matrix[j, i]:
                    matrix[[i, j], :] = matrix[[j,i], :]
                    break
                
    # elimination
    for i in range(0, row - 1):
        for j in range(i + 1, row):
            matrix[j, :] = matrix[j, :] - matrix[i, :]/matrix[i, i]*matrix[j,i]
          
    return matrix


def back_substitution(matrix):
    row = matrix.shape[0]
    for i in range(row - 2, -1, -1):
        for j in range(i + 1, row):
            matrix[i, :] = matrix[i, :] - matrix[j, :]/matrix[j, j]*matrix[i,j]
            
    return matrix

def Gaussian(mat,b):
    c = b.reshape(b.shape[0],1)
    np.concatenate((M,c), axis=1)
    return back_substitution(elimination(mat))
41/124: Gaussian(M,b)
41/125:
def elimination(matrix):
    row = matrix.shape[0]
    #a_ii^(i-1) noeql 0
    for i in range(row):
        if not matrix[i, i]:
            for j in range(i + 1, row):
                if matrix[j, i]:
                    matrix[[i, j], :] = matrix[[j,i], :]
                    break
                
    # elimination
    for i in range(0, row - 1):
        for j in range(i + 1, row):
            matrix[j, :] = matrix[j, :] - matrix[i, :]/matrix[i, i]*matrix[j,i]
          
    return matrix


def back_substitution(matrix):
    row = matrix.shape[0]
    for i in range(row - 2, -1, -1):
        for j in range(i + 1, row):
            matrix[i, :] = matrix[i, :] - matrix[j, :]/matrix[j, j]*matrix[i,j]
            
    return matrix

def Gaussian(mat,b):
    c = b.reshape(b.shape[0],1)
    np.concatenate((M,c), axis=1)
    return back_substitution(elimination(mat))
41/126:
def elimination(matrix):
    row = matrix.shape[0]
    #a_ii^(i-1) noeql 0
    for i in range(row):
        if not matrix[i, i]:
            for j in range(i + 1, row):
                if matrix[j, i]:
                    matrix[[i, j], :] = matrix[[j,i], :]
                    break
                
    # elimination
    for i in range(0, row - 1):
        for j in range(i + 1, row):
            matrix[j, :] = matrix[j, :] - matrix[i, :]/matrix[i, i]*matrix[j,i]
          
    return matrix


def back_substitution(matrix):
    row = matrix.shape[0]
    for i in range(row - 2, -1, -1):
        for j in range(i + 1, row):
            matrix[i, :] = matrix[i, :] - matrix[j, :]/matrix[j, j]*matrix[i,j]
            
    return matrix

def Gaussian(mat,b):
    c = b.reshape(b.shape[0],1)
    np.concatenate((M,c), axis=1)
    return back_substitution(elimination(mat))
41/127: np.concatenate((M,c), axis=1)
41/128: Gaussian(M,b)
41/129: M
41/130: M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
41/131: M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
41/132:
def elimination(matrix):
    row = matrix.shape[0]
    #a_ii^(i-1) noeql 0
    for i in range(row):
        if not matrix[i, i]:
            for j in range(i + 1, row):
                if matrix[j, i]:
                    matrix[[i, j], :] = matrix[[j,i], :]
                    break
                
    # elimination
    for i in range(0, row - 1):
        for j in range(i + 1, row):
            matrix[j, :] = matrix[j, :] - matrix[i, :]/matrix[i, i]*matrix[j,i]
          
    return matrix


def back_substitution(matrix):
    row = matrix.shape[0]
    for i in range(row - 2, -1, -1):
        for j in range(i + 1, row):
            matrix[i, :] = matrix[i, :] - matrix[j, :]/matrix[j, j]*matrix[i,j]
            
    return matrix

def Gaussian(mat,b):
    c = copy.deepcopy(b.reshape(b.shape[0],1))
    np.concatenate((copy.deepcopy(M),c), axis=1)
    return back_substitution(elimination(mat))
41/133: M
41/134: b
41/135: c = b.reshape(3,1)
41/136: np.concatenate((M,c), axis=1)
41/137: Gaussian(M,b)
42/1:
import numpy as np
from numpy.random import rand, seed
import copy
from func import *
from numpy.linalg import inv
42/2: M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
42/3:
def Inverse_method_solve(A,b):
    return np.dot(get_inv(A),b)
42/4: Inverse_method_solve(M,b)
42/5:
Inverse_method_solve(M,b)
b = np.array([2,20,11])
42/6:
M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
b = np.array([2,20,11])
42/7:
def Inverse_method_solve(A,b):
    return np.dot(get_inv(A),b)
42/8: Inverse_method_solve(M,b)
42/9:
def Cramer_rule_solve(A,b):
    F = get_det(A)
    X = np.zeros(b.shape[0])
    for i in range(b.shape[0]):
        X[i] = get_det(replace_colum(copy.deepcopy(M),i,b))/F
    return X
42/10: Cramer_rule_solve(M,b)
42/11:
def elimination(matrix):
    row = matrix.shape[0]
    #a_ii^(i-1) noeql 0
    for i in range(row):
        if not matrix[i, i]:
            for j in range(i + 1, row):
                if matrix[j, i]:
                    matrix[[i, j], :] = matrix[[j,i], :]
                    break
                
    # elimination
    for i in range(0, row - 1):
        for j in range(i + 1, row):
            matrix[j, :] = matrix[j, :] - matrix[i, :]/matrix[i, i]*matrix[j,i]
          
    return matrix


def back_substitution(matrix):
    row = matrix.shape[0]
    for i in range(row - 2, -1, -1):
        for j in range(i + 1, row):
            matrix[i, :] = matrix[i, :] - matrix[j, :]/matrix[j, j]*matrix[i,j]
            
    return matrix

def Gaussian(mat,b):
    c = copy.deepcopy(b.reshape(b.shape[0],1))
    np.concatenate((copy.deepcopy(M),c), axis=1)
    return back_substitution(elimination(mat))
42/12: Gaussian(M,b)
42/13:
def gaussElimination(matrix):
    np.asarray(matrix) #ensure the array
    matrix = matrix.astype(float) #ensure the datatype is float
    print "the initial matrix:"
    print matrix
    if matrix[0,0] == 0.0:
        raise Exception("matrix row 1 column 1 cannot be zero!")
    n,m = matrix.shape
    print "row:",n,"column:",m
    #start the elimination phase
    for i in range(0,n):#row
        for j in range(i+1,n):
            if matrix[j,i] != 0.0:
                print "using row ",i,"as pivot and row ",j,"as target"
                multiplier = matrix[j,i]/matrix[i,i]
                #print matrix[i,k],matrix[k,k],multiplier 
                #just to verbose multiplier process
                matrix[j,i:m]=matrix[j,i:m] - multiplier*matrix[i,i:m] 
                print matrix
                
    #start the backsubstitution phase
    x = []
    substractor = 0.0
    for i in range(n-1,-1,-1): #row
        #print "i",i #just for debugging
        for j in range(0,n-i): #column
            #print "j",j #just for debugging
            if j==0:
                substractor = 0
            else:
                substractor = substractor + matrix[i,m-j-1]*x[j-1]
        x.append((matrix[i,m-1]-substractor)/matrix[i,i])
        #print "x",x
    return x
42/14:
def gaussElimination(matrix):
    np.asarray(matrix) #ensure the array
    matrix = matrix.astype(float) #ensure the datatype is float
    n,m = matrix.shape
    #start the elimination phase
    for i in range(0,n):#row
        for j in range(i+1,n):
            if matrix[j,i] != 0.0:
                multiplier = matrix[j,i]/matrix[i,i]
                #print matrix[i,k],matrix[k,k],multiplier 
                #just to verbose multiplier process
                matrix[j,i:m]=matrix[j,i:m] - multiplier*matrix[i,i:m] 
                print matrix
                
    #start the backsubstitution phase
    x = []
    substractor = 0.0
    for i in range(n-1,-1,-1): #row
        #print "i",i #just for debugging
        for j in range(0,n-i): #column
            #print "j",j #just for debugging
            if j==0:
                substractor = 0
            else:
                substractor = substractor + matrix[i,m-j-1]*x[j-1]
        x.append((matrix[i,m-1]-substractor)/matrix[i,i])
        #print "x",x
    return x
42/15:
def gaussElimination(matrix):
    np.asarray(matrix) #ensure the array
    matrix = matrix.astype(float) #ensure the datatype is float
    n,m = matrix.shape
    for i in range(0,n):#row
        for j in range(i+1,n):
            if matrix[j,i] != 0.0:
                multiplier = matrix[j,i]/matrix[i,i]
                #print matrix[i,k],matrix[k,k],multiplier 
                #just to verbose multiplier process
                matrix[j,i:m]=matrix[j,i:m] - multiplier*matrix[i,i:m] 
                
    #start the backsubstitution phase
    x = []
    substractor = 0.0
    for i in range(n-1,-1,-1): #row
        #print "i",i #just for debugging
        for j in range(0,n-i): #column
            #print "j",j #just for debugging
            if j==0:
                substractor = 0
            else:
                substractor = substractor + matrix[i,m-j-1]*x[j-1]
        x.append((matrix[i,m-1]-substractor)/matrix[i,i])
        #print "x",x
    return x
42/16:
def elimination(matrix):
    row = matrix.shape[0]
    #a_ii^(i-1) noeql 0
    for i in range(row):
        if not matrix[i, i]:
            for j in range(i + 1, row):
                if matrix[j, i]:
                    matrix[[i, j], :] = matrix[[j,i], :]
                    break
                
    # elimination
    for i in range(0, row - 1):
        for j in range(i + 1, row):
            matrix[j, :] = matrix[j, :] - matrix[i, :]/matrix[i, i]*matrix[j,i]
          
    return matrix


def back_substitution(matrix):
    row = matrix.shape[0]
    for i in range(row - 2, -1, -1):
        for j in range(i + 1, row):
            matrix[i, :] = matrix[i, :] - matrix[j, :]/matrix[j, j]*matrix[i,j]
            
    return matrix

def Gaussian(mat,b):
    c = copy.deepcopy(b.reshape(b.shape[0],1))
    np.concatenate((copy.deepcopy(mat),c), axis=1)
    return back_substitution(elimination(mat))
42/17: Gaussian(M,b)
42/18: M
42/19:
M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
b = np.array([2,20,11])
42/20:
def Inverse_method_solve(A,b):
    return np.dot(get_inv(A),b)
42/21: Inverse_method_solve(M,b)
42/22: Gaussian(M,b)
42/23:
def gaussElimination(mat,b):
    c = copy.deepcopy(b.reshape(b.shape[0],1))
    matrix = np.concatenate((copy.deepcopy(mat),c), axis=1)
    matrix = matrix.astype(float)
    n,m = matrix.shape
    for i in range(0,n):#row
        for j in range(i+1,n):
            if matrix[j,i] != 0.0:
                multiplier = matrix[j,i]/matrix[i,i]
                #print matrix[i,k],matrix[k,k],multiplier 
                #just to verbose multiplier process
                matrix[j,i:m]=matrix[j,i:m] - multiplier*matrix[i,i:m] 
                
    #start the backsubstitution phase
    x = []
    substractor = 0.0
    for i in range(n-1,-1,-1): #row
        #print "i",i #just for debugging
        for j in range(0,n-i): #column
            #print "j",j #just for debugging
            if j==0:
                substractor = 0
            else:
                substractor = substractor + matrix[i,m-j-1]*x[j-1]
        x.append((matrix[i,m-1]-substractor)/matrix[i,i])
        #print "x",x
    return x
42/24: gaussElimination(M,b)
42/25: M
42/26:
M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
b = np.array([2,20,11])
42/27: gaussElimination(M,b)
42/28:
def LUDecompose(table):
    # Table that contains our data
    # Table has to be a square array so we need to check first
    rows, columns = numpy.shape(table)
    L = numpy.zeros((rows, columns))
    U = numpy.zeros((rows, columns))
    if rows != columns:
        return []
    for i in range(columns):
        for j in range(i):
            sum = 0
            for k in range(j):
                sum += L[i][k] * U[k][j]
            L[i][j] = (table[i][j] - sum) / U[j][j]
        L[i][i] = 1
        for j in range(i, columns):
            sum1 = 0
            for k in range(i):
                sum1 += L[i][k] * U[k][j]
            U[i][j] = table[i][j] - sum1
    return L, U
42/29: LUDecompose(M)
42/30:
def LUDecompose(table):
    # Table that contains our data
    # Table has to be a square array so we need to check first
    rows, columns = numpy.shape(table)
    L = np.zeros((rows, columns))
    U = np.zeros((rows, columns))
    if rows != columns:
        return []
    for i in range(columns):
        for j in range(i):
            sum = 0
            for k in range(j):
                sum += L[i][k] * U[k][j]
            L[i][j] = (table[i][j] - sum) / U[j][j]
        L[i][i] = 1
        for j in range(i, columns):
            sum1 = 0
            for k in range(i):
                sum1 += L[i][k] * U[k][j]
            U[i][j] = table[i][j] - sum1
    return L, U
42/31: LUDecompose(M)
42/32:
def LUDecompose(table):
    # Table that contains our data
    # Table has to be a square array so we need to check first
    rows, columns = np.shape(table)
    L = np.zeros((rows, columns))
    U = np.zeros((rows, columns))
    if rows != columns:
        return []
    for i in range(columns):
        for j in range(i):
            sum = 0
            for k in range(j):
                sum += L[i][k] * U[k][j]
            L[i][j] = (table[i][j] - sum) / U[j][j]
        L[i][i] = 1
        for j in range(i, columns):
            sum1 = 0
            for k in range(i):
                sum1 += L[i][k] * U[k][j]
            U[i][j] = table[i][j] - sum1
    return L, U
42/33: LUDecompose(M)
42/34:
def LUDecompose(mat):
    rows, columns = mat.shape
    L = np.zeros((rows, columns))
    U = np.zeros((rows, columns))
    for i in range(columns):
        for j in range(i):
            sum = 0
            for k in range(j):
                sum += L[i][k] * U[k][j]
            L[i][j] = (mat[i][j] - sum) / U[j][j]
        L[i][i] = 1
        for j in range(i, columns):
            sum1 = 0
            for k in range(i):
                sum1 += L[i][k] * U[k][j]
            U[i][j] = mat[i][j] - sum1
    return L, U
42/35: LUDecompose(M)
42/36: LU_decompose(M)
42/37:
def LU_decompose(mat):
    rows, columns = mat.shape
    L = np.zeros((rows, columns))
    U = np.zeros((rows, columns))
    for i in range(columns):
        for j in range(i):
            sum = 0
            for k in range(j):
                sum += L[i][k] * U[k][j]
            L[i][j] = (mat[i][j] - sum) / U[j][j]
        L[i][i] = 1
        for j in range(i, columns):
            sum1 = 0
            for k in range(i):
                sum1 += L[i][k] * U[k][j]
            U[i][j] = mat[i][j] - sum1
    return L, U
42/38: LU_decompose(M)
42/39: L,U = LU_decompose(M)
42/40: np.product(L,U)
42/41: L
42/42: L*U
42/43: L
42/44:
import numpy as np


def LU(A):
    '''
    生成值全位0的U矩阵，和单位矩阵L
    '''
    L = np.eye(len(A))
    U = np.zeros(np.shape(A))
    for r in range(1, len(A)):  # 求U的第一行和L的第一列
        U[0, r - 1] = A[0, r - 1]
        L[r, 0] = A[r, 0] / A[0, 0]
    U[0, -1] = A[0, -1]
    for r in range(1, len(A)):  # 先求U再求L
        for i in range(r, len(A)):
            delta = 0
            for k in range(0, r):  # 求∑(???∗???)
                delta += L[r, k] * U[k, i]
            U[r, i] = A[r, i] - delta

            for i in range(r + 1, len(A)):  # 求L矩阵
                theta = 0
                for k in range(0, r):  # 求∑(?i?∗??r)
                    theta += L[i, k] * U[k, r]
                L[i, r] = (A[i, r] - theta) / U[r, r]
    return L,U
def my_LUsolve(A,b):
    L, U = LU(A) # 得到L和U
    '''print("L={}".format(L))
    print("U={}".format(U))'''
    # 求解线性方程LY=b
    n = len(A)
    y = np.zeros((n, 1))
    b = np.array(b).reshape(n,1) # 把b列表格式变成向量格式
    for i in range(len(A)):
        t = 0
        for j in range(i):
            t += L[i][j]* y[j][0]
        y[i][0] = b[i][0] - t
    # print("y={}".format(y))
    # 求解UX=Y
    X = np.zeros((n, 1))
    for i in range(len(A)-1,-1,-1):
        t = 0
        for j in range(i+1,len(A)):
            t += U[i][j]*X[j][0]
        t = y[i][0] - t
        if t != 0 and U[i][i] == 0:
            return 0
        X[i] = t/U[i][i]
    # print("X={}".format(X))
    return X
42/45: my_LUsolve(M,b)
42/46: L = np.eye(3)
42/47: L
42/48:
def LU_decompose(A):
    L = np.eye(len(A))
    U = np.zeros(A.shape)
    for r in range(1, len(A)): 
        U[0, r - 1] = A[0, r - 1]
        L[r, 0] = A[r, 0] / A[0, 0]
    U[0, -1] = A[0, -1]
    for r in range(1, len(A)):
        for i in range(r, len(A)):
            delta = 0
            for k in range(0, r):
                delta += L[r, k] * U[k, i]
            U[r, i] = A[r, i] - delta

            for i in range(r + 1, len(A)): 
                theta = 0
                for k in range(0, r):  
                    theta += L[i, k] * U[k, r]
                L[i, r] = (A[i, r] - theta) / U[r, r]
    return L,U
def my_LUsolve(A,b):
    L, U = LU(A)
    n = len(A)
    y = np.zeros((n, 1))
    b = np.array(b).reshape(n,1) 
    for i in range(len(A)):
        t = 0
        for j in range(i):
            t += L[i][j]* y[j][0]
        y[i][0] = b[i][0] - t
    X = np.zeros((n, 1))
    for i in range(len(A)-1,-1,-1):
        t = 0
        for j in range(i+1,len(A)):
            t += U[i][j]*X[j][0]
        t = y[i][0] - t
        if t != 0 and U[i][i] == 0:
            return 0
        X[i] = t/U[i][i]
    # print("X={}".format(X))
    return X
42/49:
def LU_decompose(A):
    L = np.eye(len(A))
    U = np.zeros(A.shape)
    for r in range(1, len(A)): 
        U[0, r - 1] = A[0, r - 1]
        L[r, 0] = A[r, 0] / A[0, 0]
    U[0, -1] = A[0, -1]
    for r in range(1, len(A)):
        for i in range(r, len(A)):
            delta = 0
            for k in range(0, r):
                delta += L[r, k] * U[k, i]
            U[r, i] = A[r, i] - delta

            for i in range(r + 1, len(A)): 
                theta = 0
                for k in range(0, r):  
                    theta += L[i, k] * U[k, r]
                L[i, r] = (A[i, r] - theta) / U[r, r]
    return L,U
def my_LUsolve(A,b):
    L, U = LU_decompose(A)
    n = len(A)
    y = np.zeros((n, 1))
    b = np.array(b).reshape(n,1) 
    for i in range(len(A)):
        t = 0
        for j in range(i):
            t += L[i][j]* y[j][0]
        y[i][0] = b[i][0] - t
    X = np.zeros((n, 1))
    for i in range(len(A)-1,-1,-1):
        t = 0
        for j in range(i+1,len(A)):
            t += U[i][j]*X[j][0]
        t = y[i][0] - t
        if t != 0 and U[i][i] == 0:
            return 0
        X[i] = t/U[i][i]
    # print("X={}".format(X))
    return X
42/50: my_LUsolve(M,b)
42/51: LU_decompose(M)
42/52: L,U = LU_decompose(M)
42/53: np.product(L,U)
42/54: np.multiply(L,U)
42/55:
M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
b = np.array([2,20,11])
42/56: L,U = LU_decompose(M)
42/57: np.multiply(L,U)
42/58: L
42/59: M
42/60: my_LUsolve(M,b)
42/61:
def LU_decompose(A):
    L = np.eye(len(A))
    U = np.zeros(A.shape)
    for r in range(1, len(A)): 
        U[0, r - 1] = A[0, r - 1]
        L[r, 0] = A[r, 0] / A[0, 0]
    U[0, -1] = A[0, -1]
    for r in range(1, len(A)):
        for i in range(r, len(A)):
            delta = 0
            for k in range(0, r):
                delta += L[r, k] * U[k, i]
            U[r, i] = A[r, i] - delta

            for i in range(r + 1, len(A)): 
                theta = 0
                for k in range(0, r):  
                    theta += L[i, k] * U[k, r]
                L[i, r] = (A[i, r] - theta) / U[r, r]
    return L,U
def LUsolve(A,b):
    L, U = LU_decompose(A)
    n = len(A)
    y = np.zeros((n, 1))
    b = np.array(b).reshape(n,1) 
    for i in range(len(A)):
        t = 0
        for j in range(i):
            t += L[i][j]* y[j][0]
        y[i][0] = b[i][0] - t
    X = np.zeros((n, 1))
    for i in range(len(A)-1,-1,-1):
        t = 0
        for j in range(i+1,len(A)):
            t += U[i][j]*X[j][0]
        t = y[i][0] - t
        X[i] = t/U[i][i]
    return X
42/62: LUsolve(M,b)
42/63:
def GaussElimination(mat,b):
    c = copy.deepcopy(b.reshape(b.shape[0],1))
    matrix = np.concatenate((copy.deepcopy(mat),c), axis=1)
    matrix = matrix.astype(float)
    n,m = matrix.shape
    for i in range(0,n):#row
        for j in range(i+1,n):
            if matrix[j,i] != 0.0:
                multiplier = matrix[j,i]/matrix[i,i]
                matrix[j,i:m]=matrix[j,i:m] - multiplier*matrix[i,i:m] 
    x = []
    substractor = 0.0
    for i in range(n-1,-1,-1): #row
        for j in range(0,n-i): #column
            if j==0:
                substractor = 0
            else:
                substractor = substractor + matrix[i,m-j-1]*x[j-1]
        x.append((matrix[i,m-1]-substractor)/matrix[i,i])
    return x
42/64: GaussElimination(M,b)
42/65:
def LU_decompose(A):
    L = np.eye(len(A))
    U = np.zeros(A.shape)
    for r in range(1, len(A)): 
        U[0, r - 1] = A[0, r - 1]
        L[r, 0] = A[r, 0] / A[0, 0]
    U[0, -1] = A[0, -1]
    for r in range(1, len(A)):
        for i in range(r, len(A)):
            delta = 0
            for k in range(0, r):
                delta += L[r, k] * U[k, i]
            U[r, i] = A[r, i] - delta

            for i in range(r + 1, len(A)): 
                theta = 0
                for k in range(0, r):  
                    theta += L[i, k] * U[k, r]
                L[i, r] = (A[i, r] - theta) / U[r, r]
    return L,U
def LUsolve(A,b):
    L, U = LU_decompose(A)
    n = len(A)
    y = np.zeros((n, 1))
    b = np.array(b).reshape(n,1) 
    for i in range(len(A)):
        t = 0
        for j in range(i):
            t += L[i][j]* y[j][0]
        y[i][0] = b[i][0] - t
    X = np.zeros((n, 1))
    for i in range(len(A)-1,-1,-1):
        t = 0
        for j in range(i+1,len(A)):
            t += U[i][j]*X[j][0]
        t = y[i][0] - t
        X[i] = t/U[i][i]
    return X
42/66: def test_time_cost():
42/67:
def test_time_cost():
    N = [i*5 for i in range(20)]:
42/68:
def test_time_cost():
    N = [i*5 for i in range(20)]
    return make_rand_square_matrix(N)
42/69:
def test_time_cost():
    N = [i*5 for i in range(20)]
    return make_rand_square_matrix(N[0])
42/70: test_time_cost
42/71:
def test_time_cost():
    N = [i*5 for i in range(20)]
    print(make_rand_square_matrix(N[0]))
    return make_rand_square_matrix(N[0])
42/72: test_time_cost
42/73:  print(make_rand_square_matrix(5))
42/74: make_rand_square_matrix(5)
42/75: make_rand_square_matrix(100,5)
42/76:
import numpy as np
from numpy.random import rand, seed
import copy
from func import *
from numpy.linalg import inv
42/77:
def make_rand_square_matrix(n):
    A =rand(n ** 2)
    A = np.floor(A*100)
    return A.reshape(n, n)
def test_time_cost():
    N = [i*5 for i in range(20)]
    Data = [make_rand_square_matrix()]
    return make_rand_square_matrix(N[0])
42/78:
def make_rand_square_matrix(n):
    A =rand(n ** 2)
    A = np.floor(A*100)
    return A.reshape(n, n)
42/79: N = [i*5 for i in range(20)]
42/80: make_rand_square_matrix(5)
42/81:
def make_rand_square_matrix(n):
    A =rand(n ** 2)
    A = np.floor(A*100)
    return A.reshape(n, n)
42/82: make_rand_square_matrix(5)
42/83: A = make_rand_square_matrix(5)
42/84:
x = np.array([i+1 for i in range(n)])
b = np.multiply(A,x)
42/85:
n = 5
x = np.array([i+1 for i in range(n)])
b = np.multiply(A,x)
42/86: x
42/87: b
42/88: GaussElimination(A,b)
42/89: A
42/90: b
42/91: b
42/92:
n = 5
x = np.array([i+1 for i in range(n)])
42/93: x
42/94: x.reshape(1,5)
42/95: x.reshape(5,1)
42/96: np.multiply(A,x)
42/97: x = x.reshape(5,1)
42/98: np.multiply(A,x)
42/99: x
42/100: x = x.reshape(1,5)
42/101: x
42/102: np.multiply(A,x)
42/103: np.dot(A,x)
42/104: x = x.reshape(5,1)
42/105: x
42/106: np.dot(A,x)
42/107: b = np.dot(A,x)
42/108: GaussElimination(A,b)
42/109:
N = [i*5 for i in range(20)]
Mats = []
bs = []
for n in N:
    A = make_rand_square_matrix(n)
    x = np.array([i+1 for i in range(n)])
    x = x.reshape(n,1)
    b = np.dot(A,x)
    Mats.append(A)
    bs.append(b)
42/110: bs[0]
42/111: bs[1]
42/112: bs[2]
42/113: bs[3]
42/114: bs[0]
42/115:
N = [i*5 for i in range(1,20)]
Mats = []
bs = []
for n in N:
    A = make_rand_square_matrix(n)
    x = np.array([i+1 for i in range(n)])
    x = x.reshape(n,1)
    b = np.dot(A,x)
    Mats.append(A)
    bs.append(b)
42/116:
import time
def cost(func):
    start = time.clock()
    Times = []
    for i in range(len(Mats)):
42/117:
import time
def cost(func):
    start = time.clock()
    Times = []
    for i in range(len(Mats)):
        func(Mats[i],bs[i])
        Times.append(time.clock()-start)
    return Times
42/118: cost(GaussElimination)
42/119:
import time
def cost(func):
    start = time.process_time()
    Times = []
    for i in range(len(Mats)):
        func(Mats[i],bs[i])
        Times.append(time.process_time()-start)
    return Times
42/120: cost(GaussElimination)
42/121:
N = [i*5 for i in range(1,100)]
Mats = []
bs = []
for n in N:
    A = make_rand_square_matrix(n)
    x = np.array([i+1 for i in range(n)])
    x = x.reshape(n,1)
    b = np.dot(A,x)
    Mats.append(A)
    bs.append(b)
42/122:
N = [i for i in range(1,300)]
Mats = []
bs = []
for n in N:
    A = make_rand_square_matrix(n)
    x = np.array([i+1 for i in range(n)])
    x = x.reshape(n,1)
    b = np.dot(A,x)
    Mats.append(A)
    bs.append(b)
42/123: Gauss =cost(GaussElimination)
42/124:
N = [i for i in range(1,100)]
Mats = []
bs = []
for n in N:
    A = make_rand_square_matrix(n)
    x = np.array([i+1 for i in range(n)])
    x = x.reshape(n,1)
    b = np.dot(A,x)
    Mats.append(A)
    bs.append(b)
42/125:
import time
def cost(func):
    start = time.process_time()
    Times = []
    for i in range(len(Mats)):
        func(Mats[i],bs[i])
        Times.append(time.process_time()-start)
    return Times
42/126: Gauss = cost(GaussElimination)
42/127: import pyplot as plt
42/128: import matplotlib.pyplot as plt
42/129: plt.plot(Gauss)
42/130:
Gauss = cost(GaussElimination)
LU = cost(LUsolve)
Inver = cost(Inverse_method_solve)
Cra = cost(Cramer_rule_solve)
42/131:
import numpy as np
from numpy.random import rand, seed
import copy
from func import *
from numpy.linalg import inv
42/132:
M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
b = np.array([2,20,11])
42/133:
def Inverse_method_solve(A,b):
    return np.dot(get_inv(A),b)
42/134:
def Cramer_rule_solve(A,b):
    F = get_det(A)
    X = np.zeros(b.shape[0])
    for i in range(b.shape[0]):
        X[i] = get_det(replace_colum(copy.deepcopy(M),i,b))/F
    return X
42/135:
def GaussElimination(mat,b):
    c = copy.deepcopy(b.reshape(b.shape[0],1))
    matrix = np.concatenate((copy.deepcopy(mat),c), axis=1)
    matrix = matrix.astype(float)
    n,m = matrix.shape
    for i in range(0,n):#row
        for j in range(i+1,n):
            if matrix[j,i] != 0.0:
                multiplier = matrix[j,i]/matrix[i,i]
                matrix[j,i:m]=matrix[j,i:m] - multiplier*matrix[i,i:m] 
    x = []
    substractor = 0.0
    for i in range(n-1,-1,-1): #row
        for j in range(0,n-i): #column
            if j==0:
                substractor = 0
            else:
                substractor = substractor + matrix[i,m-j-1]*x[j-1]
        x.append((matrix[i,m-1]-substractor)/matrix[i,i])
    return x
42/136:
def LU_decompose(A):
    L = np.eye(len(A))
    U = np.zeros(A.shape)
    for r in range(1, len(A)): 
        U[0, r - 1] = A[0, r - 1]
        L[r, 0] = A[r, 0] / A[0, 0]
    U[0, -1] = A[0, -1]
    for r in range(1, len(A)):
        for i in range(r, len(A)):
            delta = 0
            for k in range(0, r):
                delta += L[r, k] * U[k, i]
            U[r, i] = A[r, i] - delta

            for i in range(r + 1, len(A)): 
                theta = 0
                for k in range(0, r):  
                    theta += L[i, k] * U[k, r]
                L[i, r] = (A[i, r] - theta) / U[r, r]
    return L,U
def LUsolve(A,b):
    L, U = LU_decompose(A)
    n = len(A)
    y = np.zeros((n, 1))
    b = np.array(b).reshape(n,1) 
    for i in range(len(A)):
        t = 0
        for j in range(i):
            t += L[i][j]* y[j][0]
        y[i][0] = b[i][0] - t
    X = np.zeros((n, 1))
    for i in range(len(A)-1,-1,-1):
        t = 0
        for j in range(i+1,len(A)):
            t += U[i][j]*X[j][0]
        t = y[i][0] - t
        X[i] = t/U[i][i]
    return X
42/137:
import time

time_start=time.time()
time_end=time.time()
print('time cost',time_end-time_start,'s')
42/138:
def make_rand_square_matrix(n):
    A =rand(n ** 2)
    A = np.floor(A*100)
    return A.reshape(n, n)
42/139:
N = [i for i in range(1,100)]
Mats = []
bs = []
for n in N:
    A = make_rand_square_matrix(n)
    x = np.array([i+1 for i in range(n)])
    x = x.reshape(n,1)
    b = np.dot(A,x)
    Mats.append(A)
    bs.append(b)
42/140:
import time
def cost(func):
    start = time.process_time()
    Times = []
    for i in range(len(Mats)):
        func(Mats[i],bs[i])
        Times.append(time.process_time()-start)
    return Times
42/141:
Gauss = cost(GaussElimination)
LU = cost(LUsolve)
Inver = cost(Inverse_method_solve)
Cra = cost(Cramer_rule_solve)
42/142:
import time
def cost(func):
    start = time.process_time()
    Times = []
    for i in range(len(Mats)):
        func(Mats[i],bs[i])
        Times.append(time.process_time()-start)
    return Times
42/143:
N = [i for i in range(1,100)]
Mats = []
bs = []
for n in N:
    A = make_rand_square_matrix(n)
    x = np.array([i+1 for i in range(n)])
    x = x.reshape(n,1)
    b = np.dot(A,x)
    Mats.append(A)
    bs.append(b)
42/144:
N = [i for i in range(1,10)]
Mats = []
bs = []
for n in N:
    A = make_rand_square_matrix(n)
    x = np.array([i+1 for i in range(n)])
    x = x.reshape(n,1)
    b = np.dot(A,x)
    Mats.append(A)
    bs.append(b)
42/145:
import time
def cost(func):
    start = time.process_time()
    Times = []
    for i in range(len(Mats)):
        func(Mats[i],bs[i])
        Times.append(time.process_time()-start)
    return Times
42/146:
Gauss = cost(GaussElimination)
LU = cost(LUsolve)
Inver = cost(Inverse_method_solve)
Cra = cost(Cramer_rule_solve)
42/147:
import numpy as np
from numpy.random import rand, seed
import copy
from func import *
from numpy.linalg import inv
43/1:
import numpy as np
from numpy.random import rand, seed
import copy
from func import *
from numpy.linalg import inv
43/2:
M = np.array([[1,2,-1],[2,3,4],[3,1,2]])
b = np.array([2,20,11])
43/3:
def Inverse_method_solve(A,b):
    return np.dot(get_inv(A),b)
43/4: Inverse_method_solve(M,b)
43/5:
def Cramer_rule_solve(A,b):
    F = get_det(A)
    X = np.zeros(b.shape[0])
    for i in range(b.shape[0]):
        X[i] = get_det(replace_colum(copy.deepcopy(M),i,b))/F
    return X
43/6: Cramer_rule_solve(M,b)
43/7:
#The inverse method
Inverse_method_solve(M,b)
43/8:
def GaussElimination(mat,b):
    c = copy.deepcopy(b.reshape(b.shape[0],1))
    matrix = np.concatenate((copy.deepcopy(mat),c), axis=1)
    matrix = matrix.astype(float)
    n,m = matrix.shape
    for i in range(0,n):#row
        for j in range(i+1,n):
            if matrix[j,i] != 0.0:
                multiplier = matrix[j,i]/matrix[i,i]
                matrix[j,i:m]=matrix[j,i:m] - multiplier*matrix[i,i:m] 
    x = []
    substractor = 0.0
    for i in range(n-1,-1,-1): #row
        for j in range(0,n-i): #column
            if j==0:
                substractor = 0
            else:
                substractor = substractor + matrix[i,m-j-1]*x[j-1]
        x.append((matrix[i,m-1]-substractor)/matrix[i,i])
    return x
43/9: GaussElimination(M,b)
43/10:
def LU_decompose(A):
    L = np.eye(len(A))
    U = np.zeros(A.shape)
    for r in range(1, len(A)): 
        U[0, r - 1] = A[0, r - 1]
        L[r, 0] = A[r, 0] / A[0, 0]
    U[0, -1] = A[0, -1]
    for r in range(1, len(A)):
        for i in range(r, len(A)):
            delta = 0
            for k in range(0, r):
                delta += L[r, k] * U[k, i]
            U[r, i] = A[r, i] - delta

            for i in range(r + 1, len(A)): 
                theta = 0
                for k in range(0, r):  
                    theta += L[i, k] * U[k, r]
                L[i, r] = (A[i, r] - theta) / U[r, r]
    return L,U
def LUsolve(A,b):
    L, U = LU_decompose(A)
    n = len(A)
    y = np.zeros((n, 1))
    b = np.array(b).reshape(n,1) 
    for i in range(len(A)):
        t = 0
        for j in range(i):
            t += L[i][j]* y[j][0]
        y[i][0] = b[i][0] - t
    X = np.zeros((n, 1))
    for i in range(len(A)-1,-1,-1):
        t = 0
        for j in range(i+1,len(A)):
            t += U[i][j]*X[j][0]
        t = y[i][0] - t
        X[i] = t/U[i][i]
    return X
43/11: LUsolve(M,b)
43/12:
import time

time_start=time.time()
time_end=time.time()
print('time cost',time_end-time_start,'s')
43/13:
def make_rand_square_matrix(n):
    A =rand(n ** 2)
    A = np.floor(A*100)
    return A.reshape(n, n)
43/14:
N = [i for i in range(1,10)]
Mats = []
bs = []
for n in N:
    A = make_rand_square_matrix(n)
    x = np.array([i+1 for i in range(n)])
    x = x.reshape(n,1)
    b = np.dot(A,x)
    Mats.append(A)
    bs.append(b)
43/15:
import time
def cost(func):
    start = time.process_time()
    Times = []
    for i in range(len(Mats)):
        func(Mats[i],bs[i])
        Times.append(time.process_time()-start)
    return Times
43/16:
Gauss = cost(GaussElimination)
LU = cost(LUsolve)
Inver = cost(Inverse_method_solve)
Cra = cost(Cramer_rule_solve)
43/17:
Gauss = cost(GaussElimination)
LU = cost(LUsolve)
Inver = cost(Inverse_method_solve)
43/18:
plt.plot(Gauss,label='Gauss')
plt.plot(Gauss,label='LU')
plt.plot(Gauss,label='Inverse')
plt.legend()
43/19: import matplotlib.pyplot as plt
43/20:
plt.plot(Gauss,label='Gauss')
plt.plot(Gauss,label='LU')
plt.plot(Gauss,label='Inverse')
plt.legend()
43/21: plt.show()
43/22:
plt.plot(Gauss,label='Gauss')
plt.plot(LU,label='LU')
plt.plot(Inver,label='Inverse')
plt.legend()
44/1:
import scipy.sparse

def laplacian_matrix(n, m):   
    mat_D = scipy.sparse.lil_matrix((m, m))
    mat_D.setdiag(-1, -1)
    mat_D.setdiag(4)
    mat_D.setdiag(-1, 1)
        
    mat_A = scipy.sparse.block_diag([mat_D] * n).tolil()
    
    mat_A.setdiag(-1, 1*m)
    mat_A.setdiag(-1, -1*m)
    
    return mat_A

laplacian_matrix(3, 3).todense()
44/2:
from os import path
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

scr_dir = 'figs/example1'
source = cv2.imread(path.join(scr_dir, "source1.jpg")) 
target = cv2.imread(path.join(scr_dir, "target1.jpg"))
mask = cv2.imread(path.join(scr_dir, "mask1.png"), cv2.IMREAD_GRAYSCALE) 
offset = (0, 66)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
44/3:
y_max, x_max = target.shape[:-1]
y_min, x_min = 0, 0
x_range = x_max - x_min
y_range = y_max - y_min

M = np.float32([[1, 0, offset[0]], [0, 1, offset[1]]])
source = cv2.warpAffine(source, M, (x_range, y_range))

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) 
plt.show()
44/4:
mask = mask[y_min:y_max, x_min:x_max]
mask[mask != 0] = 1
44/5:
mat_A = laplacian_matrix(y_range, x_range)
laplacian = mat_A.tocsc()
44/6:
for y in range(1, y_range - 1):
    for x in range(1, x_range - 1):
        if mask[y, x] == 0:
            k = x + y * x_range
            mat_A[k, k] = 1
            mat_A[k, k + 1] = 0
            mat_A[k, k - 1] = 0
            mat_A[k, k + x_range] = 0
            mat_A[k, k - x_range] = 0
mat_A = mat_A.tocsc()
44/7:
from scipy.sparse.linalg import spsolve

mask_flat = mask.flatten()    
for channel in range(source.shape[2]):
    source_flat = source[y_min:y_max, x_min:x_max, channel].flatten()
    target_flat = target[y_min:y_max, x_min:x_max, channel].flatten()        

    # inside the mask:
    # \Delta f = div v = \Delta g       
    alpha = 1
    mat_b = laplacian.dot(source_flat)*alpha

    # outside the mask:
    # f = t
    mat_b[mask_flat == 0] = target_flat[mask_flat == 0]
    
    x = spsolve(mat_A, mat_b)    
    x = x.reshape((y_range, x_range))
    x[x > 255] = 255
    x[x < 0] = 0
    x = x.astype('uint8')
    
    target[y_min:y_max, x_min:x_max, channel] = x
44/8:
plt.imshow(target[:,:,::-1]) 
plt.show()

out_dir = 'figs'
cv2.imwrite(path.join(out_dir, "possion1.png"), target)
44/9: mat_A
44/10:
mat_A = laplacian_matrix(y_range, x_range)
laplacian = mat_A.tocsc()
44/11: laplacian
44/12: mat_A
46/1: import cv2
46/2: import cv2
46/3:
import cv2
import numpy as np
46/4: #Read the image and cut
46/5: #Read the image and cut
46/6:
x1 = 3
y1 = 2
x2 = 15
y2 = 5
bresenham(x1, y1, x2, y2)
46/7:
#Read the image and cut
# function for line generation  
def bresenham(x1,y1,x2, y2):  
  
    m_new = 2 * (y2 - y1)  
    slope_error_new = m_new - (x2 - x1) 
  
    y=y1 
    for x in range(x1,x2+1):  
      
        print("(",x ,",",y ,")\n")  
  
        # Add slope to increment angle formed  
        slope_error_new =slope_error_new + m_new  
  
        # Slope error reached limit, time to  
        # increment y and update slope error.  
        if (slope_error_new >= 0):  
            y=y+1
            slope_error_new =slope_error_new - 2 * (x2 - x1)
46/8:
x1 = 3
y1 = 2
x2 = 15
y2 = 5
bresenham(x1, y1, x2, y2)
46/9:
#Read the image and cut
# function for line generation  
def bresenham(x1,y1,x2, y2):  
  
    m_new = 2 * (y2 - y1)  
    slope_error_new = m_new - (x2 - x1) 
  
    y=y1 
    for x in range(x1,x2+1):  
      
        print(x,y)  
  
        # Add slope to increment angle formed  
        slope_error_new =slope_error_new + m_new  
  
        # Slope error reached limit, time to  
        # increment y and update slope error.  
        if (slope_error_new >= 0):  
            y=y+1
            slope_error_new =slope_error_new - 2 * (x2 - x1)
46/10:
x1 = 3
y1 = 2
x2 = 15
y2 = 5
bresenham(x1, y1, x2, y2)
46/11:
#Read the image and cut
# function for line generation  
def bresenham(x1,y1,x2, y2):  
  
    m_new = 2 * (y2 - y1)  
    slope_error_new = m_new - (x2 - x1) 
    y=y1 
    path = []
    for x in range(x1,x2+1):  
        path.append([x,y])
        slope_error_new =slope_error_new + m_new  
        if (slope_error_new >= 0):  
            y=y+1
            slope_error_new =slope_error_new - 2 * (x2 - x1)  
    return path
46/12:
x1 = 3
y1 = 2
x2 = 15
y2 = 5
bresenham(x1, y1, x2, y2)
46/13:
#Read the image and cut
# function for line generation  
def bresenham(x1,y1,x2, y2):  
    m_new = 2 * (y2 - y1)  
    slope_error_new = m_new - (x2 - x1) 
    y=y1 
    path = []
    for x in range(x1,x2+1):  
        path.append([x,y])
        slope_error_new =slope_error_new + m_new  
        if (slope_error_new >= 0):  
            y=y+1
            slope_error_new =slope_error_new - 2 * (x2 - x1)  
    return path
46/14: cv2.imread("mask.png")
46/15: M = cv2.imread("mask.png")
46/16:
Mask = cv2.imread("mask.png")
Source = cv2.imread("source.png")
Target = cv2.imread("target.png")
46/17:
def cloest_path():
    pair = []
    return pair
46/18: Target
46/19: Target.imshow
46/20:
Source = cv2.imread("source.png")
mask = np.zeros(image.shape, dtype=np.uint8)
46/21:
Source = cv2.imread("source.png")
mask = np.zeros(image.shape, dtype=np.uint8)
46/22:
Source = cv2.imread("source.png")
Mask = np.zeros(Source.shape, dtype=np.uint8)
46/23:

import cv2
import numpy as np
 
# 图片路径
img = cv2.imread('target.png')
a = []
b = []
 
 
def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
    if event == cv2.EVENT_LBUTTONDOWN:
        xy = "%d,%d" % (x, y)
        a.append(x)
        b.append(y)
        cv2.circle(img, (x, y), 1, (0, 0, 255), thickness=-1)
        cv2.putText(img, xy, (x, y), cv2.FONT_HERSHEY_PLAIN,
                    1.0, (0, 0, 0), thickness=1)
        cv2.imshow("image", img)
        print(x,y)
 
 
cv2.namedWindow("image")
cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
cv2.imshow("image", img)
cv2.waitKey(0)
print(a[0], b[0])
47/1:
import cv2
import numpy as np
47/2:

import cv2
import numpy as np
 
# 图片路径
img = cv2.imread('target.png')
a = []
b = []
 
 
def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
    if event == cv2.EVENT_LBUTTONDOWN:
        xy = "%d,%d" % (x, y)
        a.append(x)
        b.append(y)
        cv2.imshow("image", img)
        print(x,y)
 
 
cv2.namedWindow("image")
cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
cv2.imshow("image", img)
cv2.waitKey(0)
print(a[0], b[0])
48/1:

import cv2
import numpy as np
 
# 图片路径
img = cv2.imread('target.png')
a = []
b = []
 
 
def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
    if event == cv2.EVENT_LBUTTONDOWN:
        xy = "%d,%d" % (x, y)
        a.append(x)
        b.append(y)
        cv2.circle(img, (x, y), 1, (0, 0, 255), thickness=-1)
        cv2.imshow("image", img)
        print(x,y)
 
 
cv2.namedWindow("image")
cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
cv2.imshow("image", img)
cv2.waitKey(0)
print(a[0], b[0])
49/1:

import cv2
import numpy as np
img = cv2.imread('target.png')
a = []
b = []
def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
    if event == cv2.EVENT_LBUTTONDOWN:
        xy = "%d,%d" % (x, y)
        a.append(x)
        b.append(y)
        cv2.circle(img, (x, y), 1, (0, 0, 255), thickness=-1)
        cv2.imshow("image", img)
        print(x,y)
 
 
cv2.namedWindow("image")
cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
cv2.imshow("image", img)
cv2.waitKey(0)
print(a[0], b[0])
50/1:

import cv2
import numpy as np
img = cv2.imread('target.png')
a = []
b = []
def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
    if event == cv2.EVENT_LBUTTONDOWN:
        xy = "%d,%d" % (x, y)
        a.append(x)
        b.append(y)
        cv2.line(img,(x,y),(a[1],b[1]), 1, (0, 0, 255), thickness=-1)
        cv2.imshow("image", img)
        print(x,y)
cv2.namedWindow("image")
cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
cv2.imshow("image", img)
cv2.waitKey(0)
print(a[0], b[0])
51/1:

import cv2
import numpy as np
img = cv2.imread('target.png')
a = []
b = []
def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
    if event == cv2.EVENT_LBUTTONDOWN:
        xy = "%d,%d" % (x, y)
        a.append(x)
        b.append(y)
        cv2.line(img,(x,y),(a[1],b[1]),(0, 0, 255), thickness=-1)
        cv2.imshow("image", img)
        print(x,y)
cv2.namedWindow("image")
cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
cv2.imshow("image", img)
cv2.waitKey(0)
print(a[0], b[0])
52/1:

import cv2
import numpy as np
img = cv2.imread('target.png')
a = []
b = []
def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
    if event == cv2.EVENT_LBUTTONDOWN:
        xy = "%d,%d" % (x, y)
        a.append(x)
        b.append(y)
        if len(a)>1 :
            cv2.line(img,(x,y),(a[1],b[1]),(0, 0, 255), thickness=-1)
        cv2.imshow("image", img)
        print(x,y)
cv2.namedWindow("image")
cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
cv2.imshow("image", img)
cv2.waitKey(0)
print(a[0], b[0])
53/1:

import cv2
import numpy as np
img = cv2.imread('target.png')
a = []
b = []
def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
    if event == cv2.EVENT_LBUTTONDOWN:
        xy = "%d,%d" % (x, y)
        a.append(x)
        b.append(y)
        if len(a)>1 :
            cv2.line(img,(x,y),(a[-1],b[-1]),(0, 0, 255), thickness=-1)
        cv2.imshow("image", img)
        print(x,y)
cv2.namedWindow("image")
cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
cv2.imshow("image", img)
cv2.waitKey(0)
print(a[0], b[0])
54/1:
import cv2
import numpy as np
 
img = cv2.imread('target.png')
Points = []
def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
    if event == cv2.EVENT_LBUTTONDOWN:
        xy = "%d,%d" % (x, y)
        Points.append([x,y])
        cv2.circle(img, (x,y), 1, (0, 0, 255), thickness=-1)
        cv2.imshow("image", img)
while len(Points)<10:
    cv2.namedWindow("image")
    cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
    cv2.imshow("image", img)
    cv2.waitKey(0)
55/1:
import cv2
import numpy as np
 
img = cv2.imread('target.png')
Points = []
def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
    if event == cv2.EVENT_LBUTTONDOWN:
        xy = "%d,%d" % (x, y)
        Points.append([x,y])
        cv2.circle(img, (x,y), 1, (0, 0, 255), thickness=-1)
        cv2.imshow("image", img)
cv2.namedWindow("image")
cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
cv2.imshow("image", img)
cv2.waitKey(0)
56/1:
import cv2
import numpy as np
 
img = cv2.imread('target.png')
Points = []
def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
    if event == cv2.EVENT_LBUTTONDOWN:
        xy = "%d,%d" % (x, y)
        Points.append([x,y])
        cv2.circle(img, (x,y), 1, (0, 0, 255), thickness=-1)
        cv2.imshow("image", img)
cv2.namedWindow("image")
cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
cv2.imshow("image", img)
56/2: cv2.destroyWindow("image")
56/3:
import cv2
import numpy as np
 
img = cv2.imread('target.png')
Points = []
def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
    if event == cv2.EVENT_LBUTTONDOWN:
        xy = "%d,%d" % (x, y)
        Points.append([x,y])
        cv2.circle(img, (x,y), 1, (0, 0, 255), thickness=-1)
        cv2.imshow("image", img)
cv2.namedWindow("image")
cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
cv2.imshow("image", img)
cv2.waitKey(0)
cv2.destroyWindow("image")
56/4: Points
56/5: make_outline("source.png")
56/6:
def make_outline(path):
    img = cv2.imread(path)
    Points = []
    def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
        if event == cv2.EVENT_LBUTTONDOWN:
            xy = "%d,%d" % (x, y)
            Points.append([x,y])
            cv2.circle(img, (x,y), 1, (0, 0, 255), thickness=-1)
            cv2.imshow("image", img)
    cv2.namedWindow("image")
    cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
    cv2.imshow("image", img)
    cv2.waitKey(0)
    cv2.destroyWindow("image")
    return Points
56/7: make_outline("source.png")
56/8: K =[[44, 35], [58, 19], [82, 19], [87, 34], [87, 54], [65, 63], [47, 55]]
56/9: K.append(K[0])
56/10: K
56/11: mask = np.zeros(image.shape, dtype=np.uint8)
56/12: Mask = cv2.imread("mask.png")
56/13: test = np.zeros(Mask.shape, dtype=np.uint8)
56/14: test
56/15: cv2.imshow("Mask",Mask)
57/1: import imageio
57/2: Image.fromarray(Mask)
57/3: from PIL import Image
57/4: Mask = cv2.imread("mask.png")
57/5:
import cv2
import numpy as np
57/6: Image.fromarray(Mask)
57/7: Mask = cv2.imread("mask.png")
57/8: Image.fromarray(Mask)
57/9: K = [[44, 35], [58, 19], [82, 19], [87, 34], [87, 54], [65, 63], [47, 55]]
57/10:
#Read the image and cut
# function for line generation  
def bresenham(x1,y1,x2, y2):  
    m_new = 2 * (y2 - y1)  
    slope_error_new = m_new - (x2 - x1) 
    y=y1 
    path = []
    for x in range(x1,x2+1):  
        path.append([x,y])
        slope_error_new =slope_error_new + m_new  
        if (slope_error_new >= 0):  
            y=y+1
            slope_error_new =slope_error_new - 2 * (x2 - x1)  
    return path
57/11:
Path = []
for i in range(len(K)-1):
    Path = Path+bresenham(K[i],K[i+1])
57/12:
#Read the image and cut
# function for line generation  
def bresenham(n1,n2):
    x1,y1 = n1
    x2,y2 = n2
    m_new = 2 * (y2 - y1)  
    slope_error_new = m_new - (x2 - x1) 
    y=y1 
    path = []
    for x in range(x1,x2+1):  
        path.append([x,y])
        slope_error_new =slope_error_new + m_new  
        if (slope_error_new >= 0):  
            y=y+1
            slope_error_new =slope_error_new - 2 * (x2 - x1)  
    return path
57/13:
Path = []
for i in range(len(K)-1):
    Path = Path+bresenham(K[i],K[i+1])
57/14: len(Path)
57/15: test = np.zeros(Mask.shape, dtype=np.uint8)
57/16:
for p in Path:
    test[p[0]][p[1]] = 1
57/17: test
57/18:
for p in Path:
    test[p[0]][p[1]] = [255,0,0]
57/19: Image.fromarray(test)
57/20: bresenham(K[0],K[1])
57/21: bresenham([1,1],[5,5])
57/22: bresenham([44, 35], [58, 19])
57/23:
class bresenham:
    def __init__(self, start, end):
        self.start = list(start)
        self.end = list(end)
        self.path = []
        
        self.steep = abs(self.end[1]-self.start[1]) > abs(self.end[0]-self.start[0])
        
        if self.steep:
            print 'Steep'
            self.start = self.swap(self.start[0],self.start[1])
            self.end = self.swap(self.end[0],self.end[1])
        
        if self.start[0] > self.end[0]:
            print 'flippin and floppin'
            _x0 = int(self.start[0])
            _x1 = int(self.end[0])
            self.start[0] = _x1
            self.end[0] = _x0
            
            _y0 = int(self.start[1])
            _y1 = int(self.end[1])
            self.start[1] = _y1
            self.end[1] = _y0
        
        dx = self.end[0] - self.start[0]
        dy = abs(self.end[1] - self.start[1])
        error = 0
        derr = dy/float(dx)
        
        ystep = 0
        y = self.start[1]
        
        if self.start[1] < self.end[1]: ystep = 1
        else: ystep = -1
        
        for x in range(self.start[0],self.end[0]+1):
            if self.steep:
                self.path.append((y,x))
            else:
                self.path.append((x,y))
            
            error += derr
            
            if error >= 0.5:
                y += ystep
                error -= 1.0
        
        print start
        print end
        print
        print self.start
        print self.end
    
    def swap(self,n1,n2):
        return [n2,n1]
57/24:
class bresenham:
    def __init__(self, start, end):
        self.start = list(start)
        self.end = list(end)
        self.path = []
        
        self.steep = abs(self.end[1]-self.start[1]) > abs(self.end[0]-self.start[0])
        
        if self.steep:
            print 'Steep'
            self.start = self.swap(self.start[0],self.start[1])
            self.end = self.swap(self.end[0],self.end[1])
        
        if self.start[0] > self.end[0]:
            print 'flippin and floppin'
            _x0 = int(self.start[0])
            _x1 = int(self.end[0])
            self.start[0] = _x1
            self.end[0] = _x0
            
            _y0 = int(self.start[1])
            _y1 = int(self.end[1])
            self.start[1] = _y1
            self.end[1] = _y0
        
        dx = self.end[0] - self.start[0]
        dy = abs(self.end[1] - self.start[1])
        error = 0
        derr = dy/float(dx)
        
        ystep = 0
        y = self.start[1]
        
        if self.start[1] < self.end[1]: ystep = 1
        else: ystep = -1
        
        for x in range(self.start[0],self.end[0]+1):
            if self.steep:
                self.path.append((y,x))
            else:
                self.path.append((x,y))
            
            error += derr
            
            if error >= 0.5:
                y += ystep
                error -= 1.0
        
        print start
        print end
        print
        print self.start
        print self.end
    
    def swap(self,n1,n2):
        return [n2,n1]
57/25:
class bresenham:
    def __init__(self, start, end):
        self.start = list(start)
        self.end = list(end)
        self.path = []
        
        self.steep = abs(self.end[1]-self.start[1]) > abs(self.end[0]-self.start[0])
        
        if self.steep:
            self.start = self.swap(self.start[0],self.start[1])
            self.end = self.swap(self.end[0],self.end[1])
        
        if self.start[0] > self.end[0]:
            _x0 = int(self.start[0])
            _x1 = int(self.end[0])
            self.start[0] = _x1
            self.end[0] = _x0
            
            _y0 = int(self.start[1])
            _y1 = int(self.end[1])
            self.start[1] = _y1
            self.end[1] = _y0
        
        dx = self.end[0] - self.start[0]
        dy = abs(self.end[1] - self.start[1])
        error = 0
        derr = dy/float(dx)
        
        ystep = 0
        y = self.start[1]
        
        if self.start[1] < self.end[1]: ystep = 1
        else: ystep = -1
        
        for x in range(self.start[0],self.end[0]+1):
            if self.steep:
                self.path.append((y,x))
            else:
                self.path.append((x,y))
            
            error += derr
            
            if error >= 0.5:
                y += ystep
                error -= 1.0
        
        print start
        print end
        print
        print self.start
        print self.end
    
    def swap(self,n1,n2):
        return [n2,n1]
57/26:
class bresenham:
    def __init__(self, start, end):
        self.start = list(start)
        self.end = list(end)
        self.path = []
        
        self.steep = abs(self.end[1]-self.start[1]) > abs(self.end[0]-self.start[0])
        
        if self.steep:
            self.start = self.swap(self.start[0],self.start[1])
            self.end = self.swap(self.end[0],self.end[1])
        
        if self.start[0] > self.end[0]:
            _x0 = int(self.start[0])
            _x1 = int(self.end[0])
            self.start[0] = _x1
            self.end[0] = _x0
            
            _y0 = int(self.start[1])
            _y1 = int(self.end[1])
            self.start[1] = _y1
            self.end[1] = _y0
        
        dx = self.end[0] - self.start[0]
        dy = abs(self.end[1] - self.start[1])
        error = 0
        derr = dy/float(dx)
        
        ystep = 0
        y = self.start[1]
        
        if self.start[1] < self.end[1]: ystep = 1
        else: ystep = -1
        
        for x in range(self.start[0],self.end[0]+1):
            if self.steep:
                self.path.append((y,x))
            else:
                self.path.append((x,y))
            
            error += derr
            
            if error >= 0.5:
                y += ystep
                error -= 1.0
    
    def swap(self,n1,n2):
        return [n2,n1]
57/27: A = bresenham([1,1],[5,5])
57/28: A.path
57/29: A = bresenham([44, 35], [58, 19])
57/30: A.path
57/31: bresenham([44, 35], [58, 19]).path
57/32:
Path = []
for i in range(len(K)-1):
    Path = Path+bresenham(K[i],K[i+1]).path
57/33: Path
57/34:
for p in Path:
    test[p[0]][p[1]] = [255,0,0]
57/35: Image.fromarray(test)
59/1:
class bresenham:
    def __init__(self, start, end):
        self.start = list(start)
        self.end = list(end)
        self.path = []
        
        self.steep = abs(self.end[1]-self.start[1]) > abs(self.end[0]-self.start[0])
        
        if self.steep:
            self.start = self.swap(self.start[0],self.start[1])
            self.end = self.swap(self.end[0],self.end[1])
        
        if self.start[0] > self.end[0]:
            _x0 = int(self.start[0])
            _x1 = int(self.end[0])
            self.start[0] = _x1
            self.end[0] = _x0
            
            _y0 = int(self.start[1])
            _y1 = int(self.end[1])
            self.start[1] = _y1
            self.end[1] = _y0
        
        dx = self.end[0] - self.start[0]
        dy = abs(self.end[1] - self.start[1])
        error = 0
        derr = dy/float(dx)
        
        ystep = 0
        y = self.start[1]
        
        if self.start[1] < self.end[1]: ystep = 1
        else: ystep = -1
        
        for x in range(self.start[0],self.end[0]+1):
            if self.steep:
                self.path.append((y,x))
            else:
                self.path.append((x,y))
            
            error += derr
            
            if error >= 0.5:
                y += ystep
                error -= 1.0
    
    def swap(self,n1,n2):
        return [n2,n1]
59/2:
import cv2
import numpy as np
from PIL import Image
59/3:
def make_outline(path):
    img = cv2.imread(path)
    Points = []
    def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
        if event == cv2.EVENT_LBUTTONDOWN:
            xy = "%d,%d" % (x, y)
            Points.append([x,y])
            cv2.circle(img, (x,y), 1, (0, 0, 255), thickness=-1)
            cv2.imshow("image", img)
    cv2.namedWindow("image")
    cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
    cv2.imshow("image", img)
    cv2.waitKey(0)
    cv2.destroyWindow("image")
    return Points
59/4: K = make_outline("source.png")
59/5: K.append(K[0])
59/6: K
59/7:
Path = []
for i in range(len(K)-1):
    Path = Path+bresenham(K[i],K[i+1]).path
59/8:
import matplotlib.pyplot as plt
plt.scatter(K)
59/9:
import matplotlib.pyplot as plt
plt.scatter(K[0],K[1])
59/10: import matplotlib.pyplot as plt
59/11: plt.scatter([x for i[0] in Path],[y for i[1] in path)
59/12: plt.scatter([x for i[0] in Path],[y for i[1] in path])
59/13: plt.scatter([i[0] for i in Path],[i[1] for i in path])
59/14: plt.scatter([i[0] for i in Path],[i[1] for i in Path])
59/15: test = np.zeros(Mask.shape, dtype=np.uint8)
59/16: test = np.zeros(Mask.shape, dtype=np.uint8)
59/17: Mask = cv2.imread("mask.png")
59/18: test = np.zeros(Mask.shape, dtype=np.uint8)
59/19:
for p in Path:
    test[p[0]][p[1]] = [255,0,0]
59/20: len(Path)
59/21: test = np.zeros(Mask.shape, dtype=np.uint8)
59/22:
for p in Path:
    test[p[0]][p[1]] = [255,0,0]
59/23: Image.fromarray(test)
59/24: Image.fromarray(Mask)
59/25:
for p in Path:
    test[p[0]][p[1]] = [255,0,0]
59/26:
for p in Path:
    print(p)
    test[p[0]][p[1]] = [255,0,0]
59/27:
for p in Path:
    print(p)
    test[p[1]][p[0]] = [255,0,0]
59/28:
for p in Path:
    test[p[1]][p[0]] = [255,0,0]
59/29: Image.fromarray(test)
59/30:
for i in range(len(Path)-1):
    if(cv2.norm(Path[i],Path[i+1])>1:
       print(True)
59/31:
for i in range(len(Path)-1):
    if cv2.norm(Path[i],Path[i+1]) > 1:
       print(True)
59/32:
for i in range(len(Path)-1):
    if cv2.norm(Path[i],Path[i+1]) > 1.5:
       print(True)
59/33:
for i in range(len(Path)-1):
    if cv2.norm(Path[i],Path[i+1]) > 1.5:
       print(Path[i],Path[i+1])
59/34: Path.index((71,243))
59/35: Path[40:60]
59/36:
Path = []
for i in range(len(K)-1):
    Path.append(bresenham(K[i],K[i+1]).path)
59/37: import matplotlib.pyplot as plt
59/38:
for P in path:
    plt.scatter([i[0] for i in P],[i[1] for i in P])
59/39:
for P in Path:
    plt.scatter([i[0] for i in P],[i[1] for i in P])
59/40: K = make_outline("source.png")
59/41: K.append(K[0])
59/42: K
59/43:
K
plt.scatter([i[0] for i in K],[i[1] for i in K])
59/44:
for P in Path:
    plt.scatter([i[0] for i in P],[i[1] for i in P])
59/45:
Path = []
for i in range(len(K)-1):
    Path.append(bresenham(K[i],K[i+1]).path)
59/46:
for P in Path:
    plt.scatter([i[0] for i in P],[i[1] for i in P])
59/47: test = np.zeros(Mask.shape, dtype=np.uint8)
59/48:
for i in range(len(Path)-1):
    if cv2.norm(Path[i],Path[i+1]) > 1.5:
       print(Path[i],Path[i+1])
59/49:
for i in range(len(Path)-1):
    if cv2.norm(Path[i],Path[i+1]) > 1.5:
       print(Path[i],Path[i+1])
59/50:
import cv2
import numpy as np
from PIL import Image
59/51:
import cv2
import numpy as np
59/52:
for i in range(len(Path)-1):
    if cv2.norm(Path[i],Path[i+1]) > 1.5:
       print(Path[i],Path[i+1])
59/53:
for i in range(len(Path)-1):
    if cv2.norm(Path[i],Path[i+1]) > 1.5:
           print(Path[i],Path[i+1])
59/54: Path
59/55: for i in range(len(Path)):
59/56:
for k in range(len(Path)):
    for i in range(len(len(Path[k]-1))):
        if cv2.norm(Path[i],Path[i+1]) > 1.5:
               print(Path[i],Path[i+1])
59/57:
for k in range(len(Path)):
    for i in range(len(len(Path[k]-1))):
        if cv2.norm(Path[k][i],Path[k][i+1]) > 1.5:
               print(Path[k][i],Path[k][i+1])
59/58:
for k in range(len(Path)):
    for i in range(len(Path[k])-1):
        if cv2.norm(Path[k][i],Path[k][i+1]) > 1.5:
               print(Path[k][i],Path[k][i+1])
59/59:
for k in range(len(Path)):
    for i in range(len(Path[k])-1):
        print(cv2.norm(Path[k][i],Path[k][i+1]))
59/60: Path
59/61:
def plot_line(K):
    print()
    plt.scatter([i[0] for i in K],[i[1] for i in K])
    Path = []
    for i in range(len(K)-1):
        Path.append(bresenham(K[i],K[i+1]).path)
59/62:
def plot_line(K):
    print("The points you chose")
    plt.scatter([i[0] for i in K],[i[1] for i in K])
    Path = []
    for i in range(len(K)-1):
        Path.append(bresenham(K[i],K[i+1]).path)
    print("The points you chose")
        for P in Path:
        plt.scatter([i[0] for i in P],[i[1] for i in P])
plot_line(K
59/63:
def plot_line(K):
    print("The points you chose")
    plt.scatter([i[0] for i in K],[i[1] for i in K])
    Path = []
    for i in range(len(K)-1):
        Path.append(bresenham(K[i],K[i+1]).path)
    print("The points you chose")
        for P in Path:
        plt.scatter([i[0] for i in P],[i[1] for i in P])
plot_line(K)
59/64:
def plot_line(K):
    print("The points you chose")
    plt.scatter([i[0] for i in K],[i[1] for i in K])
    Path = []
    for i in range(len(K)-1):
        Path.append(bresenham(K[i],K[i+1]).path)
    print("The points you chose")
    for P in Path:
    plt.scatter([i[0] for i in P],[i[1] for i in P])
plot_line(K)
59/65:
def plot_line(K):
    print("The points you chose")
    plt.scatter([i[0] for i in K],[i[1] for i in K])
    Path = []
    for i in range(len(K)-1):
        Path.append(bresenham(K[i],K[i+1]).path)
    print("The points you chose")
    for P in Path:
        plt.scatter([i[0] for i in P],[i[1] for i in P])
plot_line(K)
59/66:
def plot_line(K):
    print("The points you chose")
    plt.scatter([i[0] for i in K],[i[1] for i in K])
    plt.show()
    Path = []
    for i in range(len(K)-1):
        Path.append(bresenham(K[i],K[i+1]).path)
    print("The points you chose")
    for P in Path:
        plt.scatter([i[0] for i in P],[i[1] for i in P])
plot_line(K)
59/67:
def plot_line(K):
    print("The points you chose:)
    plt.scatter([i[0] for i in K],[i[1] for i in K])
    plt.show()
    Path = []
    for i in range(len(K)-1):
        Path.append(bresenham(K[i],K[i+1]).path)
    print("Line:")
    for P in Path:
        plt.scatter([i[0] for i in P],[i[1] for i in P])
plot_line(K)
59/68:
def plot_line(K):
    print("The points you chose:)
    plt.scatter([i[0] for i in K],[i[1] for i in K])
    plt.show()
    Path = []
    for i in range(len(K)-1):
        Path.append(bresenham(K[i],K[i+1]).path)
    print("Line:")
    for P in Path:
        plt.scatter([i[0] for i in P],[i[1] for i in P])
plot_line(K)
59/69:
def plot_line(K):
    print("The points you chose:")
    plt.scatter([i[0] for i in K],[i[1] for i in K])
    plt.show()
    Path = []
    for i in range(len(K)-1):
        Path.append(bresenham(K[i],K[i+1]).path)
    print("Line:")
    for P in Path:
        plt.scatter([i[0] for i in P],[i[1] for i in P])
plot_line(K)
59/70:
def plot_line(K):
    print("The points you chose:")
    plt.scatter([i[0] for i in K],[i[1] for i in K])
    plt.show()
    Path = []
    for i in range(len(K)-1):
        Path.append(bresenham(K[i],K[i+1]).path)
    print("Line:")
    for P in Path:
        plt.scatter([i[0] for i in P],[i[1] for i in P])
    return Path
plot_line(K)
59/71:
def plot_line(K):
    print("The points you chose:")
    plt.scatter([i[0] for i in K],[i[1] for i in K])
    plt.show()
    Path = []
    for i in range(len(K)-1):
        Path.append(bresenham(K[i],K[i+1]).path)
    print("Line:")
    for P in Path:
        plt.scatter([i[0] for i in P],[i[1] for i in P])
    return Path
59/72:
Outline = make_outline("source.png")
Out = plot_line(Outline)
59/73:
Outline = make_outline("source.png")
Out = plot_line(Outline)
59/74:
Outline = make_outline("source.png")
Out = plot_line(Outline)
59/75:
Outline = make_outline("source.png")
Out = plot_line(Outline)
59/76:
def plot_line(K):
    print("The points you chose:")
    plt.scatter([i[0] for i in K],[i[1] for i in K])
    plt.show()
    Path = []
    K.append(K[0])
    for i in range(len(K)-1):
        Path.append(bresenham(K[i],K[i+1]).path)
    print("Line:")
    for P in Path:
        plt.scatter([i[0] for i in P],[i[1] for i in P])
    return Path
59/77:
Outline = make_outline("source.png")
Out = plot_line(Outline)
59/78:
Innerline = make_outline("source.png")
Inner = plot_line(Outline)
59/79:
Innerline = make_outline("source.png")
Inner = plot_line(Outline)
59/80:
Innerline = make_outline("source.png")
Inner = plot_line(Innerline)
59/81: Source = cv2.imread("source.png")
59/82: test = np.zeros(Mask.shape, dtype=np.uint8)
59/83:
for p in Inner:
    test[p[1]][p[0]] = [255,0,0]
59/84: Inner
59/85:
M = []
for i in Inner:
    M = M+I
59/86:
M = []
for i in Inner:
    M = M+i
59/87:
for p in M:
    test[p[1]][p[0]] = [255,0,0]
59/88: Image.fromarray(test)
59/89:
test = np.zeros(Mask.shape, dtype=np.uint8)
Source = cv2.imread("source.png")
Line = Inner[0]
for i in range(len(Line)-1):
    N = cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]])
    print(N)
59/90:
test = np.zeros(Mask.shape, dtype=np.uint8)
Source = cv2.imread("source.png")
Line = Inner[0]
for i in range(len(Line)-1):
    print(Source[Line[i][1]][Line[i][0]])
    print(Source[Line[i+1][1]][Line[i+1][0]])
    N = cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]])
    print(N)
59/91:
test = np.zeros(Mask.shape, dtype=np.uint8)
Source = cv2.imread("source.png")
def Average_color_bias(Line,bias):
    Loss = 0
    for i in range(len(Line)-1):
        Loss = Loss + cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]])
    Average_loss = Loss/(len(Line)-1)
    return Average_loss
59/92: image = cv2.fillPoly(Source,Inner,[255,255,255])
59/93: image = cv2.fillPoly(Source,M,[255,255,255])
59/94:
M = []
for i in Inner:
    M = M+i
59/95:
for p in M:
    test[p[1]][p[0]] = [255,0,0]
59/96: Image.fromarray(test)
59/97: image = cv2.fillPoly(Source,M,[255,255,255])
59/98:
Fill = []
for i in M:
    if i not in Fill:
        Fill.append(M)
59/99: image = cv2.fillPoly(Source,Fill,[255,255,255])
59/100: image = cv2.fillPoly(Source,Fill)
59/101: image = cv2.fillPoly(Source,Fill,color)
59/102: image = cv2.fillPoly(Source,Fill,Mask[0][0])
59/103: image = cv2.fillPoly(Source,Fill,255)
59/104: image = cv2.fillPoly(Source,Innerline,255)
59/105: image = cv2.fillPoly(Source,Innerline,color = 255)
59/106: Innerline
59/107: Fill
59/108: len(M)
59/109: len(Fill)
59/110: M
59/111:
Fill = []
for i in M:
    if i not in Fill:
        Fill.append(i)
59/112: Fill
59/113: len(Fill)
59/114: image = cv2.fillPoly(Source,Fill,color=255)
59/115:
len(Fill)
F = np.int32(Fill)
59/116: F
59/117: image = cv2.fillPoly(Source,F,color=255)
59/118: np.int32(Out)
59/119: np.int32(Outline)
59/120: O = np.int32(Outline)
59/121: image = cv2.fillPoly(Source,O,(255,255,255))
59/122: O = np.int32([Outline])
59/123: O
59/124: O = np.int32(Outline)
59/125: O
59/126: O[0]
59/127: O.shape
59/128: O = np.int32([Outline])
59/129: O
59/130: O.shape
59/131: image = cv2.fillPoly(Source,O,(255,255,255))
59/132:
len(Fill)
F = np.int32([Fill])
59/133: image = cv2.fillPoly(Source,F,(255,255,255))
59/134: Image.fromarray(image)
59/135: F = np.int32([Inner])
59/136: O = np.int32([Outline])
59/137: O.shape
59/138: image = cv2.fillPoly(Source,O,(255,255,255))
59/139: Image.fromarray(image)
59/140: Image.fromarray(image)
59/141: Image.fromarray(image)
59/142: Image.fromarray(image)
59/143:
Fill = []
for i in M:
    if i not in Fill:
        Fill.append(i)
59/144: image = cv2.fillPoly(test,O,(255,0,0))
59/145: Image.fromarray(image)
59/146: image = cv2.fillPoly(test,F,(255,0,0))
59/147: Image.fromarray(image)
59/148:
Outline = make_outline("source.png")
Out = plot_line(Outline)
59/149:
Innerline = make_outline("source.png")
Inner = plot_line(Innerline)
59/150:
test = np.zeros(Mask.shape, dtype=np.uint8)
Source = cv2.imread("source.png")
def Average_color_bias(Line,bias):
    Loss = 0
    for i in range(len(Line)-1):
        Loss = Loss + cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]])
    Average_loss = Loss/(len(Line)-1)
    return Average_loss
59/151: O = np.int32([Outline])
59/152: image = cv2.fillPoly(test,O,(255,0,0))
59/153: Image.fromarray(image)
59/154:
O = np.int32([Outline])
I = np.int32([Innerline])
59/155:
image = cv2.fillPoly(test,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
59/156:
O = np.int32([Outline])
I = np.int32([Innerline])
59/157:
image = cv2.fillPoly(test,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
59/158: Image.fromarray(image)
59/159: test = np.zeros(Mask.shape, dtype=np.uint8)
59/160:
ALL = []
for i in Out:
    ALL = ALL+i
Fill = []
for i in ALL:
    if i not in Fill:
        Fill.append(i)
59/161: F = np.int32([F])
59/162: image = cv2.fillPoly(test,F,(255,0,0))
59/163: Image.fromarray(image)
59/164:
test = np.zeros(Mask.shape, dtype=np.uint8)
image = test
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
59/165: Image.fromarray(image)
59/166:
Source = cv2.imread("source.png")
def Average_color_bias(Line,bias):
    Loss = 0
    for i in range(len(Line)-1):
        Loss = Loss + cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]])
    Average_loss = Loss/(len(Line)-1)
    return Average_loss
59/167:
def Average_color_bias(Line,bias):
    Loss = 0
    for i in range(len(Line)-1):
        Loss = Loss + cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]])
    Average_loss = Loss/(len(Line)-1)
    return Average_loss
59/168:
for Line in Out:
    print Average_color_bias(Line,0)
59/169:
for Line in Out:
    print(Average_color_bias(Line,0))
59/170:
import numpy as np
from scipy.optimize import leastsq
59/171:
def err(p, x, y):
    return p[0] * x + p[1] - y
p0 = [100, 20]
Xi=np.array([8.19,2.72,6.39,8.71,4.7,2.66,3.78])
Yi=np.array([7.01,2.78,6.47,6.71,4.1,4.23,4.05])
ret = leastsq(err, p0, args = (Xi, Yi))
print ret 
import matplotlib.pyplot as plt
k, b = ret[0]
plt.figure(figsize=(8,6))
plt.scatter(Xi,Yi,color="red",label="Sample Point",linewidth=3)
x = np.linspace(0,10,1000)
y = k * x + b
plt.plot(x,y,color="orange",label="Fitting Line",linewidth=2)
plt.legend()
plt.show()
59/172:
def err(p, x, y):
    return p[0] * x + p[1] - y
p0 = [100, 20]
Xi=np.array([8.19,2.72,6.39,8.71,4.7,2.66,3.78])
Yi=np.array([7.01,2.78,6.47,6.71,4.1,4.23,4.05])
ret = leastsq(err, p0, args = (Xi, Yi))
import matplotlib.pyplot as plt
k, b = ret[0]
plt.figure(figsize=(8,6))
plt.scatter(Xi,Yi,color="red",label="Sample Point",linewidth=3)
x = np.linspace(0,10,1000)
y = k * x + b
plt.plot(x,y,color="orange",label="Fitting Line",linewidth=2)
plt.legend()
plt.show()
59/173:
def Loss(Line,bias):
    Loss = []
    for i in range(len(Line)-1):
        Loss.append(cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]])
    return Loss
59/174:
def Loss(Line,bias):
    Loss = []
    for i in range(len(Line)-1):
        Loss.append(cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]]))
    return Loss
59/175:
for Line in Out:
    print(Average_color_bias(Line,0))
59/176:
for Line in Out:
    print(Loss(Line,0))
59/177:
Out_loss = []
for Line in Out:
    Out_loss.append(Loss(Line,0))
59/178: len(Out_loss)
59/179:
Out_loss = []
for Line in Out:
    Out_loss = Out_loss + Loss(Line,0)
59/180: len(Out_loss)
59/181: len(Out)
59/182: [len(i)for i in Out]
59/183: sum[len(i)for i in Out]
59/184: sum([len(i)for i in Out])
59/185:
len(Out_loss
arr_var = np.var(Out_loss)
59/186:
np.arra
arr = np.var(Out_loss)
59/187: arr = np.var(Out_loss)
59/188: arr
59/189:
Sum = 0
for i in Out_loss:
    Sum = Sum+pow(i-arr,2)
59/190: Sum
59/191: Out_loss
59/192: plt.plot([i*0.1 for i in range(len(50))],[Error(i) for i in range(len(20))])
59/193: plt.scatter([i*0.1 for i in range(len(50))],[Error(i) for i in range(len(20))])
59/194: plt.plot([i*0.1 for i in range(50)],[Error(i) for i in range(20)])
59/195:
def Error(arr):
    Sum = 0
    for i in Out_loss:
        Sum = Sum+pow(i-arr,2)
    return Sum
59/196: plt.plot([i*0.1 for i in range(50)],[Error(i) for i in range(50)])
59/197: plt.plot([i*0.1 for i in range(50)],[Error(i*0.3) for i in range(50)])
59/198: plt.plot([i*0.1 for i in range(50)],[Error(i*0.1) for i in range(50)])
59/199: arr = np.var(Out_loss)
59/200:
arr = np.var(Out_loss)
arr
59/201: arr = np.mean(Out_loss)
59/202: arr
59/203:
plt.plot([i*0.1 for i in range(50)],[Error(i*0.1) for i in range(50)])
plt.scatter(arr,Error(arr))
59/204:
test = np.zeros(Mask.shape, dtype=np.uint8)
image = test
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
Image.fromarray(image)
59/205:
test = np.zeros(Mask.shape, dtype=np.uint8)
image = test
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
Image.fromarray(image)
59/206:
Out_loss = []
for Line in Out:
    Out_loss = Out_loss + Loss(Line,0)
k = np.mean(Out_loss)
k
59/207:
def dedu(Out):
    ALL = []
    for i in Out:
        ALL = ALL+i
    Fill = []
    for i in ALL:
        if i not in Fill:
            Fill.append(i)
    return Fill
59/208: Set_in = dedu(Inner)
59/209: Set_out = dedu(Out)
59/210:
test = np.zeros(Mask.shape, dtype=np.uint8)
image = test
O = np.int32([Outline])
I = np.int32([Innerline])
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
Image.fromarray(image)
59/211:
Set_in = dedu(Inner)
len(Set_in)
59/212:
Set_out = dedu(Out)
len(Set_out)
59/213:
Start = Set_in[0]
End = Set_out[0]
distance = cv2.norm(Start,End)
for i in Set_in:
    for j in Set_out:
        d_temp = cv2.norm(i,j)
        if d_temp < distance:
            distance = d_temp
            Start = i
            End = j
59/214: Start
59/215: Start,End
59/216: image = cv2.line(image,Start,End,(0,255,0))
59/217: Image.fromarray(image)
59/218: image = cv2.line(image,Start,End,(0,0,255))
59/219: Image.fromarray(image)
59/220:
image = cv2.line(image,Start,End,(0,0,255))
Image.fromarray(image)
59/221: Start_side = bresenham(Start,End).path
59/222: Start_side
59/223: Image.fromarray(image)
59/224: cv2.imwrite("1.png")
59/225: cv2.imwrite(image,"1.png")
59/226: Image.fromarray(image)
59/227: k = cv2.imwrite(image,"1.png")
59/228: k = cv2.imwrite("1.png",image)
59/229: cv2.imwrite("1.png",image)
59/230: Image.fromarray(image)
59/231: cv2.imwrite("1.png",image)
59/232: Start_side
59/233:
def cross_product(p1,p2):
    return p1[0]*p2[1]-p1[1]*p2[0]
59/234: S = Start_side[0]
59/235:
Reach = [[S[0]-1,S[1]],[S[0]+1,S[1]],[S[0]+1,S[1]],[S[0],S[1]+1]]
R = Reach[0]
59/236:
#if in graph
image.shape
59/237:
#if in graph
image[58][68]
59/238:
#if in graph
image[58][69]
59/239:
#if in graph
image[58][68]
59/240: image.shape
59/241:
#if in graph
image[177][68]
59/242:
#if in graph
image[177][177]
59/243:
#if in graph
image[58][68]
59/244:
#if in graph
image[58][176]
59/245:
#if in graph
image[58][175]
59/246: image[58][176]
59/247: 1 != 2
59/248: image[58][68]
59/249: image[58][69]
59/250: image[58][69] = [255,0,0]
59/251: image[58][69] == [255,0,0]
59/252:
if image[58][69] == [255,0,0]:
    print(1)
59/253: image[58][69]
59/254: image[58][20]
59/255: image[58][68]
59/256: image[58][69]
59/257: image[58][69] == np.array([255,   0,   0], dtype=uint8)
59/258: image[58][69] == np.array([255,0,0], dtype=uint8)
59/259: image[58][69] == np.array([255,0,0], dtype=np.uint8)
59/260: np.array_equal(image[58][69],[255,0,0])
59/261: Direction = Start_side[-1] -Start_side[0]
59/262: Direction = Start_side[-1] - Start_side[0]
59/263: Direction = [Start_side[-1][0] - Start_side[0][0],Start_side[-1][1] - Start_side[0][1]]
59/264: Direction
59/265:
def ju(R,image,Direction)
    #if in graph
    #x 
    if R[0]>image.shape[1]:
        return False
    #y
    if R[1]>image.shape[0]:
        return False
    #means out of adjust range
    if np.array_equal(image[R[1]][R[0]],[255,0,0]) == False:
        return False
    if cross_product(Direction,R)<0
        return False
    return True
59/266:
def ju(R,image,Direction):
    #if in graph
    #x 
    if R[0]>image.shape[1]:
        return False
    #y
    if R[1]>image.shape[0]:
        return False
    #means out of adjust range
    if np.array_equal(image[R[1]][R[0]],[255,0,0]) == False:
        return False
    if cross_product(Direction,R)<0
        return False
    return True
59/267:
def ju(R,image,Direction):
    #if in graph
    #x 
    if R[0]>image.shape[1]:
        return False
    #y
    if R[1]>image.shape[0]:
        return False
    #means out of adjust range
    if np.array_equal(image[R[1]][R[0]],[255,0,0]) == False:
        return False
    if cross_product(Direction,R)<0:
        return False
    return True
59/268: ju(R)
59/269: ju(R,image,Direction)
59/270:
for i in Reach:
    print ju(i,image,Direction)
59/271:
for i in Reach:
    print(ju(i,image,Direction))
59/272: Reach
59/273: S
59/274:
Reach = [[S[0]-1,S[1]],[S[0]+1,S[1]],[S[0],S[1]-1],[S[0],S[1]+1]]
R = Reach[0]
59/275: Reach
59/276:
for i in Reach:
    print(ju(i,image,Direction))
59/277:
for i in Reach:
    print(image[i[1]][i[0]])
59/278:
for i in Reach:
    print(cross_product(Direction,i))
59/279: Direction
59/280:
for i in Reach:
    print(cross_product(Direction,i-S))
59/281:
def sub(v1,v2):
    return [v1[0]-v2[0],v1[1]-v2[1]]
59/282: Direction = sub(Start_side[-1],Start_side[0])
59/283:
Direction = sub(Start_side[-1],Start_side[0])
Direction
59/284: Direction = [Start_side[-1][0] - Start_side[0][0],Start_side[-1][1] - Start_side[0][1]]
59/285:
Direction = [Start_side[-1][0] - Start_side[0][0],Start_side[-1][1] - Start_side[0][1]]
Direction
59/286:
for i in Reach:
    print(cross_product(Direction,sub(i-S)))
59/287:
for i in Reach:
    print(cross_product(Direction,sub(i-list(S)))
59/288:
for i in Reach:
    print(cross_product(Direction,sub(i-list(S))
59/289:
for i in Reach:
    print(cross_product(Direction,sub(i-list(S))))
59/290: Reach[0]
59/291: S
59/292: list(S)
59/293: sub(Reach[0]-list(S))
59/294: sub(Reach[0],list(S))
59/295:
for i in Reach:
    print(cross_product(Direction,sub(i,list(S))))
59/296:
def ju(R,image,Direction):
    #if in graph
    #x 
    if R[0]>image.shape[1]:
        return False
    #y
    if R[1]>image.shape[0]:
        return False
    #means out of adjust range
    if np.array_equal(image[R[1]][R[0]],[255,0,0]) == False:
        return False
    if cross_product(Direction,sub(R,list(S)))<0:
        return False
    return True
59/297:
for i in Reach:
    print(ju(i,image,Direction))
59/298:
def if_target(R,image,Direction):
    #if in graph
    #x 
    if R[0]>image.shape[1]:
        return False
    #y
    if R[1]>image.shape[0]:
        return False
    #means out of adjust range
    if np.array_equal(image[R[1]][R[0]],[255,0,0]) == False:
        return False
    if cross_product(Direction,sub(R,list(S)))<0:
        return False
    return True
59/299:
def find_pair(Reach)
    for i in Reach:
        if if_target(i,image,Direction):
            return i
    print("No pair")
    return False
59/300:
def find_pair(Reach):
    for i in Reach:
        if if_target(i,image,Direction):
            return i
    print("No pair")
    return False
59/301: Reach = [[S[0]-1,S[1]],[S[0]+1,S[1]],[S[0],S[1]-1],[S[0],S[1]+1]]
59/302:
def find_pair(S):
    Reach = [[S[0]-1,S[1]],[S[0]+1,S[1]],[S[0],S[1]-1],[S[0],S[1]+1]]
    for i in Reach:
        if if_target(i,image,Direction):
            return i
    print("No pair")
    return False
59/303:
for s in Start_side:
    ans = find_pair(s)
    if ans:
        print(ans)
59/304:
def get_pair_list(Search_edge):
    Pair = []
    for s in Search_edge:
        ans = find_pair(s)
        if ans:
            Pair.append(ans)
        else:
            print("Error")
            return False
    return Pair
59/305: get_pair_list(Start_side)
59/306: Target_side = get_pair_list(Start_side)
59/307:
Target_side = get_pair_list(Start_side)
Target_side
59/308:
for i in Target_side:
    image[i[1]][i[0]] = [100,100,100]
59/309: Image.fromarray(image)
59/310: cv2.imwrite("1.png",image)
59/311: image[image == [255,255,255]]
59/312: image[image == [255,255,255]].shape
59/313: image[image == [255,255,255]]
59/314: image[image == [255,0,0]]
59/315: image[image == [255,0,0]].shape
59/316: image.shape
59/317:
count = 0
for x in range(image.shape[1]):
    for y in range(image.shape[0]):
        if np.array_equal(image[y][x],[255,0,0]):
            count = count + 1
59/318: count
59/319: image.shape[1]*image.shape[0]
60/1:
class bresenham:
    def __init__(self, start, end):
        self.start = list(start)
        self.end = list(end)
        self.path = []
        self.steep = abs(self.end[1]-self.start[1]) > abs(self.end[0]-self.start[0])
        if self.steep:
            self.start = self.swap(self.start[0],self.start[1])
            self.end = self.swap(self.end[0],self.end[1])
        if self.start[0] > self.end[0]:
            _x0 = int(self.start[0])
            _x1 = int(self.end[0])
            self.start[0] = _x1
            self.end[0] = _x0
            _y0 = int(self.start[1])
            _y1 = int(self.end[1])
            self.start[1] = _y1
            self.end[1] = _y0
        dx = self.end[0] - self.start[0]
        dy = abs(self.end[1] - self.start[1])
        error = 0
        derr = dy/float(dx)
        ystep = 0
        y = self.start[1]
        if self.start[1] < self.end[1]: ystep = 1
        else: ystep = -1
        for x in range(self.start[0],self.end[0]+1):
            if self.steep:
                self.path.append((y,x))
            else:
                self.path.append((x,y))
            error += derr
            if error >= 0.5:
                y += ystep
                error -= 1.0
    def swap(self,n1,n2):
        return [n2,n1]
60/2:
import cv2
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
60/3:
Mask = cv2.imread("mask.png")
Source = cv2.imread("source.png")
Target = cv2.imread("target.png")
60/4:
def make_outline(path):
    img = cv2.imread(path)
    Points = []
    def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
        if event == cv2.EVENT_LBUTTONDOWN:
            xy = "%d,%d" % (x, y)
            Points.append([x,y])
            cv2.circle(img, (x,y), 1, (0, 0, 255), thickness=-1)
            cv2.imshow("image", img)
    cv2.namedWindow("image")
    cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
    cv2.imshow("image", img)
    cv2.waitKey(0)
    cv2.destroyWindow("image")
    return Points
60/5:
def plot_line(K):
    print("The points you chose:")
    plt.scatter([i[0] for i in K],[i[1] for i in K])
    plt.show()
    Path = []
    K.append(K[0])
    for i in range(len(K)-1):
        Path.append(bresenham(K[i],K[i+1]).path)
    print("Line:")
    for P in Path:
        plt.scatter([i[0] for i in P],[i[1] for i in P])
    return Path
60/6:
Outline = make_outline("source.png")
Out = plot_line(Outline)
60/7:
Innerline = make_outline("source.png")
Inner = plot_line(Innerline)
60/8:
def Loss(Line,bias):
    Loss = []
    for i in range(len(Line)-1):
        Loss.append(cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]]))
    return Loss
60/9:
test = np.zeros(Mask.shape, dtype=np.uint8)
image = test
O = np.int32([Outline])
I = np.int32([Innerline])
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
Image.fromarray(image)
60/10:
Out_loss = []
for Line in Out:
    Out_loss = Out_loss + Loss(Line,0)
k = np.mean(Out_loss)
k
60/11:
def dedu(Out):
    ALL = []
    for i in Out:
        ALL = ALL+i
    Fill = []
    for i in ALL:
        if i not in Fill:
            Fill.append(i)
    return Fill
60/12:
Set_in = dedu(Inner)
len(Set_in)
60/13:
Set_out = dedu(Out)
len(Set_out)
60/14:
Start = Set_in[0]
End = Set_out[0]
distance = cv2.norm(Start,End)
for i in Set_in:
    for j in Set_out:
        d_temp = cv2.norm(i,j)
        if d_temp < distance:
            distance = d_temp
            Start = i
            End = j
60/15:
image = cv2.line(image,Start,End,(0,0,255))
Image.fromarray(image)
60/16: Start_side = bresenham(Start,End).path
60/17: Start_side
60/18:
def sub(v1,v2):
    return [v1[0]-v2[0],v1[1]-v2[1]]
60/19:
Direction = sub(Start_side[-1],Start_side[0])
Direction
60/20:
def cross_product(p1,p2):
    return p1[0]*p2[1]-p1[1]*p2[0]
60/21: S = Start_side[0]
60/22:
def if_target(R,image,Direction):
    #if in graph
    #x 
    if R[0]>image.shape[1]:
        return False
    #y
    if R[1]>image.shape[0]:
        return False
    #means out of adjust range
    if np.array_equal(image[R[1]][R[0]],[255,0,0]) == False:
        return False
    if cross_product(Direction,sub(R,list(S)))<0:
        return False
    return True
60/23:
def find_pair(S):
    Reach = [[S[0]-1,S[1]],[S[0]+1,S[1]],[S[0],S[1]-1],[S[0],S[1]+1]]
    for i in Reach:
        if if_target(i,image,Direction):
            return i
    print("No pair")
    return False
60/24:
def get_pair_list(Search_edge):
    Pair = []
    for s in Search_edge:
        ans = find_pair(s)
        if ans:
            Pair.append(ans)
        else:
            print("Error")
            return False
    return Pair
60/25:
Target_side = get_pair_list(Start_side)
Target_side
60/26:
for i in Target_side:
    image[i[1]][i[0]] = [100,100,100]
60/27: Image.fromarray(image)
60/28: count
60/29:
count = 0
for x in range(image.shape[1]):
    for y in range(image.shape[0]):
        if np.array_equal(image[y][x],[255,0,0]):
            count = count + 1
60/30: count
60/31: image.shape[1]*image.shape[0]
60/32:
def around4(S):
    return [[S[0]-1,S[1]],[S[0]+1,S[1]],[S[0],S[1]-1],[S[0],S[1]+1]]
60/33:
Node_dic = {}
ID = 0
60/34:
for n in Start_side:
    Node_dic[ID] = n
    ID = ID + 1
60/35:
for x in range(image.shape[1]):
    for y in range(image.shape[0]):
        if np.array_equal(image[y][x],[255,0,0]):
            Vertex.append(ID)
            ID = ID + 1
60/36:
for n in Target_side:
    Node_dic[ID] = n
    ID = ID + 1
60/37:
for x in range(image.shape[1]):
    for y in range(image.shape[0]):
        if np.array_equal(image[y][x],[255,0,0]):
            Node_dic[ID] = (x,y)
            ID = ID + 1
60/38: len(Node_dic)
60/39: (1,2) == [1,2]
60/40: (1,2) == (1,2)
60/41: type((1,2))
60/42:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side
Target_side
60/43:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
60/44: Start_side = bresenham(Start,End).path
60/45: Start_side
60/46:
def sub(v1,v2):
    return [v1[0]-v2[0],v1[1]-v2[1]]
60/47:
Direction = sub(Start_side[-1],Start_side[0])
Direction
60/48:
def cross_product(p1,p2):
    return p1[0]*p2[1]-p1[1]*p2[0]
60/49: S = Start_side[0]
60/50:
def if_target(R,image,Direction):
    #if in graph
    #x 
    if R[0]>image.shape[1]:
        return False
    #y
    if R[1]>image.shape[0]:
        return False
    #means out of adjust range
    if np.array_equal(image[R[1]][R[0]],[255,0,0]) == False:
        return False
    if cross_product(Direction,sub(R,list(S)))<0:
        return False
    return True
60/51:
def around4(S):
    return [[S[0]-1,S[1]],[S[0]+1,S[1]],[S[0],S[1]-1],[S[0],S[1]+1]]
60/52:
def find_pair(S):
    Reach = around4(S)
    for i in Reach:
        if if_target(i,image,Direction):
            return i
    print("No pair")
    return False
60/53:
def get_pair_list(Search_edge):
    Pair = []
    for s in Search_edge:
        ans = find_pair(s)
        if ans:
            Pair.append(ans)
        else:
            print("Error")
            return False
    return Pair
60/54:
def around4(S):
    return [[S[0]-1,S[1]],[S[0]+1,S[1]],[S[0],S[1]-1],[S[0],S[1]+1]]
60/55:
def find_pair(S):
    Reach = around4(S)
    for i in Reach:
        if if_target(i,image,Direction):
            return i
    print("No pair")
    return False
60/56:
def get_pair_list(Search_edge):
    Pair = []
    for s in Search_edge:
        ans = find_pair(s)
        if ans:
            Pair.append(ans)
        else:
            print("Error")
            return False
    return Pair
60/57:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
60/58: Start_side
60/59: Start_side[0]
60/60: find_pair(Start_side[0])
60/61:
S = Start_side[0]
around4(S)
60/62:
S = Start_side[0]
Reach = around4(S)
for i in Reach:
    if if_target(i,image,Direction):
        return i
print("No pair")
60/63:
S = Start_side[0]
Reach = around4(S)
for i in Reach:
    if if_target(i,image,Direction):
        print(o)
print("No pair")
60/64:
S = Start_side[0]
Reach = around4(S)
for i in Reach:
    if if_target(i,image,Direction):
        print(i)
print("No pair")
60/65:
S = Start_side[0]
Reach = around4(S)
Direction
60/66: Image.fromarray(image)
60/67:
image = cv2.line(image,Start,End,(0,0,255))
Image.fromarray(image)
60/68:
test = np.zeros(Mask.shape, dtype=np.uint8)
image = test
O = np.int32([Outline])
I = np.int32([Innerline])
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
Image.fromarray(image)
60/69:
Out_loss = []
for Line in Out:
    Out_loss = Out_loss + Loss(Line,0)
k = np.mean(Out_loss)
k
60/70:
def dedu(Out):
    ALL = []
    for i in Out:
        ALL = ALL+i
    Fill = []
    for i in ALL:
        if i not in Fill:
            Fill.append(i)
    return Fill
60/71:
Set_out = dedu(Out)
len(Set_out)
60/72:
Set_in = dedu(Inner)
len(Set_in)
60/73:
Start = Set_in[0]
End = Set_out[0]
distance = cv2.norm(Start,End)
for i in Set_in:
    for j in Set_out:
        d_temp = cv2.norm(i,j)
        if d_temp < distance:
            distance = d_temp
            Start = i
            End = j
60/74:
image = cv2.line(image,Start,End,(0,0,255))
Image.fromarray(image)
60/75: Start_side = bresenham(Start,End).path
60/76: Start_side = bresenham(Start,End).path
60/77: Start_side
60/78:
def sub(v1,v2):
    return [v1[0]-v2[0],v1[1]-v2[1]]
60/79:
Direction = sub(Start_side[-1],Start_side[0])
Direction
60/80:
def cross_product(p1,p2):
    return p1[0]*p2[1]-p1[1]*p2[0]
60/81:
def if_target(R,image,Direction):
    #if in graph
    #x 
    if R[0]>image.shape[1]:
        return False
    #y
    if R[1]>image.shape[0]:
        return False
    #means out of adjust range
    if np.array_equal(image[R[1]][R[0]],[255,0,0]) == False:
        return False
    if cross_product(Direction,sub(R,list(S)))<0:
        return False
    return True
60/82:
def around4(S):
    return [[S[0]-1,S[1]],[S[0]+1,S[1]],[S[0],S[1]-1],[S[0],S[1]+1]]
60/83:
def find_pair(S):
    Reach = around4(S)
    for i in Reach:
        if if_target(i,image,Direction):
            return i
    print("No pair")
    return False
60/84:
def get_pair_list(Search_edge):
    Pair = []
    for s in Search_edge:
        ans = find_pair(s)
        if ans:
            Pair.append(ans)
        else:
            print("Error")
            return False
    return Pair
60/85:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
60/86:
for i in Target_side:
    image[i[1]][i[0]] = [100,100,100]
60/87: Image.fromarray(image)
60/88:
Node_dic = {}
ID = 0
60/89:
for n in Start_side:
    Node_dic[n] = ID
    ID = ID + 1
60/90:
for n in Target_side:
    Node_dic[n] = ID
    ID = ID + 1
60/91:
Edge = []
Weight = []
60/92:
for x in range(image.shape[1]):
    for y in range(image.shape[0]):
        if np.array_equal(image[y][x],[255,0,0]):
            Node_dic[(x,y)] = I 
            ID = ID + 1
60/93:
def get_color(node,img):
    return img[node[1]][node[0]]
def get_edge(node1,node2):
    return (Node_dic[node1],Node_dic[node2],\
            cv2.norm(get_color(node1,Source),get_color(node2,Source)))
60/94:
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,Source),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R))
Edge
60/95:
for S in Start_side:
    Reach = around4(S)
    print(Reach)
    for R in Reach:
        if np.array_equal(get_color(R,Source),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R))
Edge
60/96:
for S in Start_side:
    Reach = around4(S)
    print(Reach)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
Edge
60/97:
def get_color(node,img):
    return img[node[1]][node[0]]
def get_edge(node1,node2,Source):
    return (Node_dic[node1],Node_dic[node2],\
            cv2.norm(get_color(node1,Source),get_color(node2,Source)))
60/98:
for S in Start_side:
    Reach = around4(S)
    print(Reach)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
Edge
60/99:
def around4(S):
    return [(S[0]-1,S[1]),(S[0]+1,S[1]),(S[0],S[1]-1),(S[0],S[1]+1)]
60/100:
for S in Start_side:
    Reach = around4(S)
    print(Reach)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
Edge
60/101:
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
Edge
60/102:
for x in range(image.shape[1]):
    for y in range(image.shape[0]):
        if np.array_equal(image[y][x],[255,0,0]):
            Node_dic[(x,y)] = ID
            ID = ID + 1
60/103:
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
Edge
60/104: Reach = around4(S)
60/105: Reach
60/106: Node_dic[(69, 67)]
60/107: Node_dic[(71, 67)]
60/108: Node_dic[(70, 66)]
60/109:
def get_color(node,img):
    return img[node[1]][node[0]]
def get_edge(node1,node2,Source):
    return (Node_dic[node1],Node_dic[node2],cv2.norm(get_color(node1,Source),get_color(node2,Source)))
60/110:
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
Edge
60/111:
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        print(S)
        print(R)
        print(Node_dic[S])
        print(Node_dic[R])
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
Edge
60/112:
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        print(S)
        print(R)
        print(Node_dic[S])
        print(Node_dic[R])
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
Edge
60/113:
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            print(S)
            print(R)
            print(Node_dic[S])
            print(Node_dic[R])
            #Red is ok
            Edge.append(get_edge(S,R,Source))
Edge
60/114:
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            print(S)
            print(R)
            print(Node_dic[S])
            print(Node_dic[R])
            #Red is ok
            Edge.append(get_edge(S,R,Source))
60/115: Node_dic[(71, 62)]
60/116: Node_dic[(71, 67)]
60/117:
def get_color(node,img):
    return img[node[1]][node[0]]
def get_edge(node1,node2,Source):
    return cv2.norm(get_color(node1,Source),get_color(node2,Source))
60/118:
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            print(S)
            print(R)
            print(Node_dic[S])
            print(Node_dic[R])
            #Red is ok
            Edge.append(get_edge(S,R,Source))
60/119: Edge
60/120: Edge = []
60/121:
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            print(S)
            print(R)
            print(Node_dic[S])
            print(Node_dic[R])
            #Red is ok
            Edge.append(get_edge(S,R,Source))
60/122: Edge
60/123:
def get_color(node,img):
    return img[node[1]][node[0]]
def get_edge(node1,node2,Source):
    return (Node_dic[S],Node_dic[R],cv2.norm(get_color(node1,Source),get_color(node2,Source)))
60/124:
Edge = []
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            print(S)
        print(R)
        print()
        print(Node_dic[R])
            #Red is ok
            Edge.append(get_edge(S,R,Source))
Edge
60/125:
Edge = []
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
Edge
60/126:
Move_area = []
for x in range(image.shape[1]):
    for y in range(image.shape[0]):
        if np.array_equal(image[y][x],[255,0,0]):
            Node_dic[(x,y)] = ID
            Move_area.append((x,y))
            ID = ID + 1
60/127: len(Move_area)
60/128:
Edge = []
def add_cut(side):
    for S in side:
        Reach = around4(S)
        for R in Reach:
            if np.array_equal(get_color(R,image),[255,0,0]):
                #Red is ok
                Edge.append(get_edge(S,R,Source))
add_cut(Start_side)
add_cut(Target_side)
Edge
60/129:
Edge = []
def add_cut(side):
    for S in side:
        Reach = around4(S)
        for R in Reach:
            if np.array_equal(get_color(R,image),[255,0,0]):
                #Red is ok
                Edge.append(get_edge(S,R,Source))
    return 0
add_cut(Start_side)
add_cut(Target_side)
Edge
60/130:
Edge = []
side = Start_side
for S in side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
60/131: Edge
60/132:
Edge = []
def add_cut(side)
    for S in side:
        Reach = around4(S)
        for R in Reach:
            if np.array_equal(get_color(R,image),[255,0,0]):
                #Red is ok
                Edge.append(get_edge(S,R,Source))
60/133:
Edge = []
def add_cut(side):
    for S in side:
        Reach = around4(S)
        for R in Reach:
            if np.array_equal(get_color(R,image),[255,0,0]):
                #Red is ok
                Edge.append(get_edge(S,R,Source))
60/134:
add_cut(Start_side)
add_cut(Target_side)
Edge
60/135: add_cut(Start_side)
60/136:
Edge = []
def add_cut(side):
    for S in side:
        Reach = around4(S)
        for R in Reach:
            if np.array_equal(get_color(R,image),[255,0,0]):
                #Red is ok
                Edge.append(get_edge(S,R,Source))
60/137: add_cut(Start_side)
60/138:
Edge = []
def add_cut(side):
    for S in side:
        Reach = around4(S)
        for R in Reach:
            if np.array_equal(get_color(R,image),[255,0,0]):
                #Red is ok
                Edge.append(get_edge(S,R,Source))
    return 0
60/139: add_cut(Start_side)
60/140:
Edge = []
def add_cut(side,Edge):
    for S in side:
        Reach = around4(S)
        for R in Reach:
            if np.array_equal(get_color(R,image),[255,0,0]):
                #Red is ok
                Edge.append(get_edge(S,R,Source))
    return Edge
60/141: Edge = add_cut(Start_side)
60/142: Edge = add_cut(Start_side,Edge)
60/143:
def add_cut(side,Edge):
    for S in side:
        Reach = around4(S)
        for R in Reach:
            if np.array_equal(get_color(R,image),[255,0,0]):
                #Red is ok
                Edge.append(get_edge(S,R,Source))
    return Edge
60/144:
Edge = []
Edge = add_cut(Start_side,Edge)
60/145:
Edge = []
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
60/146: Edge
60/147:
for S in Target_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
60/148: Edge
60/149:
for node in Move_area:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            Edge.append(get_edge(node,R,Source))
60/150: len(Edge)
60/151: Edge[1000:1100]
60/152: Edge[1000:1200]
60/153:
Edge = []
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
60/154:
for S in Target_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
60/155: Edge
60/156: Move_area[:100]
60/157:
Normal_edge = []
for node in Move_area:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            Normal_edge.append(get_edge(node,R,Source))
60/158: Normal_edge
60/159: Move_area[:100
60/160: Move_area[:100]
60/161: plt.scatter(Move_area[0],Move_area[1])
60/162: plt.scatter(Move_area)
60/163: plt.scatter([i[0] for i in Move_area],[i[1] for i in Move_area])
60/164:
Normal_edge = []
M = Move_area[:20]
for node in M:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    print(Reach)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            Normal_edge.append(get_edge(node,R,Source))
60/165:
Normal_edge = []
M = Move_area[:20]
for node in M:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        print(R)
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            Normal_edge.append(get_edge(node,R,Source))
60/166:
Normal_edge = []
M = Move_area[:20]
for node in M:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        print("R:"R)
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            Normal_edge.append(get_edge(node,R,Source))
60/167:
Normal_edge = []
M = Move_area[:20]
for node in M:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        print("R:")
        print(R)
        print("node:")
        print(node)
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            Normal_edge.append(get_edge(node,R,Source))
60/168:
Normal_edge = []
M = Move_area[:20]
for node in M:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        print("R:")
        print(R,node)
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            Normal_edge.append(get_edge(node,R,Source))
60/169:
Normal_edge = []
M = Move_area[:20]
for node in M:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            print(R,node)
            Normal_edge.append(get_edge(node,R,Source))
60/170:
Normal_edge = []
M = Move_area[:20]
for node in M:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            print(get_edge(node,R,Source))
60/171:
Normal_edge = []
M = Move_area[:20]
for node in M:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            print(R,node)
            Normal_edge.append(get_edge(node,R,Source))
60/172: Node_dic[(33, 33)]
60/173: Node_dic[(33, 32)]
60/174:
Normal_edge = []
M = Move_area[:20]
for node in M:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            print(R,node)
            print(Node_dic[R],Node_dic[node])
            Normal_edge.append(get_edge(R,S,Source))
60/175:
def get_color(node,img):
    return img[node[1]][node[0]]
def get_edge(node1,node2,Source):
    return (Node_dic[node1],Node_dic[node2],cv2.norm(get_color(node1,Source),get_color(node2,Source)))
60/176:
a = [480,250,3899,2000,260]
sum(a)
60/177:
Normal_edge = []
M = Move_area[:20]
for node in M:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            print(R,node)
            print(Node_dic[R],Node_dic[node])
            print(get_edge(R,S,Source))
            Normal_edge.append(get_edge(R,S,Source))
60/178:
Normal_edge = []
M = Move_area[:100]
for node in M:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            Normal_edge.append(get_edge(R,S,Source))
60/179: Normal_edge
60/180:
Normal_edge = []
M = Move_area[:100]
for node in M:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            Normal_edge.append(get_edge(R,node,Source))
60/181: Normal_edge
60/182:
Normal_edge = []
for node in Normal_edge:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            Normal_edge.append(get_edge(R,node,Source))
60/183: len(Normal_edge)
60/184: len(Normal_edge)
60/185:
Normal_edge = []
for node in Move_area:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            Normal_edge.append(get_edge(R,node,Source))
60/186: len(Normal_edge)
60/187: Normal_edge[800:1000]
60/188: print(Normal_edge[0])
60/189:
with open("Edge") as f:
    f.write(Normal_edge[0])
60/190:
with open("Edge", "w" ) as f:
    f.write(Normal_edge[0])
60/191: str(Normal_edge[0])
60/192:
Node_All = Start_side + Target_side + Move_area
Edge_All = Edge + Normal_edge
60/193:
with open("Edge","w") as f:
    for line in Edge_All:
    f.write(str(line))
60/194: Edge_All[0]
60/195: str(Edge_All[0])
60/196: line = Edge_All[0]
60/197: line
60/198: line[0]+" "+line[1]+" "+"%.2f" % line[2]
60/199: line[0]+" "+line[1]+" "+("%.2f" % line[2])
60/200: line[0]+" "+line[1]+" "
60/201: str(line[0])+" "+str(line[1])+" "+("%.2f" % line[2])
60/202:
with open("Edge","w") as f:
    for line in Edge_All:
        f.write(str(line[0])+" "+str(line[1])+" "+("%.2f" % line[2]))
60/203:
with open("Edge","w") as f:
    for line in Edge_All:
        f.write(str(line[0])+" "+str(line[1])+" "+("%.2f" % line[2])+"\n")
60/204: Node_All[0]
60/205: len(Node_All)
60/206: len(Node_dic)
60/207:
for keys,values in Node_dic.items():
    print(keys)
    print(values)
    break
60/208:
for node,ID in Node_dic.items():
    print(str(node))
    print(str(ID))
    break
60/209:
for node,ID in Node_dic.items():
    print(str(node)+" "+str(ID))
    break
60/210:
for node,ID in Node_dic.items():
    print(str(node[0])+" "+str(node[1])+" "+str(ID))
    break
60/211:
with open("Node","w") as f:
    for node,ID in Node_dic.items():
    f.write(str(node[0])+" "+str(node[1])+" "+str(ID))
60/212:
with open("Node","w") as f:
    for node,ID in Node_dic.items():
        f.write(str(node[0])+" "+str(node[1])+" "+str(ID))
60/213:
with open("Node","w") as f:
    for node,ID in Node_dic.items():
        f.write(str(node[0])+" "+str(node[1])+" "+str(ID)+"\n")
60/214:
Node_dic = {}
ID = 0
60/215:
for n in Start_side:
    Node_dic[n] = ID
    ID = ID + 1
60/216:
for n in Target_side:
    Node_dic[n] = ID
    ID = ID + 1
60/217: Edge = []
60/218:
Move_area = []
for x in range(image.shape[1]):
    for y in range(image.shape[0]):
        if np.array_equal(image[y][x],[255,0,0]):
            Node_dic[(x,y)] = ID
            Move_area.append((x,y))
            ID = ID + 1
60/219:
def get_color(node,img):
    return img[node[1]][node[0]]
def get_edge(node1,node2,Source):
    return (Node_dic[node1],Node_dic[node2],cv2.norm(get_color(node1,Source),get_color(node2,Source)))
60/220:
Edge = []
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
60/221:
for S in Target_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
60/222: Edge
60/223: plt.scatter([i[0] for i in Move_area],[i[1] for i in Move_area])
60/224:
Normal_edge = []
for node in Move_area:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            Normal_edge.append(get_edge(R,node,Source))
60/225: len(Normal_edge)
60/226: str(Normal_edge[0])
60/227:
Node_All = Start_side + Target_side + Move_area
Edge_All = Edge + Normal_edge
60/228:
with open("Edge","w") as f:
    for line in Edge_All:
        f.write(str(line[0])+" "+str(line[1])+" "+("%.2f" % line[2])+"\n")
60/229:
with open("Node","w") as f:
    for node,ID in Node_dic.items():
        f.write(str(node[0])+" "+str(node[1])+" "+str(ID)+"\n")
60/230: Start_side
60/231: Node_dic[Start_side[0]]
60/232: Node_dic[Target_side[0]]
60/233: Inner
60/234:
Loss = [Loss(i,0) for i in Inner]
Loss
60/235: Inner[0]
60/236: Loss(Inner[0],0)
60/237: Inner[0]
60/238: Loos(Inner[0],0)
60/239: Loss(Inner[0],0)
60/240:
Loss = []
Line = Inner[0]
for i in range(len(Line)-1):
    Loss.append(cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]]))
60/241: Loss
60/242: Line
60/243:
L = [Loss(i,0) for i in Inner]
L
60/244:
def Loss(Line,bias):
    Loss = []
    for i in range(len(Line)-1):
        Loss.append(cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]]))
    return Loss
60/245:
L = [Loss(i,0) for i in Inner]
L
60/246: k
60/247: with open("path") as f:
60/248:
with open("path") as f:
    p = f.read()
60/249: p
60/250: p.strip("\n")
60/251: p.strip("\n").split()
60/252: p.strip("\n").split(" ")
60/253: path =p.strip("\n").split(" ")
60/254: path[0]
60/255: path[1]
60/256: path[2]
60/257: path[3]
60/258: path =p.strip("\n").split()
60/259: path
60/260:
path = path[1:]
path
60/261: p.strip("\n").split("[]")
60/262: path =p.strip("\n").split("[".)
60/263: p.strip("\n").split("[]")
60/264: p.strip("\n").split("[","]")
60/265: p.strip("\n").split("[")
60/266: p.strip("\n").split("[").split("]")
60/267: p.strip("\n")
60/268: x = p.strip("\n")
60/269: x.strip("[")
60/270: x.split("[")
60/271: x.split("[")[1]
60/272: (x.split("[")[1]).split("]")
60/273: (x.split("[")[1]).strip("]")
60/274: (x.split("[")[1]).strip("]").split()
60/275: path = ((p.strip("\n")).split("[")[1]).strip("]").split()
60/276: pim = image
60/277: ID_dic = {v: k for k, v in Node_dic.items()}
60/278:
for i in path:
    p = ID_dic[int(i)]
    pim[p[1]][p[0]] = [200,200,200]
60/279: Image.fromarray(pim)
60/280:
enclose = []
for i in path:
    p = ID_dic[int(i)]
    enclose.append(p)
    pim[p[1]][p[0]] = [200,200,200]
60/281: Image.fromarray(pim)
60/282:
O = np.int32([enclose])
T = cv2.fillPoly(pim,O,(255,0,0))
60/283: Image.fromarray(T)
60/284:
O = np.int32([enclose])
T = cv2.fillPoly(pim,O,(180,20,20))
60/285: Image.fromarray(T)
60/286:
O = np.int32([enclose])
T = cv2.fillPoly(pim,O,(120,120,120))
60/287: Image.fromarray(T)
60/288:
E = np.int32([enclose])
T = cv2.fillPoly(test,E,(255,255,255))
60/289: Image.fromarray(T)
60/290: Image.fromarray(test)
60/291: Image.fromarray(T)
60/292: Image.fromarray(image)
60/293: Image.fromarray(images)
60/294: Image.fromarray(image)
60/295:
test = np.zeros(Mask.shape, dtype=np.uint8)
E = np.int32([enclose])
T = cv2.fillPoly(test,E,(255,255,255))
60/296: Image.fromarray(E)
60/297: Image.fromarray(E)
60/298: Image.fromarray(T)
60/299: enclose
60/300: Loss(enclose,0)
60/301: sum(Loss(enclose,0))
60/302: sum(Loss(enclose,0))/(len(Loss))
60/303: sum(Loss(enclose,0))/(len(enclose))
61/1:
with open("path") as f:
    p = f.read()
61/2: path = ((p.strip("\n")).split("[")[1]).strip("]").split()
61/3: pim = image
61/4:
class bresenham:
    def __init__(self, start, end):
        self.start = list(start)
        self.end = list(end)
        self.path = []
        self.steep = abs(self.end[1]-self.start[1]) > abs(self.end[0]-self.start[0])
        if self.steep:
            self.start = self.swap(self.start[0],self.start[1])
            self.end = self.swap(self.end[0],self.end[1])
        if self.start[0] > self.end[0]:
            _x0 = int(self.start[0])
            _x1 = int(self.end[0])
            self.start[0] = _x1
            self.end[0] = _x0
            _y0 = int(self.start[1])
            _y1 = int(self.end[1])
            self.start[1] = _y1
            self.end[1] = _y0
        dx = self.end[0] - self.start[0]
        dy = abs(self.end[1] - self.start[1])
        error = 0
        derr = dy/float(dx)
        ystep = 0
        y = self.start[1]
        if self.start[1] < self.end[1]: ystep = 1
        else: ystep = -1
        for x in range(self.start[0],self.end[0]+1):
            if self.steep:
                self.path.append((y,x))
            else:
                self.path.append((x,y))
            error += derr
            if error >= 0.5:
                y += ystep
                error -= 1.0
    def swap(self,n1,n2):
        return [n2,n1]
61/5:
import cv2
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
61/6:
Mask = cv2.imread("mask.png")
Source = cv2.imread("source.png")
Target = cv2.imread("target.png")
61/7:
def make_outline(path):
    img = cv2.imread(path)
    Points = []
    def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
        if event == cv2.EVENT_LBUTTONDOWN:
            xy = "%d,%d" % (x, y)
            Points.append([x,y])
            cv2.circle(img, (x,y), 1, (0, 0, 255), thickness=-1)
            cv2.imshow("image", img)
    cv2.namedWindow("image")
    cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
    cv2.imshow("image", img)
    cv2.waitKey(0)
    cv2.destroyWindow("image")
    return Points
61/8:
def plot_line(K):
    print("The points you chose:")
    plt.scatter([i[0] for i in K],[i[1] for i in K])
    plt.show()
    Path = []
    K.append(K[0])
    for i in range(len(K)-1):
        Path.append(bresenham(K[i],K[i+1]).path)
    print("Line:")
    for P in Path:
        plt.scatter([i[0] for i in P],[i[1] for i in P])
    return Path
61/9:
Outline = make_outline("source.png")
Out = plot_line(Outline)
61/10:
Innerline = make_outline("source.png")
Inner = plot_line(Innerline)
61/11:
def Loss(Line,bias):
    Loss = []
    for i in range(len(Line)-1):
        Loss.append(cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]]))
    return Loss
61/12:
test = np.zeros(Mask.shape, dtype=np.uint8)
image = test
O = np.int32([Outline])
I = np.int32([Innerline])
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
Image.fromarray(image)
62/1:
class bresenham:
    def __init__(self, start, end):
        self.start = list(start)
        self.end = list(end)
        self.path = []
        self.steep = abs(self.end[1]-self.start[1]) > abs(self.end[0]-self.start[0])
        if self.steep:
            self.start = self.swap(self.start[0],self.start[1])
            self.end = self.swap(self.end[0],self.end[1])
        if self.start[0] > self.end[0]:
            _x0 = int(self.start[0])
            _x1 = int(self.end[0])
            self.start[0] = _x1
            self.end[0] = _x0
            _y0 = int(self.start[1])
            _y1 = int(self.end[1])
            self.start[1] = _y1
            self.end[1] = _y0
        dx = self.end[0] - self.start[0]
        dy = abs(self.end[1] - self.start[1])
        error = 0
        derr = dy/float(dx)
        ystep = 0
        y = self.start[1]
        if self.start[1] < self.end[1]: ystep = 1
        else: ystep = -1
        for x in range(self.start[0],self.end[0]+1):
            if self.steep:
                self.path.append((y,x))
            else:
                self.path.append((x,y))
            error += derr
            if error >= 0.5:
                y += ystep
                error -= 1.0
    def swap(self,n1,n2):
        return [n2,n1]
62/2:
import cv2
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
62/3:
Mask = cv2.imread("mask.png")
Source = cv2.imread("source.png")
Target = cv2.imread("target.png")
62/4:
def make_outline(path):
    img = cv2.imread(path)
    Points = []
    def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
        if event == cv2.EVENT_LBUTTONDOWN:
            xy = "%d,%d" % (x, y)
            Points.append([x,y])
            cv2.circle(img, (x,y), 1, (0, 0, 255), thickness=-1)
            cv2.imshow("image", img)
    cv2.namedWindow("image")
    cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
    cv2.imshow("image", img)
    cv2.waitKey(0)
    cv2.destroyWindow("image")
    return Points
62/5:
def plot_line(K):
    print("The points you chose:")
    plt.scatter([i[0] for i in K],[i[1] for i in K])
    plt.show()
    Path = []
    K.append(K[0])
    for i in range(len(K)-1):
        Path.append(bresenham(K[i],K[i+1]).path)
    print("Line:")
    for P in Path:
        plt.scatter([i[0] for i in P],[i[1] for i in P])
    return Path
62/6:
Outline = make_outline("source.png")
Out = plot_line(Outline)
62/7:
Innerline = make_outline("source.png")
Inner = plot_line(Innerline)
62/8:
def Loss(Line,bias):
    Loss = []
    for i in range(len(Line)-1):
        Loss.append(cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]]))
    return Loss
62/9:
test = np.zeros(Mask.shape, dtype=np.uint8)
image = test
O = np.int32([Outline])
I = np.int32([Innerline])
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
Image.fromarray(image)
62/10:
Out_loss = []
for Line in Out:
    Out_loss = Out_loss + Loss(Line,0)
k = np.mean(Out_loss)
k
62/11:
def dedu(Out):
    ALL = []
    for i in Out:
        ALL = ALL+i
    Fill = []
    for i in ALL:
        if i not in Fill:
            Fill.append(i)
    return Fill
62/12:
Set_in = dedu(Inner)
len(Set_in)
62/13:
Set_out = dedu(Out)
len(Set_out)
62/14:
Start = Set_in[0]
End = Set_out[0]
distance = cv2.norm(Start,End)
for i in Set_in:
    for j in Set_out:
        d_temp = cv2.norm(i,j)
        if d_temp < distance:
            distance = d_temp
            Start = i
            End = j
62/15:
image = cv2.line(image,Start,End,(0,0,255))
Image.fromarray(image)
62/16: Start_side = bresenham(Start,End).path
62/17: Start_side
62/18:
def sub(v1,v2):
    return [v1[0]-v2[0],v1[1]-v2[1]]
62/19:
Direction = sub(Start_side[-1],Start_side[0])
Direction
62/20:
def cross_product(p1,p2):
    return p1[0]*p2[1]-p1[1]*p2[0]
62/21:
def if_target(R,image,Direction):
    #if in graph
    #x 
    if R[0]>image.shape[1]:
        return False
    #y
    if R[1]>image.shape[0]:
        return False
    #means out of adjust range
    if np.array_equal(image[R[1]][R[0]],[255,0,0]) == False:
        return False
    if cross_product(Direction,sub(R,list(S)))<0:
        return False
    return True
62/22:
def around4(S):
    return [(S[0]-1,S[1]),(S[0]+1,S[1]),(S[0],S[1]-1),(S[0],S[1]+1)]
62/23:
def find_pair(S):
    Reach = around4(S)
    for i in Reach:
        if if_target(i,image,Direction):
            return i
    print("No pair")
    return False
62/24:
def get_pair_list(Search_edge):
    Pair = []
    for s in Search_edge:
        ans = find_pair(s)
        if ans:
            Pair.append(ans)
        else:
            print("Error")
            return False
    return Pair
62/25:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
62/26:
def find_pair(S):
    Reach = around4(S)
    for i in Reach:
        if if_target(i,image,Direction,S):
            return i
    print("No pair")
    return False
62/27:
def if_target(R,image,Direction,S):
    #if in graph
    #x 
    if R[0]>image.shape[1]:
        return False
    #y
    if R[1]>image.shape[0]:
        return False
    #means out of adjust range
    if np.array_equal(image[R[1]][R[0]],[255,0,0]) == False:
        return False
    if cross_product(Direction,sub(R,list(S)))<0:
        return False
    return True
62/28:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
62/29:
def if_target(R,image,Direction,S):
    #if in graph
    #x 
    if R[0]>image.shape[1]:
        return False
    #y
    if R[1]>image.shape[0]:
        return False
    #means out of adjust range
    if np.array_equal(image[R[1]][R[0]],[255,0,0]) == False:
        return False
    if cross_product(Direction,sub(R,list(S)))<0:
        print("catch")
        return False
    return True
62/30:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
62/31:
def if_target(R,image,Direction,S):
    #if in graph
    #x 
    if R[0]>image.shape[1]:
        return False
    #y
    if R[1]>image.shape[0]:
        return False
    #means out of adjust range
    if np.array_equal(image[R[1]][R[0]],[255,0,0]) == False:
        return False
    if cross_product(Direction,sub(R,list(S)))<0:
        print("catch")
        return False
    print("got"+str(R))
    return True
62/32:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
62/33:
def find_pair(S):
    Reach = around4(S)
    for i in Reach:
        if if_target(i,image,Direction,S):
            return i
    print("fair to pair " + str(S))
    return False
62/34:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
62/35: img
62/36: Image.fromarray(image)
62/37: Image[33][52]
62/38: image[33][52]
62/39: Image.fromarray(images)
62/40: Image.fromarray(image)
62/41: image[33][52]
62/42:
image[33][52]#Blue is ok
around4((52,33))
62/43: Target
62/44: Target_side
62/45: Target_side = []
62/46:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
62/47: Target_side
62/48:
for i in around4((52,33)):
    print(image[i[1]][i[0]])
62/49:
def get_pair_list(Search_edge):
    Pair = []
    for s in Search_edge:
        ans = find_pair(s)
        if ans:
            Pair.append(ans)
        else:
            print("Error,need drop")
            Pair.append("Drop")
    return Pair
62/50: Image.fromarray(image)
62/51:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
62/52:
def get_pair_list(Search_edge):
    Pair = []
    for s in Search_edge:
        ans = find_pair(s)
        if ans:
            Pair.append(ans)
        else:
            print("Error,need drop")
            Pair.append("Drop")
    return Pair
62/53:
def if_target(R,image,Direction,S):
    #if in graph
    #x 
    if R[0]>image.shape[1]:
        return False
    #y
    if R[1]>image.shape[0]:
        return False
    #means out of adjust range
    if np.array_equal(image[R[1]][R[0]],[255,0,0]) == False:
        return False
    if cross_product(Direction,sub(R,list(S)))<0:
        return False
    return True
62/54:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
62/55:
def get_pair_list(Search_edge):
    Pair = []
    for s in Search_edge:
        ans = find_pair(s)
        if ans:
            Pair.append(ans)
        else:
            print("Error,need drop")
            Pair.append(str("Drop"))
    return Pair
62/56:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
62/57: Target_side[-1] == "Drop"
62/58:
def get_pair_list(Search_edge):
    Pair = []
    for s in Search_edge:
        ans = find_pair(s)
        if ans:
            Pair.append(ans)
        else:
            print("Error,need drop")
            Pair.append(False)
    return Pair
62/59:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
62/60:
def get_pair_list(Search_edge):
    Pair = []
    for s in Search_edge:
        ans = find_pair(s)
        if ans:
            Pair.append(ans)
        else:
            print("Error,need drop")
            Pair.append("F"）
    return Pair
62/61:
def get_pair_list(Search_edge):
    Pair = []
    for s in Search_edge:
        ans = find_pair(s)
        if ans:
            Pair.append(ans)
        else:
            print("Error,need drop")
            Pair.append("F")
    return Pair
62/62:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
62/63:
def get_pair_list(Search_edge):
    Pair = []
    for s in Search_edge:
        ans = find_pair(s)
        if ans:
            Pair.append(ans)
        else:
            print("Error,need drop")
            Pair.append("DE")
    return Pair
62/64:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
62/65: Target_side[-1] == ("DE")
62/66: Target_side[-1] == ('D','E'')
62/67: Target_side[-1] == ('D','E)
62/68: Target_side[-1] == ('D','E')
62/69:
for i in range(len(Target_side)):
    if Target_side[i] != ('D','E'):
        image[Target_side[i][1]][Target_side[i][0]] = [100,100,100]
        Pair.append([Start_side[i],Target_side[i]])
62/70: Pair = []
62/71:
for i in range(len(Target_side)):
    if Target_side[i] != ('D','E'):
        image[Target_side[i][1]][Target_side[i][0]] = [100,100,100]
        Pair.append([Start_side[i],Target_side[i]])
62/72: Image.fromarray(image)
62/73:
for i in range(len(Target_side)):
    if Target_side[i] != ('D','E'):
        image[Target_side[i][1]][Target_side[i][0]] = [25555,255,2]
        Pair.append([Start_side[i],Target_side[i]])
62/74:
for i in range(len(Target_side)):
    if Target_side[i] != ('D','E'):
        image[Target_side[i][1]][Target_side[i][0]] = [25555,255,255]
        Pair.append([Start_side[i],Target_side[i]])
62/75: Pair = []
62/76:
for i in range(len(Target_side)):
    if Target_side[i] != ('D','E'):
        image[Target_side[i][1]][Target_side[i][0]] = [25555,255,255]
        Pair.append([Start_side[i],Target_side[i]])
62/77: Image.fromarray(image)
62/78:
Start_side = [i[0] for i in Pair]
Target_side = [i[1] for i in Pair]
62/79:
Node_dic = {}
ID = 0
62/80:
for n in Start_side:
    Node_dic[n] = ID
    ID = ID + 1
62/81:
for n in Target_side:
    Node_dic[n] = ID
    ID = ID + 1
62/82: Edge = []
62/83:
Move_area = []
for x in range(image.shape[1]):
    for y in range(image.shape[0]):
        if np.array_equal(image[y][x],[255,0,0]):
            Node_dic[(x,y)] = ID
            Move_area.append((x,y))
            ID = ID + 1
62/84:
def get_color(node,img):
    return img[node[1]][node[0]]
def get_edge(node1,node2,Source):
    return (Node_dic[node1],Node_dic[node2],cv2.norm(get_color(node1,Source),get_color(node2,Source)))
62/85:
Edge = []
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
62/86:
for S in Target_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
62/87: Edge
62/88: plt.scatter([i[0] for i in Move_area],[i[1] for i in Move_area])
62/89:
Normal_edge = []
for node in Move_area:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            Normal_edge.append(get_edge(R,node,Source))
62/90: len(Normal_edge)
62/91: str(Normal_edge[0])
62/92:
with open("path") as f:
    p = f.read()
62/93: path = ((p.strip("\n")).split("[")[1]).strip("]").split()
62/94: pim = image
62/95: ID_dic = {v: k for k, v in Node_dic.items()}
62/96:
enclose = []
for i in path:
    p = ID_dic[int(i)]
    enclose.append(p)
    pim[p[1]][p[0]] = [200,200,200]
62/97: Image.fromarray(pim)
62/98:
Node_All = Start_side + Target_side + Move_area
Edge_All = Edge + Normal_edge
62/99:
with open("Edge","w") as f:
    for line in Edge_All:
        f.write(str(line[0])+" "+str(line[1])+" "+("%.2f" % line[2])+"\n")
62/100:
with open("Node","w") as f:
    for node,ID in Node_dic.items():
        f.write(str(node[0])+" "+str(node[1])+" "+str(ID)+"\n")
62/101: Start_side
62/102: Node_dic[Start_side[0]]
62/103: Node_dic[Target_side[0]]
62/104: k
62/105:
with open("Path\Edge","w") as f:
    for line in Edge_All:
        f.write(str(line[0])+" "+str(line[1])+" "+("%.2f" % line[2])+"\n")
62/106:
with open("Path\Node","w") as f:
    for node,ID in Node_dic.items():
        f.write(str(node[0])+" "+str(node[1])+" "+str(ID)+"\n")
62/107:
with open("Path\Node","w") as f:
    for node,ID in Node_dic.items():
        f.write(str(node[0])+" "+str(node[1])+" "+str(ID)+"\n")
62/108:
with open("Path\Node","w") as f:
    for node,ID in Node_dic.items():
        f.write(str(node[0])+" "+str(node[1])+" "+str(ID)+"\n")
62/109:
with open("Path\\Node","w") as f:
    for node,ID in Node_dic.items():
        f.write(str(node[0])+" "+str(node[1])+" "+str(ID)+"\n")
62/110:
with open("Path\Edge","w") as f:
    for line in Edge_All:
        f.write(str(line[0])+" "+str(line[1])+" "+("%.2f" % line[2])+"\n")
62/111:
with open("Path\\Node","w") as f:
    for node,ID in Node_dic.items():
        f.write(str(node[0])+" "+str(node[1])+" "+str(ID)+"\n")
62/112:
with open("\Path\Edge","w") as f:
    for line in Edge_All:
        f.write(str(line[0])+" "+str(line[1])+" "+("%.2f" % line[2])+"\n")
62/113:
with open("\Path\\Node","w") as f:
    for node,ID in Node_dic.items():
        f.write(str(node[0])+" "+str(node[1])+" "+str(ID)+"\n")
62/114:
with open(".\Path\Edge","w") as f:
    for line in Edge_All:
        f.write(str(line[0])+" "+str(line[1])+" "+("%.2f" % line[2])+"\n")
62/115:
with open(".\Path\\Node","w") as f:
    for node,ID in Node_dic.items():
        f.write(str(node[0])+" "+str(node[1])+" "+str(ID)+"\n")
62/116:
with open("Edge","w") as f:
    for line in Edge_All:
        f.write(str(line[0])+" "+str(line[1])+" "+("%.2f" % line[2])+"\n")
62/117:
with open("Node","w") as f:
    for node,ID in Node_dic.items():
        f.write(str(node[0])+" "+str(node[1])+" "+str(ID)+"\n")
63/1:
class bresenham:
    def __init__(self, start, end):
        self.start = list(start)
        self.end = list(end)
        self.path = []
        self.steep = abs(self.end[1]-self.start[1]) > abs(self.end[0]-self.start[0])
        if self.steep:
            self.start = self.swap(self.start[0],self.start[1])
            self.end = self.swap(self.end[0],self.end[1])
        if self.start[0] > self.end[0]:
            _x0 = int(self.start[0])
            _x1 = int(self.end[0])
            self.start[0] = _x1
            self.end[0] = _x0
            _y0 = int(self.start[1])
            _y1 = int(self.end[1])
            self.start[1] = _y1
            self.end[1] = _y0
        dx = self.end[0] - self.start[0]
        dy = abs(self.end[1] - self.start[1])
        error = 0
        derr = dy/float(dx)
        ystep = 0
        y = self.start[1]
        if self.start[1] < self.end[1]: ystep = 1
        else: ystep = -1
        for x in range(self.start[0],self.end[0]+1):
            if self.steep:
                self.path.append((y,x))
            else:
                self.path.append((x,y))
            error += derr
            if error >= 0.5:
                y += ystep
                error -= 1.0
    def swap(self,n1,n2):
        return [n2,n1]
63/2:
import cv2
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
63/3:
Mask = cv2.imread("mask.png")
Source = cv2.imread("source.png")
Target = cv2.imread("target.png")
63/4:
class bresenham:
    def __init__(self, start, end):
        self.start = list(start)
        self.end = list(end)
        self.path = []
        self.steep = abs(self.end[1]-self.start[1]) > abs(self.end[0]-self.start[0])
        if self.steep:
            self.start = self.swap(self.start[0],self.start[1])
            self.end = self.swap(self.end[0],self.end[1])
        if self.start[0] > self.end[0]:
            _x0 = int(self.start[0])
            _x1 = int(self.end[0])
            self.start[0] = _x1
            self.end[0] = _x0
            _y0 = int(self.start[1])
            _y1 = int(self.end[1])
            self.start[1] = _y1
            self.end[1] = _y0
        dx = self.end[0] - self.start[0]
        dy = abs(self.end[1] - self.start[1])
        error = 0
        derr = dy/float(dx)
        ystep = 0
        y = self.start[1]
        if self.start[1] < self.end[1]: ystep = 1
        else: ystep = -1
        for x in range(self.start[0],self.end[0]+1):
            if self.steep:
                self.path.append((y,x))
            else:
                self.path.append((x,y))
            error += derr
            if error >= 0.5:
                y += ystep
                error -= 1.0
    def swap(self,n1,n2):
        return [n2,n1]
64/1:
class bresenham:
    def __init__(self, start, end):
        self.start = list(start)
        self.end = list(end)
        self.path = []
        self.steep = abs(self.end[1]-self.start[1]) > abs(self.end[0]-self.start[0])
        if self.steep:
            self.start = self.swap(self.start[0],self.start[1])
            self.end = self.swap(self.end[0],self.end[1])
        if self.start[0] > self.end[0]:
            _x0 = int(self.start[0])
            _x1 = int(self.end[0])
            self.start[0] = _x1
            self.end[0] = _x0
            _y0 = int(self.start[1])
            _y1 = int(self.end[1])
            self.start[1] = _y1
            self.end[1] = _y0
        dx = self.end[0] - self.start[0]
        dy = abs(self.end[1] - self.start[1])
        error = 0
        derr = dy/float(dx)
        ystep = 0
        y = self.start[1]
        if self.start[1] < self.end[1]: ystep = 1
        else: ystep = -1
        for x in range(self.start[0],self.end[0]+1):
            if self.steep:
                self.path.append((y,x))
            else:
                self.path.append((x,y))
            error += derr
            if error >= 0.5:
                y += ystep
                error -= 1.0
    def swap(self,n1,n2):
        return [n2,n1]
64/2:
import cv2
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
64/3:
Source = cv2.imread("Source.png")
Target = cv2.imread("Target.png")
64/4:
def make_outline(path):
    img = cv2.imread(path)
    Points = []
    def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
        if event == cv2.EVENT_LBUTTONDOWN:
            xy = "%d,%d" % (x, y)
            Points.append([x,y])
            cv2.circle(img, (x,y), 1, (0, 0, 255), thickness=-1)
            cv2.imshow("image", img)
    cv2.namedWindow("image")
    cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
    cv2.imshow("image", img)
    cv2.waitKey(0)
    cv2.destroyWindow("image")
    return Points
64/5:
def plot_line(K):
    print("The points you chose:")
    plt.scatter([i[0] for i in K],[i[1] for i in K])
    plt.show()
    Path = []
    K.append(K[0])
    for i in range(len(K)-1):
        Path.append(bresenham(K[i],K[i+1]).path)
    print("Line:")
    for P in Path:
        plt.scatter([i[0] for i in P],[i[1] for i in P])
    return Path
64/6:
Outline = make_outline("source.png")
Out = plot_line(Outline)
64/7:
class bresenham:
    def __init__(self, start, end):
        self.start = list(start)
        self.end = list(end)
        self.path = []
        self.steep = abs(self.end[1]-self.start[1]) > abs(self.end[0]-self.start[0])
        if self.steep:
            self.start = self.swap(self.start[0],self.start[1])
            self.end = self.swap(self.end[0],self.end[1])
        if self.start[0] > self.end[0]:
            _x0 = int(self.start[0])
            _x1 = int(self.end[0])
            self.start[0] = _x1
            self.end[0] = _x0
            _y0 = int(self.start[1])
            _y1 = int(self.end[1])
            self.start[1] = _y1
            self.end[1] = _y0
        dx = self.end[0] - self.start[0]
        dy = abs(self.end[1] - self.start[1])
        error = 0
        derr = dy/float(dx)
        ystep = 0
        y = self.start[1]
        if self.start[1] < self.end[1]: ystep = 1
        else: ystep = -1
        for x in range(self.start[0],self.end[0]+1):
            if self.steep:
                self.path.append((y,x))
            else:
                self.path.append((x,y))
            error += derr
            if error >= 0.5:
                y += ystep
                error -= 1.0
    def swap(self,n1,n2):
        return [n2,n1]
65/1:
class bresenham:
    def __init__(self, start, end):
        self.start = list(start)
        self.end = list(end)
        self.path = []
        self.steep = abs(self.end[1]-self.start[1]) > abs(self.end[0]-self.start[0])
        if self.steep:
            self.start = self.swap(self.start[0],self.start[1])
            self.end = self.swap(self.end[0],self.end[1])
        if self.start[0] > self.end[0]:
            _x0 = int(self.start[0])
            _x1 = int(self.end[0])
            self.start[0] = _x1
            self.end[0] = _x0
            _y0 = int(self.start[1])
            _y1 = int(self.end[1])
            self.start[1] = _y1
            self.end[1] = _y0
        dx = self.end[0] - self.start[0]
        dy = abs(self.end[1] - self.start[1])
        error = 0
        derr = dy/float(dx)
        ystep = 0
        y = self.start[1]
        if self.start[1] < self.end[1]: ystep = 1
        else: ystep = -1
        for x in range(self.start[0],self.end[0]+1):
            if self.steep:
                self.path.append((y,x))
            else:
                self.path.append((x,y))
            error += derr
            if error >= 0.5:
                y += ystep
                error -= 1.0
    def swap(self,n1,n2):
        return [n2,n1]
65/2:
import cv2
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
65/3:
Source = cv2.imread("Source.png")
Target = cv2.imread("Target.png")
65/4:
def make_outline(path):
    img = cv2.imread(path)
    Points = []
    def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
        if event == cv2.EVENT_LBUTTONDOWN:
            xy = "%d,%d" % (x, y)
            Points.append([x,y])
            cv2.circle(img, (x,y), 1, (0, 0, 255), thickness=-1)
            cv2.imshow("image", img)
    cv2.namedWindow("image")
    cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
    cv2.imshow("image", img)
    cv2.waitKey(0)
    cv2.destroyWindow("image")
    return Points
65/5:
def plot_line(K):
    print("The points you chose:")
    plt.scatter([i[0] for i in K],[i[1] for i in K])
    plt.show()
    Path = []
    K.append(K[0])
    for i in range(len(K)-1):
        Path.append(bresenham(K[i],K[i+1]).path)
    print("Line:")
    for P in Path:
        plt.scatter([i[0] for i in P],[i[1] for i in P])
    return Path
65/6:
Outline = make_outline("source.png")
Out = plot_line(Outline)
65/7:
Outline = make_outline("Source.png")
Out = plot_line(Outline)
65/8:
Innerline = make_outline("Source.png")
Inner = plot_line(Innerline)
65/9:
def Loss(Line,bias):
    Loss = []
    for i in range(len(Line)-1):
        Loss.append(cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]]))
    return Loss
65/10:
test = np.zeros(Source.shape, dtype=np.uint8)
image = test
O = np.int32([Outline])
I = np.int32([Innerline])
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
Image.fromarray(image)
65/11:
Out_loss = []
for Line in Out:
    Out_loss = Out_loss + Loss(Line,0)
k = np.mean(Out_loss)
k
65/12:
def dedu(Out):
    ALL = []
    for i in Out:
        ALL = ALL+i
    Fill = []
    for i in ALL:
        if i not in Fill:
            Fill.append(i)
    return Fill
65/13:
Set_in = dedu(Inner)
len(Set_in)
65/14:
Set_out = dedu(Out)
len(Set_out)
65/15:
Start = Set_in[0]
End = Set_out[0]
distance = cv2.norm(Start,End)
for i in Set_in:
    for j in Set_out:
        d_temp = cv2.norm(i,j)
        if d_temp < distance:
            distance = d_temp
            Start = i
            End = j
65/16:
image = cv2.line(image,Start,End,(0,0,255))
Image.fromarray(image)
65/17: Start_side = bresenham(Start,End).path
65/18: Start_side
65/19:
def sub(v1,v2):
    return [v1[0]-v2[0],v1[1]-v2[1]]
65/20:
Direction = sub(Start_side[-1],Start_side[0])
Direction
65/21:
def cross_product(p1,p2):
    return p1[0]*p2[1]-p1[1]*p2[0]
65/22:
def if_target(R,image,Direction,S):
    #if in graph
    #x 
    if R[0]>image.shape[1]:
        return False
    #y
    if R[1]>image.shape[0]:
        return False
    #means out of adjust range
    if np.array_equal(image[R[1]][R[0]],[255,0,0]) == False:
        return False
    if cross_product(Direction,sub(R,list(S)))<0:
        return False
    return True
65/23:
def around4(S):
    return [(S[0]-1,S[1]),(S[0]+1,S[1]),(S[0],S[1]-1),(S[0],S[1]+1)]
65/24:
def find_pair(S):
    Reach = around4(S)
    for i in Reach:
        if if_target(i,image,Direction,S):
            return i
    print("fair to pair " + str(S))
    return False
65/25:
def get_pair_list(Search_edge):
    Pair = []
    for s in Search_edge:
        ans = find_pair(s)
        if ans:
            Pair.append(ans)
        else:
            print("Error,need drop")
            Pair.append("DE")
    return Pair
65/26: Image.fromarray(image)
65/27:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
65/28:
for i in 
Target_side[-1] == ('D','E')
65/29: Pair = []
65/30:
for i in range(len(Target_side)):
    if Target_side[i] != ('D','E'):
        image[Target_side[i][1]][Target_side[i][0]] = [25555,255,255]
        Pair.append([Start_side[i],Target_side[i]])
65/31: Image.fromarray(image)
65/32:
Start_side = [i[0] for i in Pair]
Target_side = [i[1] for i in Pair]
65/33:
Node_dic = {}
ID = 0
65/34:
for n in Start_side:
    Node_dic[n] = ID
    ID = ID + 1
65/35:
for n in Target_side:
    Node_dic[n] = ID
    ID = ID + 1
65/36: Edge = []
65/37:
Move_area = []
for x in range(image.shape[1]):
    for y in range(image.shape[0]):
        if np.array_equal(image[y][x],[255,0,0]):
            Node_dic[(x,y)] = ID
            Move_area.append((x,y))
            ID = ID + 1
65/38:
def get_color(node,img):
    return img[node[1]][node[0]]
def get_edge(node1,node2,Source):
    return (Node_dic[node1],Node_dic[node2],cv2.norm(get_color(node1,Source),get_color(node2,Source)))
65/39:
Edge = []
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
65/40:
for S in Target_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
65/41: Edge
65/42: plt.scatter([i[0] for i in Move_area],[i[1] for i in Move_area])
65/43:
Normal_edge = []
for node in Move_area:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            Normal_edge.append(get_edge(R,node,Source))
65/44: len(Normal_edge)
65/45: str(Normal_edge[0])
65/46:
Node_All = Start_side + Target_side + Move_area
Edge_All = Edge + Normal_edge
65/47:
with open("Edge","w") as f:
    for line in Edge_All:
        f.write(str(line[0])+" "+str(line[1])+" "+("%.2f" % line[2])+"\n")
65/48:
with open("Node","w") as f:
    for node,ID in Node_dic.items():
        f.write(str(node[0])+" "+str(node[1])+" "+str(ID)+"\n")
65/49: Start_side
65/50: Node_dic[Start_side[0]]
65/51: Node_dic[Target_side[0]]
65/52: k
65/53:
with open("Edge","w") as f:
    for line in Edge_All:
        f.write(str(line[0])+" "+str(line[1])+" "+("%.2f" % line[2])+"\n")
65/54:
with open("Node","w") as f:
    for node,ID in Node_dic.items():
        f.write(str(node[0])+" "+str(node[1])+" "+str(ID)+"\n")
65/55:
with open("path") as f:
    p = f.read()
65/56: path = ((p.strip("\n")).split("[")[1]).strip("]").split()
65/57: pim = image
65/58: ID_dic = {v: k for k, v in Node_dic.items()}
65/59:
enclose = []
for i in path:
    p = ID_dic[int(i)]
    enclose.append(p)
    pim[p[1]][p[0]] = [200,200,200]
65/60: Image.fromarray(pim)
65/61: path
65/62: len(path)
65/63: path
65/64: enclose
65/65: plt.plot(enclose)
65/66: plt.plot(enclose[0],enclose[1])
65/67: plt.scatter((enclose[0],enclose[1])
65/68: plt.scatter([i[0] for i in enclose],[i[1] for i in enclose])
65/69:
with open("path") as f:
    p = f.read()
65/70: path = ((p.strip("\n")).split("[")[1]).strip("]").split()
65/71: pim = image
65/72: ID_dic = {v: k for k, v in Node_dic.items()}
65/73:
enclose = []
for i in path:
    p = ID_dic[int(i)]
    enclose.append(p)
    pim[p[1]][p[0]] = [200,200,200]
65/74: plt.scatter([i[0] for i in enclose],[i[1] for i in enclose])
65/75: Image.fromarray(pim)
65/76: patj
65/77: path
65/78: Start_side
65/79: Target_side
65/80:
for i in Start_side:
    print(i in Move_area)
65/81:
for i in Start_side:
    print(Target_side in Move_area)
65/82: Node_dic[0]
65/83: ID_dic[44533]
65/84: ID_dic[0]
65/85: image[110][353]
65/86:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
65/87:
test = np.zeros(Source.shape, dtype=np.uint8)
image = test
O = np.int32([Outline])
I = np.int32([Innerline])
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
Image.fromarray(image)
65/88:
Out_loss = []
for Line in Out:
    Out_loss = Out_loss + Loss(Line,0)
k = np.mean(Out_loss)
k
65/89:
def dedu(Out):
    ALL = []
    for i in Out:
        ALL = ALL+i
    Fill = []
    for i in ALL:
        if i not in Fill:
            Fill.append(i)
    return Fill
65/90:
Set_in = dedu(Inner)
len(Set_in)
65/91:
Set_out = dedu(Out)
len(Set_out)
65/92:
Start = Set_in[0]
End = Set_out[0]
distance = cv2.norm(Start,End)
for i in Set_in:
    for j in Set_out:
        d_temp = cv2.norm(i,j)
        if d_temp < distance:
            distance = d_temp
            Start = i
            End = j
65/93: Start_side = bresenham(Start,End).path
65/94: Start_side
65/95:
def sub(v1,v2):
    return [v1[0]-v2[0],v1[1]-v2[1]]
65/96:
Direction = sub(Start_side[-1],Start_side[0])
Direction
65/97:
def cross_product(p1,p2):
    return p1[0]*p2[1]-p1[1]*p2[0]
65/98:
def if_target(R,image,Direction,S):
    #if in graph
    #x 
    if R[0]>image.shape[1]:
        return False
    #y
    if R[1]>image.shape[0]:
        return False
    #means out of adjust range
    if np.array_equal(image[R[1]][R[0]],[255,0,0]) == False:
        return False
    if cross_product(Direction,sub(R,list(S)))<0:
        return False
    return True
65/99:
def around4(S):
    return [(S[0]-1,S[1]),(S[0]+1,S[1]),(S[0],S[1]-1),(S[0],S[1]+1)]
65/100:
def find_pair(S):
    Reach = around4(S)
    for i in Reach:
        if if_target(i,image,Direction,S):
            return i
    print("fair to pair " + str(S))
    return False
65/101:
def get_pair_list(Search_edge):
    Pair = []
    for s in Search_edge:
        ans = find_pair(s)
        if ans:
            Pair.append(ans)
        else:
            print("Error,need drop")
            Pair.append("DE")
    return Pair
65/102: Image.fromarray(image)
65/103:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
65/104: Pair = []
65/105:
for i in range(len(Target_side)):
    if Target_side[i] != ('D','E'):
        image[Target_side[i][1]][Target_side[i][0]] = [255,255,255]
        Pair.append([Start_side[i],Target_side[i]])
65/106: Image.fromarray(image)
65/107:
Start_side = [i[0] for i in Pair]
Target_side = [i[1] for i in Pair]
65/108:
for i in Start_side:
    print(image[i[1]][i[0]])
65/109:
for i in range(len(Target_side)):
    if Target_side[i] != ('D','E'):
        image[Target_side[i][1]][Target_side[i][0]] = [255,255,255]
        image[Start_side[i][1]][Start_side[i][0]] = [0,0,255]
        Pair.append([Start_side[i],Target_side[i]])
65/110: Image.fromarray(image)
65/111:
Start_side = [i[0] for i in Pair]
Target_side = [i[1] for i in Pair]
65/112:
for i in Start_side:
    print(image[i[1]][i[0]])
65/113:
for i in Start_side:
    print(image[i[1]][i[0]])
for i in Target_side:
    print(image[i[1]][i[0]])
65/114:
Node_dic = {}
ID = 0
65/115:
for n in Start_side:
    Node_dic[n] = ID
    ID = ID + 1
65/116:
for n in Target_side:
    Node_dic[n] = ID
    ID = ID + 1
65/117: Edge = []
65/118:
Move_area = []
for x in range(image.shape[1]):
    for y in range(image.shape[0]):
        if np.array_equal(image[y][x],[255,0,0]):
            Node_dic[(x,y)] = ID
            Move_area.append((x,y))
            ID = ID + 1
65/119:
def get_color(node,img):
    return img[node[1]][node[0]]
def get_edge(node1,node2,Source):
    return (Node_dic[node1],Node_dic[node2],cv2.norm(get_color(node1,Source),get_color(node2,Source)))
65/120: Start_side
65/121: Target_side
65/122:
Edge = []
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
65/123:
for S in Target_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
65/124: Edge
65/125:
Normal_edge = []
for node in Move_area:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            Normal_edge.append(get_edge(R,node,Source))
65/126: len(Normal_edge)
65/127: str(Normal_edge[0])
65/128: ID_dic[44533]
65/129: image[110][353]
65/130:
Node_All = Start_side + Target_side + Move_area
Edge_All = Edge + Normal_edge
65/131:
with open("Edge","w") as f:
    for line in Edge_All:
        f.write(str(line[0])+" "+str(line[1])+" "+("%.2f" % line[2])+"\n")
65/132:
with open("Node","w") as f:
    for node,ID in Node_dic.items():
        f.write(str(node[0])+" "+str(node[1])+" "+str(ID)+"\n")
65/133: Node_dic[Start_side[0]]
65/134: Node_dic[Start_side[0]]
65/135: Target_side[0]
65/136: Start_side[0]
65/137: Node_dic[Start_side[0]]
65/138: Node_dic[Target_side[0]]
65/139: Node_dic[Start_side[0]]
65/140: k
65/141: path = ((p.strip("\n")).split("[")[1]).strip("]").split()
65/142: path = (p.strip("\n")).split("[")[1]).strip("]").split()
65/143: path = ((p.strip("\n")).split("[")[1]).strip("]").split()
65/144: p
65/145: Node_dic[44573]
65/146: ID_dic[44573]
65/147: ID_dic[44543]
65/148: plt.scatter([i[0] for i in Start_side],[i[0] for i in Start_side])
65/149:
plt.scatter([i[0] for i in Start_side],[i[0] for i in Start_side])
plt.scatter([i[0] for i in Target_side],[i[0] for i in Target_side])
65/150:
Node_dic = {}
ID = 0
65/151:
for n in Start_side:
    Node_dic[n] = ID
    ID = ID + 1
65/152:
for n in Target_side:
    Node_dic[n] = ID
    ID = ID + 1
65/153: Edge = []
65/154:
Move_area = []
for x in range(image.shape[1]):
    for y in range(image.shape[0]):
        if np.array_equal(image[y][x],[255,0,0]):
            Node_dic[(x,y)] = ID
            Move_area.append((x,y))
            ID = ID + 1
65/155:
def get_color(node,img):
    return img[node[1]][node[0]]
def get_edge(node1,node2,Source):
    return (Node_dic[node1],Node_dic[node2],cv2.norm(get_color(node1,Source),get_color(node2,Source)))
65/156:
def place_to_co(p):
    return [i[0] for i in p],[i[1] for i in p]
65/157: plt.scatter(place_to_co[Start_side])
65/158: plt.scatter(place_to_co(Start_side))
65/159:
def place_to_co(p):
    return [[i[0] for i in p],[i[1] for i in p]]
65/160: plt.scatter(place_to_co(Start_side))
65/161:
def place_to_co(p):
    return [i[0] for i in p],[i[1] for i in p]
65/162:
xs,ys = place_to_co(Start_side)
xt,yt = place_to_co(Target_side)
plt.scatter(xs,ys)
65/163:
xs,ys = place_to_co(Start_side)
xt,yt = place_to_co(Target_side)
plt.scatter(xs,ys)
plt.scatter(xt,yt)
65/164: len(Start_side)
65/165: len(Target_side)
65/166:
xs,ys = place_to_co(Start_side)
xt,yt = place_to_co(Target_side)
plt.xlim(345, 365)
plt.ylim(100, 110)
plt.scatter(xs,ys)
plt.scatter(xt,yt)
65/167:
xs,ys = place_to_co(Start_side)
xt,yt = place_to_co(Target_side)
plt.xlim(350, 365)
plt.ylim(100, 110)
plt.scatter(xs,ys)
plt.scatter(xt,yt)
65/168: Start_side
65/169:
xs,ys = place_to_co(Start_side)
plt.xlim(350, 365)
plt.ylim(100, 110)
plt.scatter(xs,ys)
65/170:
import matplotlib.pyplot as plt
import numpy as np

a = np.random.random((16, 16))
plt.imshow(a, cmap='hot', interpolation='nearest')
plt.show()
65/171:
import matplotlib.pyplot as plt
import numpy as np

a = np.random.random((16, 16))
a
plt.imshow(a, cmap='hot', interpolation='nearest')
plt.show()
65/172:
import matplotlib.pyplot as plt
import numpy as np

a = np.random.random((16, 16))
a
65/173:
import matplotlib.pyplot as plt
import numpy as np

a = np.random.random((16, 16))
a.shape
65/174:
import matplotlib.pyplot as plt
import numpy as np

a = np.random.random((16, 16))
plt.imshow(a, cmap='hot', interpolation='nearest')
plt.show()
65/175:
import matplotlib.pyplot as plt
import numpy as np
plt.imshow(image, cmap='hot', interpolation='nearest')
plt.show()
65/176:
import matplotlib.pyplot as plt
import numpy as np
plt.imshow(Start_side, cmap='hot', interpolation='nearest')
plt.show()
65/177:
import matplotlib.pyplot as plt
import numpy as np
plt.imshow(Start_side, cmap='hot')
plt.show()
65/178:
import matplotlib.pyplot as plt
import numpy as np
plt.imshow(Start_side, [0 for in Start_side],cmap='hot')
plt.show()
65/179:
import matplotlib.pyplot as plt
import numpy as np
plt.imshow(Start_side, [0 for i in Start_side],cmap='hot')
plt.show()
65/180:
import matplotlib.pyplot as plt
import numpy as np
plt.imshow([(1,1,1),(2,2,2)],cmap='hot')
plt.show()
65/181: Pair
65/182: Target_side
65/183:
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
65/184: Start_side = bresenham(Start,End).path
65/185: Start_side
65/186:
def sub(v1,v2):
    return [v1[0]-v2[0],v1[1]-v2[1]]
65/187:
Direction = sub(Start_side[-1],Start_side[0])
Direction
65/188:
def cross_product(p1,p2):
    return p1[0]*p2[1]-p1[1]*p2[0]
65/189:
def if_target(R,image,Direction,S):
    #if in graph
    #x 
    if R[0]>image.shape[1]:
        return False
    #y
    if R[1]>image.shape[0]:
        return False
    #means out of adjust range
    if np.array_equal(image[R[1]][R[0]],[255,0,0]) == False:
        return False
    if cross_product(Direction,sub(R,list(S)))<0:
        return False
    return True
65/190:
def around4(S):
    return [(S[0]-1,S[1]),(S[0]+1,S[1]),(S[0],S[1]-1),(S[0],S[1]+1)]
65/191:
def find_pair(S):
    Reach = around4(S)
    for i in Reach:
        if if_target(i,image,Direction,S):
            return i
    print("fair to pair " + str(S))
    return False
65/192:
def get_pair_list(Search_edge):
    Pair = []
    for s in Search_edge:
        ans = find_pair(s)
        if ans:
            Pair.append(ans)
        else:
            print("Error,need drop")
            Pair.append("DE")
    return Pair
65/193: Image.fromarray(image)
65/194:
test = np.zeros(Source.shape, dtype=np.uint8)
image = test
O = np.int32([Outline])
I = np.int32([Innerline])
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
Image.fromarray(image)
65/195: Image.fromarray(image)
65/196:
test = np.zeros(Source.shape, dtype=np.uint8)
image = test
O = np.int32([Outline])
I = np.int32([
    Innerline])
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
Image.fromarray(image)
65/197:
for i in Start_side:
    image[Start_side[i][1]][Start_side[i][0]] = [0,0,255]
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
65/198:
for i in range(len(Start_side)):
    image[Start_side[i][1]][Start_side[i][0]] = [0,0,255]
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
65/199: Pair = []
65/200:
for i in range(len(Target_side)):
    if Target_side[i] != ('D','E'):
        image[Target_side[i][1]][Target_side[i][0]] = [255,255,255]
        Pair.append([Start_side[i],Target_side[i]])
65/201: Image.fromarray(image)
65/202: Pair
65/203:
Start_side = [i[0] for i in Pair]
Target_side = [i[1] for i in Pair]
65/204: Pair
65/205:
def place_to_co(p):
    return [i[0] for i in p],[i[1] for i in p]
65/206:
def place_to_co(p):
    return [i[0] for i in p],[i[1] for i in p]
65/207:
import matplotlib.pyplot as plt
import numpy as np
x1,y1 = place_to_co(Start_side)
plt.scatter(x1,y1)
65/208:
import matplotlib.pyplot as plt
import numpy as np
x1,y1 = place_to_co(Start_side)
x2,y2 = place_to_co(Target_side)
plt.scatter(x1,y1)
plt.scatter(x2,y2)
65/209:
a = [1,1]
b = [5,5]
bresenham(a,b).path
65/210:
a = [1,2,3]
def cut_start_end(l):
    return a[1:len(a)]
cut_start_end(a)
65/211:
a = [1,2,3]
def cut_start_end(l):
    return a[1:len(a)-1]
cut_start_end(a)
65/212:
def cut_start_end(l):
    return a[1:len(a)-1]
65/213: Start_side = cut_start_end(Start_side)
65/214:
for i in range(len(Start_side)):
    image[Start_side[i][1]][Start_side[i][0]] = [0,0,255]
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
65/215:
Start_side = cut_start_end(Start_side)
Start_side
65/216:
def cut_start_end(l):
    return a[1:len(l)-1]
65/217:
Start_side = cut_start_end(Start_side)
Start_side
65/218: Start_side = bresenham(Start,End).path
65/219: Start_side
65/220:
Start_side = cut_start_end(Start_side)
Start_side
65/221:
def cut_start_end(l):
    return l[1:len(l)-1]
65/222:
Start_side = cut_start_end(Start_side)
Start_side
65/223: Start_side = bresenham(Start,End).path
65/224: Start_side
65/225:
Start_side = cut_start_end(Start_side)
Start_side
65/226:
for i in range(len(Start_side)):
    image[Start_side[i][1]][Start_side[i][0]] = [0,0,255]
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
65/227:
test = np.zeros(Source.shape, dtype=np.uint8)
image = test
O = np.int32([Outline])
I = np.int32([
    Innerline])
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
Image.fromarray(image)
65/228:
Start_side = cut_start_end(Start_side)
Start_side
65/229:
Start_side = cut_start_end(Start_side)
Start_side
65/230: Start_side = bresenham(Start,End).path
65/231: Start_side
65/232:
Start_side = cut_start_end(Start_side)
Start_side
65/233:
for i in range(len(Start_side)):
    image[Start_side[i][1]][Start_side[i][0]] = [0,0,255]
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
65/234: Pair = []
65/235:
for i in range(len(Target_side)):
    if Target_side[i] != ('D','E'):
        image[Target_side[i][1]][Target_side[i][0]] = [255,255,255]
        Pair.append([Start_side[i],Target_side[i]])
65/236: Image.fromarray(image)
65/237: Pair
65/238:
for p in pair:
    R0 = around4(p[0])
    R1 = around4(p[1])
    for i in R0:
        for j in R1:
            if i == j:
                print("FUCK")
65/239:
for p in Pair:
    R0 = around4(p[0])
    R1 = around4(p[1])
    for i in R0:
        for j in R1:
            if i == j:
                print("FUCK")
65/240:
for p in Pair:
    R0 = around4(p[0])
    R1 = around4(p[1])
    for i in R0:
        for j in R1:
            if i == j:
                print("FUCK")
65/241:
import matplotlib.pyplot as plt
import numpy as np
x1,y1 = place_to_co(Start_side)
x2,y2 = place_to_co(Target_side)
plt.scatter(x1,y1)
plt.scatter(x2,y2)
65/242:
Node_dic = {}
ID = 0
65/243:
for n in Start_side:
    Node_dic[n] = ID
    ID = ID + 1
65/244:
for n in Target_side:
    Node_dic[n] = ID
    ID = ID + 1
65/245: Edge = []
65/246:
Move_area = []
for x in range(image.shape[1]):
    for y in range(image.shape[0]):
        if np.array_equal(image[y][x],[255,0,0]):
            Node_dic[(x,y)] = ID
            Move_area.append((x,y))
            ID = ID + 1
65/247:
def get_color(node,img):
    return img[node[1]][node[0]]
def get_edge(node1,node2,Source):
    return (Node_dic[node1],Node_dic[node2],cv2.norm(get_color(node1,Source),get_color(node2,Source)))
65/248: Start_side
65/249: Target_side
65/250:
Edge = []
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
65/251:
for S in Target_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
65/252: Edge
65/253:
Normal_edge = []
for node in Move_area:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            Normal_edge.append(get_edge(R,node,Source))
65/254: len(Normal_edge)
65/255: ID_dic[44573]
65/256:
Node_All = Start_side + Target_side + Move_area
Edge_All = Edge + Normal_edge
65/257:
with open("Edge","w") as f:
    for line in Edge_All:
        f.write(str(line[0])+" "+str(line[1])+" "+("%.2f" % line[2])+"\n")
65/258:
with open("Node","w") as f:
    for node,ID in Node_dic.items():
        f.write(str(node[0])+" "+str(node[1])+" "+str(ID)+"\n")
65/259: Target_side[0]
65/260: Start_side[0]
65/261: Node_dic[Target_side[0]]
65/262: Node_dic[Start_side[0]]
65/263: k
65/264: Start_side = bresenham(Start,End).path
65/265: Start_side
65/266:
Direction = sub(Start_side[-1],Start_side[0])
Direction
65/267: Start_side
65/268:
for i in range(len(Start_side)):
    image[Start_side[i][1]][Start_side[i][0]] = [0,0,255]
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
65/269:
Start_side
test = np.zeros(Source.shape, dtype=np.uint8)
image = test
O = np.int32([Outline])
I = np.int32([
    Innerline])
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
Image.fromarray(image)
65/270:
for i in range(len(Start_side)):
    image[Start_side[i][1]][Start_side[i][0]] = [0,0,255]
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
65/271:
P = [45586,44559]
for i in P:
    print(ID_dic[i])
65/272:
P = [45586,44559]
for i in P:
    print(ID_dic[0])
65/273:
P = [45586,44559]
for i in P:
    print(ID_dic[44586])
65/274:
P = [45586,44559]
for i in P:
    print(ID_dic[i])
65/275:
P = [44586,44559]
for i in P:
    print(ID_dic[i])
65/276:
import matplotlib.pyplot as plt
import numpy as np
x1,y1 = place_to_co(Start_side)
x2,y2 = place_to_co(Target_side)
x3,y3 = place_to_co([(355, 104)
(354, 104)])
plt.scatter(x1,y1)
plt.scatter(x2,y2)
65/277:
import matplotlib.pyplot as plt
import numpy as np
x1,y1 = place_to_co(Start_side)
x2,y2 = place_to_co(Target_side)
x3,y3 = place_to_co([(355, 104),(354, 104)])
plt.scatter(x1,y1)
plt.scatter(x2,y2)
plt.scatter(x3,y3)
65/278:
P = [3,44586,44559,0]
L = []
for i in P:
    L.append(ID_dic[i])
65/279:
P = [3,44586,44559,0]
L = []
for i in P:
    L.append(ID_dic[i])
import matplotlib.pyplot as plt
import numpy as np
x3,y3 = place_to_co(L)
plt.scatter(x3,y3)
65/280:
Start_side = [i[0] for i in Pair]
Target_side = [i[1] for i in Pair]
65/281: Pair
65/282: Start_side
65/283:
for i in range(len(Target_side)):
    if Target_side[i] != ('D','E'):
        image[Target_side[i][1]][Target_side[i][0]] = [255,255,255]
        Pair.append([Start_side[i],Target_side[i]])
65/284: Image.fromarray(image)
65/285:
Start_side = [i[0] for i in Pair]
Target_side = [i[1] for i in Pair]
65/286: Pair
65/287: Start_side
65/288:
Node_dic = {}
ID = 0
65/289:
for n in Start_side:
    Node_dic[n] = ID
    ID = ID + 1
65/290:
for n in Target_side:
    Node_dic[n] = ID
    ID = ID + 1
65/291:
Move_area = []
for x in range(image.shape[1]):
    for y in range(image.shape[0]):
        if np.array_equal(image[y][x],[255,0,0]):
            Node_dic[(x,y)] = ID
            Move_area.append((x,y))
            ID = ID + 1
65/292:
def get_color(node,img):
    return img[node[1]][node[0]]
def get_edge(node1,node2,Source):
    return (Node_dic[node1],Node_dic[node2],cv2.norm(get_color(node1,Source),get_color(node2,Source)))
65/293: Target_side
65/294:
Edge = []
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
65/295:
for S in Target_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
65/296: Edge
65/297:
Node_dic = {}
ID = 0
65/298: Start_side
65/299: Target_side
65/300:
for n in Start_side:
    Node_dic[n] = ID
    ID = ID + 1
65/301:
for n in Target_side:
    Node_dic[n] = ID
    ID = ID + 1
65/302:
Move_area = []
for x in range(image.shape[1]):
    for y in range(image.shape[0]):
        if np.array_equal(image[y][x],[255,0,0]):
            Node_dic[(x,y)] = ID
            Move_area.append((x,y))
            ID = ID + 1
65/303:
def get_color(node,img):
    return img[node[1]][node[0]]
def get_edge(node1,node2,Source):
    return (Node_dic[node1],Node_dic[node2],cv2.norm(get_color(node1,Source),get_color(node2,Source)))
65/304:
Edge = []
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
65/305:
for S in Target_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
65/306: Edge
65/307:
for i in Start_side:
    print(Node_dic[i])
65/308: [i for i in pair]
65/309: [i for i in Pair]
65/310: Start_side
65/311: Target_side
65/312: Pair = []
65/313:
for i in range(len(Target_side)):
    if Target_side[i] != ('D','E'):
        image[Target_side[i][1]][Target_side[i][0]] = [255,255,255]
        Pair.append([Start_side[i],Target_side[i]])
65/314: Pair
65/315:
Start_side = [i[0] for i in Pair]
Target_side = [i[1] for i in Pair]
65/316: Start_side
65/317: Target_side
65/318:
for i in Start_side:
    print(Node_dic[i])
65/319:
Node_dic = {}
ID = 0
65/320:
for n in Start_side:
    Node_dic[n] = ID
    ID = ID + 1
65/321:
for n in Target_side:
    Node_dic[n] = ID
    ID = ID + 1
65/322:
for n in Target_side:
    Node_dic[n] = ID
    ID = ID + 1
65/323:
Move_area = []
for x in range(image.shape[1]):
    for y in range(image.shape[0]):
        if np.array_equal(image[y][x],[255,0,0]):
            Node_dic[(x,y)] = ID
            Move_area.append((x,y))
            ID = ID + 1
65/324:
def get_color(node,img):
    return img[node[1]][node[0]]
def get_edge(node1,node2,Source):
    return (Node_dic[node1],Node_dic[node2],cv2.norm(get_color(node1,Source),get_color(node2,Source)))
65/325:
Edge = []
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
65/326:
for S in Target_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
65/327:
for i in Start_side:
    print(Node_dic[i])
65/328:
for i in Start_side:
    print(Node_dic[i])
65/329: Start_side
65/330: Target_side
65/331: Target_side
65/332:
Node_dic = {}
ID = 0
65/333:
for n in Start_side:
    Node_dic[n] = ID
    ID = ID + 1
65/334:
for i in Start_side:
    print(Node_dic[i])
65/335: Node_dic
65/336:
for n in Start_side:
    print(n)
    Node_dic[n] = ID
    ID = ID + 1
65/337:
for n in Start_side:
    print(n)
    Node_dic[n] = ID
    ID = ID + 1
    print(ID)
65/338:
Node_dic = {}
ID = 0
65/339:
for n in Start_side:
    print(n)
    Node_dic[n] = ID
    ID = ID + 1
    print(ID)
65/340:
for i in Start_side:
    print(Node_dic[i])
65/341: Start
65/342: Start_side
65/343: Start_side = bresenham(Start,End).path
65/344: Start_side
65/345:
print(Start_side)
test = np.zeros(Source.shape, dtype=np.uint8)
image = test
O = np.int32([Outline])
I = np.int32([
    Innerline])
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
Image.fromarray(image)
65/346:
for i in range(len(Start_side)):
    image[Start_side[i][1]][Start_side[i][0]] = [0,0,255]
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
65/347: Start_side
65/348: Target_side
65/349:
for i in range(len(Target_side)):
    if Target_side[i] != ('D','E'):
        image[Target_side[i][1]][Target_side[i][0]] = [255,255,255]
Image.fromarray(image)
65/350:
Node_dic = {}
ID = 0
65/351:
for n in Start_side:
    Node_dic[n] = ID
    ID = ID + 1
65/352: Start_side
65/353:
for i in Start_side:
    print(Node_dic[i])
65/354:
for n in Target_side:
    Node_dic[n] = ID
    ID = ID + 1
65/355:
Move_area = []
for x in range(image.shape[1]):
    for y in range(image.shape[0]):
        if np.array_equal(image[y][x],[255,0,0]):
            Node_dic[(x,y)] = ID
            Move_area.append((x,y))
            ID = ID + 1
65/356:
def get_color(node,img):
    return img[node[1]][node[0]]
def get_edge(node1,node2,Source):
    return (Node_dic[node1],Node_dic[node2],cv2.norm(get_color(node1,Source),get_color(node2,Source)))
65/357:
Edge = []
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
65/358:
for S in Target_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
65/359:
for i in Start_side:
    print(Node_dic[i])
65/360: Edge
65/361:
Normal_edge = []
for node in Move_area:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            Normal_edge.append(get_edge(R,node,Source))
65/362:
Node_All = Start_side + Target_side + Move_area
Edge_All = Edge + Normal_edge
65/363:
with open("Edge","w") as f:
    for line in Edge_All:
        f.write(str(line[0])+" "+str(line[1])+" "+("%.2f" % line[2])+"\n")
65/364:
with open("Node","w") as f:
    for node,ID in Node_dic.items():
        f.write(str(node[0])+" "+str(node[1])+" "+str(ID)+"\n")
65/365: Target_side[0]
65/366: Start_side[0]
65/367: Node_dic[Target_side[0]]
65/368: Node_dic[Start_side[0]]
65/369: k
65/370:
P = [5,44563,44533,0]
L = []
for i in P:
    L.append(ID_dic[i])
import matplotlib.pyplot as plt
import numpy as np
x3,y3 = place_to_co(L)
plt.scatter(x3,y3)
65/371:
P = [5,44563,44533,0]
L = []
for i in P:
    L.append(ID_dic[i])
print(L)
import matplotlib.pyplot as plt
import numpy as np
x3,y3 = place_to_co(L)
plt.scatter(x3,y3)
65/372: image[110][254]
65/373: image[110][354]
65/374: Image.fromarray(image)
65/375: image.shape
65/376: Start_side
65/377: Target_side
65/378:
a = 353
b = 110
image[b][a] = [0,255,0]
65/379:
Node_dic = {}
ID = 0
65/380:
a = 353
b = 110
image[b][a] = [0,255,0]
Image.fromarray(image)
65/381:
Node_dic = {}
ID = 0
65/382:
for n in Start_side:
    Node_dic[n] = ID
    ID = ID + 1
65/383:
for n in Target_side:
    Node_dic[n] = ID
    ID = ID + 1
65/384:
Move_area = []
for x in range(image.shape[1]):
    for y in range(image.shape[0]):
        if np.array_equal(image[y][x],[255,0,0]):
            Node_dic[(x,y)] = ID
            Move_area.append((x,y))
            ID = ID + 1
65/385:
def get_color(node,img):
    return img[node[1]][node[0]]
def get_edge(node1,node2,Source):
    return (Node_dic[node1],Node_dic[node2],cv2.norm(get_color(node1,Source),get_color(node2,Source)))
65/386:
Edge = []
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
65/387:
for S in Target_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
65/388:
for i in Start_side:
    print(Node_dic[i])
65/389: Edge
65/390:
Normal_edge = []
for node in Move_area:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            Normal_edge.append(get_edge(R,node,Source))
65/391:
Node_All = Start_side + Target_side + Move_area
Edge_All = Edge + Normal_edge
65/392:
with open("Edge","w") as f:
    for line in Edge_All:
        f.write(str(line[0])+" "+str(line[1])+" "+("%.2f" % line[2])+"\n")
65/393:
with open("Node","w") as f:
    for node,ID in Node_dic.items():
        f.write(str(node[0])+" "+str(node[1])+" "+str(ID)+"\n")
65/394: Target_side[0]
65/395: Start_side[0]
65/396: Node_dic[Target_side[0]]
65/397: Node_dic[Start_side[0]]
65/398:
with open("path") as f:
    p = f.read()
65/399: path = ((p.strip("\n")).split("[")[1]).strip("]").split()
65/400: path
65/401: path
65/402:
with open("path") as f:
    p = f.read()
65/403: path = ((p.strip("\n")).split("[")[1]).strip("]").split()
65/404: path
65/405: pim = image
65/406: ID_dic = {v: k for k, v in Node_dic.items()}
65/407:
enclose = []
for i in path:
    p = ID_dic[int(i)]
    enclose.append(p)
    pim[p[1]][p[0]] = [200,200,200]
65/408: plt.scatter([i[0] for i in enclose],[i[1] for i in enclose])
65/409: Image.fromarray(pim)
65/410: sum(Loss(enclose,0))/(len(enclose))
65/411: import copy
65/412: Image.fromarray(image)
65/413:
def read_path_plot(path):
    with open(path) as f:
        p = f.read()
    path = ((p.strip("\n")).split("[")[1]).strip("]").split()
    pim = copy.deepcopy(image)
    enclose = []
    for i in path:
        p = ID_dic[int(i)]
        enclose.append(p)
        pim[p[1]][p[0]] = [100,220,220]
    Image.fromarray(pim)
65/414: read_path_plot("path1")
65/415:
def read_path_plot(path):
    with open(path) as f:
        p = f.read()
    path = ((p.strip("\n")).split("[")[1]).strip("]").split()
    pim = copy.deepcopy(image)
    enclose = []
    for i in path:
        p = ID_dic[int(i)]
        enclose.append(p)
        pim[p[1]][p[0]] = [100,220,220]
    return Image.fromarray(pim)
65/416: read_path_plot("path1")
65/417:
def read_path_plot(path):
    with open(path) as f:
        p = f.read()
    path = ((p.strip("\n")).split("[")[1]).strip("]").split()
    pim = copy.deepcopy(image)
    enclose = []
    for i in path:
        p = ID_dic[int(i)]
        enclose.append(p)
        pim[p[1]][p[0]] = [100,220,220]
    print(sum(Loss(enclose,0))/(len(enclose)))
    return Image.fromarray(pim)
65/418: read_path_plot("path1")
65/419: read_path_plot("path2")
65/420:
def read_path_plot(path):
    with open(path) as f:
        p = f.read()
    path = ((p.strip("\n")).split("[")[1]).strip("]").split()
    pim = copy.deepcopy(image)
    enclose = []
    for i in path:
        p = ID_dic[int(i)]
        enclose.append(p)
        pim[p[1]][p[0]] = [100,220,220]
    print(Image.fromarray(pim))
    print(sum(Loss(enclose,0))/(len(enclose)))
    return Image.fromarray(pim)
65/421: read_path_plot("path1")
65/422:
def read_path_plot(path):
    with open(path) as f:
        p = f.read()
    path = ((p.strip("\n")).split("[")[1]).strip("]").split()
    pim = copy.deepcopy(image)
    enclose = []
    for i in path:
        p = ID_dic[int(i)]
        enclose.append(p)
        pim[p[1]][p[0]] = [100,220,220]
    L = sum(Loss(enclose,0))
    k = L/(len(enclose))
    return Image.fromarray(pim),enclose,L,k
65/423: plot,enclose,Loss,k = read_path_plot("path1")
65/424: plot
65/425: print Loss
65/426: print(Loss)
65/427: print(Loss,k)
65/428: plot
65/429: plot,enclose,Loss,k = read_path_plot("path2")
65/430:
def read_path_plot(path):
    with open(path) as f:
        p = f.read()
    path = ((p.strip("\n")).split("[")[1]).strip("]").split()
    pim = copy.deepcopy(image)
    enclose = []
    for i in path:
        p = ID_dic[int(i)]
        enclose.append(p)
        pim[p[1]][p[0]] = [100,220,220]
    L = sum(Loss(enclose,0))
    k = L/(len(enclose))
    return Image.fromarray(pim),enclose,L,k
65/431: plot,enclose,Loss,k = read_path_plot("path2")
65/432: plot,enclose,Loss,k = read_path_plot("path1")
65/433: plot,enclose,Loss,k = read_path_plot("path1")
65/434:
def read_path_plot(path):
    with open(path) as f:
        p = f.read()
    path = ((p.strip("\n")).split("[")[1]).strip("]").split()
    pim = copy.deepcopy(image)
    enclose = []
    for i in path:
        p = ID_dic[int(i)]
        enclose.append(p)
        pim[p[1]][p[0]] = [100,220,220]
    L = sum(Loss(enclose,0))
    print(enclose)
    k = L/(len(enclose))
    return Image.fromarray(pim),enclose,L,k
65/435: plot,enclose,Loss,k = read_path_plot("path1")
65/436:
def read_path_plot(path):
    with open(path) as f:
        p = f.read()
    path = ((p.strip("\n")).split("[")[1]).strip("]").split()
    pim = copy.deepcopy(image)
    enclose = []
    for i in path:
        p = ID_dic[int(i)]
        enclose.append(p)
        pim[p[1]][p[0]] = [100,220,220]
    k = sum(Loss(enclose,0))/(len(enclose))
    return Image.fromarray(pim),enclose,k
65/437: plot,enclose,k = read_path_plot("path1")
65/438:
def read_path_plot(path):
    with open(path) as f:
        p = f.read()
    path = ((p.strip("\n")).split("[")[1]).strip("]").split()
    pim = copy.deepcopy(image)
    enclose = []
    for i in path:
        p = ID_dic[int(i)]
        enclose.append(p)
        pim[p[1]][p[0]] = [100,220,220]
    return Image.fromarray(pim),enclose
65/439: plot,enclose = read_path_plot("path1")
65/440: plot
65/441: Loss(enclose,0)
65/442:
Loss = []
for i in range(len(enclose)-1):
    Loss.append(cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]]))
65/443: enclose
65/444:
Line = copy.deepcopy(enclose)
Loss = []
for i in range(len(Line)-1):
    Loss.append(cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]]))
65/445: sum(Loss)
65/446: sum(Loss)
65/447: plot,enclose = read_path_plot("path2")
65/448: pot
65/449: plot
65/450:
Line = copy.deepcopy(enclose)
Loss = []
for i in range(len(Line)-1):
    Loss.append(cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]]))
65/451: sum(Loss)
65/452: print("sum:"+sum(Loss))
65/453: print("sum:"+str(sum(Loss))
65/454: print("sum:"+str(sum(Loss)))
65/455:
print("sum:"+str(sum(Loss)))
print("k:"str(str(sum(Loss))/len(enclose)))
65/456:
print("sum:"+str(sum(Loss)))
print("k:"str(sum(Loss))/len(enclose)))
65/457:
print("sum:"+str(sum(Loss)))
print("k:"str(sum(Loss))/len(enclose))
65/458:
print("sum:"+str(sum(Loss)))
print("k:"+str(sum(Loss))/len(enclose))
65/459:
print("sum:"+str(sum(Loss)))
print("k:"+str(sum(Loss)/len(enclose)))
65/460:
def read_path_plot(path):
    with open(path) as f:
        p = f.read()
    path = ((p.strip("\n")).split("[")[1]).strip("]").split()
    pim = copy.deepcopy(image)
    enclose = []
    for i in path:
        p = ID_dic[int(i)]
        enclose.append(p)
        pim[p[1]][p[0]] = [100,220,220]
    Line = copy.deepcopy(enclose)
    Loss = []
    for i in range(len(Line)-1):
        Loss.append(cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]]))
    print("sum:"+str(sum(Loss)))
    print("k:"+str(sum(Loss)/len(enclose)))
    return Image.fromarray(pim),enclose
65/461: plot,enclose = read_path_plot("path1")
65/462: plot,enclose = read_path_plot("path1")
65/463: plot,enclose = read_path_plot("path")
65/464: plot,enclose = read_path_plot("path2")
65/465: plot,enclose = read_path_plot("path3")
65/466: plot,enclose = read_path_plot("path4")
65/467: plot
65/468:
Node_dic[Start_side[0]]
ID_dic = {v: k for k, v in Node_dic.items()}
65/469:
test = np.zeros(Source.shape, dtype=np.uint8)
E = np.int32([enclose])
T = cv2.fillPoly(test,E,(255,255,255))
65/470: Image.fromarray(T)
65/471: cv2.imwrite(T,"Mask.png")
65/472: cv2.imwrite("Mask.png",T)
65/473:
img = cv2.imread('Source.png')
mask = cv2.imread('Mask.png',0)
res = cv2.bitwise_and(img,img,mask = mask)
65/474: Image.fromarray(res)
65/475: plot,enclose = read_path_plot("path")
65/476: plot
65/477: plt.scatter([i[0] for i in enclose],[i[1] for i in enclose])
65/478: Image.fromarray(pim)
65/479:
test = np.zeros(Source.shape, dtype=np.uint8)
E = np.int32([enclose])
T = cv2.fillPoly(test,E,(255,255,255))
65/480: Image.fromarray(T)
65/481: cv2.imwrite("Mask.png",T)
65/482:
img = cv2.imread('Source.png')
mask = cv2.imread('Mask.png',0)
res = cv2.bitwise_and(img,img,mask = mask)
65/483: Image.fromarray(res)
65/484: plot,enclose = read_path_plot("path1")
65/485: plot
65/486:
a = 353
b = 110
image[b][a] = [0,255,0]
Image.fromarray(image)
65/487:
for i in range(len(Target_side)):
    if Target_side[i] != ('D','E'):
        image[Target_side[i][1]][Target_side[i][0]] = [255,255,255]
Image.fromarray(image)
65/488:
print(Start_side)
test = np.zeros(Source.shape, dtype=np.uint8)
image = test
O = np.int32([Outline])
I = np.int32([
    Innerline])
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
Image.fromarray(image)
65/489:
for i in range(len(Target_side)):
    if Target_side[i] != ('D','E'):
        image[Target_side[i][1]][Target_side[i][0]] = [255,255,255]
Image.fromarray(image)
65/490:
for i in range(len(Start_side)):
    image[Start_side[i][1]][Start_side[i][0]] = [0,0,255]
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
65/491:
print(Start_side)
test = np.zeros(Source.shape, dtype=np.uint8)
image = test
O = np.int32([Outline])
I = np.int32([
    Innerline])
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
Image.fromarray(image)
65/492:
for i in range(len(Start_side)):
    image[Start_side[i][1]][Start_side[i][0]] = [0,0,255]
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
65/493:
for i in range(len(Target_side)):
    if Target_side[i] != ('D','E'):
        image[Target_side[i][1]][Target_side[i][0]] = [255,255,255]
Image.fromarray(image)
65/494:
def place_to_co(p):
    return [i[0] for i in p],[i[1] for i in p]
65/495:
a = 353
b = 110
image[b][a] = [0,255,0]
Image.fromarray(image)
65/496: Image.fromarray(image)
65/497: plot,enclose = read_path_plot("path")
65/498: plot
65/499:
for i in Target_side:
    print(Node_dic[i])
65/500: plot,enclose = read_path_plot("path1")
65/501: plot,enclose = read_path_plot("path1")
65/502:
def read_path_plot(path):
    with open(path) as f:
        p = f.read()
    path = p.split()
    pim = copy.deepcopy(image)
    enclose = []
    for i in path:
        p = ID_dic[int(i)]
        enclose.append(p)
        pim[p[1]][p[0]] = [100,220,220]
    Line = copy.deepcopy(enclose)
    Loss = []
    for i in range(len(Line)-1):
        Loss.append(cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]]))
    print("sum:"+str(sum(Loss)))
    print("k:"+str(sum(Loss)/len(enclose)))
    return Image.fromarray(pim),enclose
65/503: plot,enclose = read_path_plot("path1")
65/504: plot
65/505: cv2.imwrite("Masked.png",res)
66/1:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("t.png")
mask = cv2.imread("mask.png", cv2.IMREAD_GRAYSCALE) 
offset = (0, 66)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
66/2:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("t.png")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
offset = (0, 66)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
66/3:
y_max, x_max = target.shape[:-1]
y_min, x_min = 0, 0
x_range = x_max - x_min
y_range = y_max - y_min

M = np.float32([[1, 0, offset[0]], [0, 1, offset[1]]])
source = cv2.warpAffine(source, M, (x_range, y_range))

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) 
plt.show()
66/4:
mask = mask[y_min:y_max, x_min:x_max]
mask[mask != 0] = 1
66/5:
mat_A = laplacian_matrix(y_range, x_range)
laplacian = mat_A.tocsc()
66/6:
import scipy.sparse

def laplacian_matrix(n, m):   
    mat_D = scipy.sparse.lil_matrix((m, m))
    mat_D.setdiag(-1, -1)
    mat_D.setdiag(4)
    mat_D.setdiag(-1, 1)
        
    mat_A = scipy.sparse.block_diag([mat_D] * n).tolil()
    
    mat_A.setdiag(-1, 1*m)
    mat_A.setdiag(-1, -1*m)
    
    return mat_A

laplacian_matrix(3, 3).todense()
66/7:
mat_A = laplacian_matrix(y_range, x_range)
laplacian = mat_A.tocsc()
66/8:
for y in range(1, y_range - 1):
    for x in range(1, x_range - 1):
        if mask[y, x] == 0:
            k = x + y * x_range
            mat_A[k, k] = 1
            mat_A[k, k + 1] = 0
            mat_A[k, k - 1] = 0
            mat_A[k, k + x_range] = 0
            mat_A[k, k - x_range] = 0
mat_A = mat_A.tocsc()
66/9:
import scipy.sparse

def laplacian_matrix(n, m):   
    mat_D = scipy.sparse.lil_matrix((m, m))
    mat_D.setdiag(-1, -1)
    mat_D.setdiag(4)
    mat_D.setdiag(-1, 1)
        
    mat_A = scipy.sparse.block_diag([mat_D] * n).tolil()
    
    mat_A.setdiag(-1, 1*m)
    mat_A.setdiag(-1, -1*m)
    
    return mat_A

laplacian_matrix(3, 3).todense()
66/10:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("t.png")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
offset = (0, 66)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
66/11:
y_max, x_max = target.shape[:-1]
y_min, x_min = 0, 0
x_range = x_max - x_min
y_range = y_max - y_min

M = np.float32([[1, 0, offset[0]], [0, 1, offset[1]]])
source = cv2.warpAffine(source, M, (x_range, y_range))

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) 
plt.show()
66/12:
mask = mask[y_min:y_max, x_min:x_max]
mask[mask != 0] = 1
66/13:
mat_A = laplacian_matrix(y_range, x_range)
laplacian = mat_A.tocsc()
66/14:
for y in range(1, y_range - 1):
    for x in range(1, x_range - 1):
        if mask[y, x] == 0:
            k = x + y * x_range
            mat_A[k, k] = 1
            mat_A[k, k + 1] = 0
            mat_A[k, k - 1] = 0
            mat_A[k, k + x_range] = 0
            mat_A[k, k - x_range] = 0
mat_A = mat_A.tocsc()
66/15:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("source1.png") 
target = cv2.imread("target1.png")
mask = cv2.imread("mask1.png", cv2.IMREAD_GRAYSCALE) 
offset = (0, 66)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
66/16:
import scipy.sparse

def laplacian_matrix(n, m):   
    mat_D = scipy.sparse.lil_matrix((m, m))
    mat_D.setdiag(-1, -1)
    mat_D.setdiag(4)
    mat_D.setdiag(-1, 1)
        
    mat_A = scipy.sparse.block_diag([mat_D] * n).tolil()
    
    mat_A.setdiag(-1, 1*m)
    mat_A.setdiag(-1, -1*m)
    
    return mat_A

laplacian_matrix(3, 3).todense()
66/17:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("source1.png") 
target = cv2.imread("target1.png")
mask = cv2.imread("mask1.png", cv2.IMREAD_GRAYSCALE) 
offset = (0, 66)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
66/18:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("source1.jpg") 
target = cv2.imread("target1.jpg")
mask = cv2.imread("mask1.png", cv2.IMREAD_GRAYSCALE) 
offset = (0, 66)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
66/19:
y_max, x_max = target.shape[:-1]
y_min, x_min = 0, 0
x_range = x_max - x_min
y_range = y_max - y_min

M = np.float32([[1, 0, offset[0]], [0, 1, offset[1]]])
source = cv2.warpAffine(source, M, (x_range, y_range))

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) 
plt.show()
66/20:
mask = mask[y_min:y_max, x_min:x_max]
mask[mask != 0] = 1
66/21:
mat_A = laplacian_matrix(y_range, x_range)
laplacian = mat_A.tocsc()
66/22:
for y in range(1, y_range - 1):
    for x in range(1, x_range - 1):
        if mask[y, x] == 0:
            k = x + y * x_range
            mat_A[k, k] = 1
            mat_A[k, k + 1] = 0
            mat_A[k, k - 1] = 0
            mat_A[k, k + x_range] = 0
            mat_A[k, k - x_range] = 0
mat_A = mat_A.tocsc()
66/23:
from scipy.sparse.linalg import spsolve

mask_flat = mask.flatten()    
for channel in range(source.shape[2]):
    source_flat = source[y_min:y_max, x_min:x_max, channel].flatten()
    target_flat = target[y_min:y_max, x_min:x_max, channel].flatten()        

    # inside the mask:
    # \Delta f = div v = \Delta g       
    alpha = 1
    mat_b = laplacian.dot(source_flat)*alpha

    # outside the mask:
    # f = t
    mat_b[mask_flat == 0] = target_flat[mask_flat == 0]
    
    x = spsolve(mat_A, mat_b)    
    x = x.reshape((y_range, x_range))
    x[x > 255] = 255
    x[x < 0] = 0
    x = x.astype('uint8')
    
    target[y_min:y_max, x_min:x_max, channel] = x
66/24:
plt.imshow(target[:,:,::-1]) 
plt.show()

out_dir = 'figs'
cv2.imwrite(path.join(out_dir, "possion1.png"), target)
66/25:
plt.imshow(target[:,:,::-1]) 
plt.show()
66/26:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("target1.jpg")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
offset = (0, 66)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
66/27:
y_max, x_max = target.shape[:-1]
y_min, x_min = 0, 0
x_range = x_max - x_min
y_range = y_max - y_min

M = np.float32([[1, 0, offset[0]], [0, 1, offset[1]]])
source = cv2.warpAffine(source, M, (x_range, y_range))

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) 
plt.show()
66/28:
mask = mask[y_min:y_max, x_min:x_max]
mask[mask != 0] = 1
66/29:
mat_A = laplacian_matrix(y_range, x_range)
laplacian = mat_A.tocsc()
66/30:
for y in range(1, y_range - 1):
    for x in range(1, x_range - 1):
        if mask[y, x] == 0:
            k = x + y * x_range
            mat_A[k, k] = 1
            mat_A[k, k + 1] = 0
            mat_A[k, k - 1] = 0
            mat_A[k, k + x_range] = 0
            mat_A[k, k - x_range] = 0
mat_A = mat_A.tocsc()
66/31:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("target1.jpg")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
resized = cv2.resize(target,source.shape, interpolation = cv2.INTER_AREA)
offset = (0, 66)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
66/32:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("target1.jpg")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
resized = cv2.resize(target,source.shape[:1], interpolation = cv2.INTER_AREA)
offset = (0, 66)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
66/33:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("target1.jpg")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
resized = cv2.resize(target,source.shape[:1], interpolation = cv2.INTER_AREA)
offset = (0, 66)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
66/34:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("target1.jpg")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
resized = cv2.resize(target,[337,404], interpolation = cv2.INTER_AREA)
offset = (0, 66)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
66/35:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("target1.jpg")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
resized = cv2.resize(target,(337,404), interpolation = cv2.INTER_AREA)
offset = (0, 66)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
66/36:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("target1.jpg")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
resized = cv2.resize(target,(337,404), interpolation = cv2.INTER_AREA)
offset = (0, 66)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', resized.shape[:-1])
plt.imshow(resized[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
66/37:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("target1.jpg")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
resized = cv2.resize(target,(404,337), interpolation = cv2.INTER_AREA)
offset = (0, 66)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', resized.shape[:-1])
plt.imshow(resized[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
66/38:
y_max, x_max = target.shape[:-1]
y_min, x_min = 0, 0
x_range = x_max - x_min
y_range = y_max - y_min

M = np.float32([[1, 0, offset[0]], [0, 1, offset[1]]])
source = cv2.warpAffine(source, M, (x_range, y_range))

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) 
plt.show()
66/39:
mask = mask[y_min:y_max, x_min:x_max]
mask[mask != 0] = 1
66/40:
mat_A = laplacian_matrix(y_range, x_range)
laplacian = mat_A.tocsc()
66/41:
for y in range(1, y_range - 1):
    for x in range(1, x_range - 1):
        if mask[y, x] == 0:
            k = x + y * x_range
            mat_A[k, k] = 1
            mat_A[k, k + 1] = 0
            mat_A[k, k - 1] = 0
            mat_A[k, k + x_range] = 0
            mat_A[k, k - x_range] = 0
mat_A = mat_A.tocsc()
66/42:
for y in range(1, y_range - 1):
    for x in range(1, x_range - 1):
        if mask[y, x] == 0:
            k = x + y * x_range
            mat_A[k, k] = 1
            mat_A[k, k + 1] = 0
            mat_A[k, k - 1] = 0
            mat_A[k, k + x_range] = 0
            mat_A[k, k - x_range] = 0
mat_A = mat_A.tocsc()
66/43:
from scipy.sparse.linalg import spsolve

mask_flat = mask.flatten()    
for channel in range(source.shape[2]):
    source_flat = source[y_min:y_max, x_min:x_max, channel].flatten()
    target_flat = target[y_min:y_max, x_min:x_max, channel].flatten()        

    # inside the mask:
    # \Delta f = div v = \Delta g       
    alpha = 1
    mat_b = laplacian.dot(source_flat)*alpha

    # outside the mask:
    # f = t
    mat_b[mask_flat == 0] = target_flat[mask_flat == 0]
    
    x = spsolve(mat_A, mat_b)    
    x = x.reshape((y_range, x_range))
    x[x > 255] = 255
    x[x < 0] = 0
    x = x.astype('uint8')
    
    target[y_min:y_max, x_min:x_max, channel] = x
66/44:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("target1.jpg")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
resized = cv2.resize(target,(404,337), interpolation = cv2.INTER_AREA)
offset = (0,0)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', resized.shape[:-1])
plt.imshow(resized[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
66/45:
y_max, x_max = target.shape[:-1]
y_min, x_min = 0, 0
x_range = x_max - x_min
y_range = y_max - y_min

M = np.float32([[1, 0, offset[0]], [0, 1, offset[1]]])
source = cv2.warpAffine(source, M, (x_range, y_range))

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) 
plt.show()
66/46:
mask = mask[y_min:y_max, x_min:x_max]
mask[mask != 0] = 1
66/47:
mat_A = laplacian_matrix(y_range, x_range)
laplacian = mat_A.tocsc()
66/48:
for y in range(1, y_range - 1):
    for x in range(1, x_range - 1):
        if mask[y, x] == 0:
            k = x + y * x_range
            mat_A[k, k] = 1
            mat_A[k, k + 1] = 0
            mat_A[k, k - 1] = 0
            mat_A[k, k + x_range] = 0
            mat_A[k, k - x_range] = 0
mat_A = mat_A.tocsc()
66/49:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("target1.jpg")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
resized = cv2.resize(target,(800,800), interpolation = cv2.INTER_AREA)
offset = (50,50)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', resized.shape[:-1])
plt.imshow(resized[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
66/50:
y_max, x_max = target.shape[:-1]
y_min, x_min = 0, 0
x_range = x_max - x_min
y_range = y_max - y_min

M = np.float32([[1, 0, offset[0]], [0, 1, offset[1]]])
source = cv2.warpAffine(source, M, (x_range, y_range))

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) 
plt.show()
66/51:
mask = mask[y_min:y_max, x_min:x_max]
mask[mask != 0] = 1
66/52:
mat_A = laplacian_matrix(y_range, x_range)
laplacian = mat_A.tocsc()
66/53:
for y in range(1, y_range - 1):
    for x in range(1, x_range - 1):
        if mask[y, x] == 0:
            k = x + y * x_range
            mat_A[k, k] = 1
            mat_A[k, k + 1] = 0
            mat_A[k, k - 1] = 0
            mat_A[k, k + x_range] = 0
            mat_A[k, k - x_range] = 0
mat_A = mat_A.tocsc()
66/54:
for y in range(1, y_range - 1):
    for x in range(1, x_range - 1):
        if mask[y, x] == 0:
            k = x + y * x_range
            mat_A[k, k] = 1
            mat_A[k, k + 1] = 0
            mat_A[k, k - 1] = 0
            mat_A[k, k + x_range] = 0
            mat_A[k, k - x_range] = 0
mat_A = mat_A.tocsc()
66/55:
for y in range(1, y_range - 1):
    for x in range(1, x_range - 1):
        if mask[y, x] == 0:
            k = x + y * x_range
            mat_A[k, k] = 1
            mat_A[k, k + 1] = 0
            mat_A[k, k - 1] = 0
            mat_A[k, k + x_range] = 0
            mat_A[k, k - x_range] = 0
mat_A = mat_A.tocsc()
66/56:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("target1.jpg")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
resized = cv2.resize(target,(800,800), interpolation = cv2.INTER_AREA)
offset = (300,300)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', resized.shape[:-1])
plt.imshow(resized[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
66/57:
y_max, x_max = resized.shape[:-1]
y_min, x_min = 0, 0
x_range = x_max - x_min
y_range = y_max - y_min

M = np.float32([[1, 0, offset[0]], [0, 1, offset[1]]])
source = cv2.warpAffine(source, M, (x_range, y_range))

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) 
plt.show()
66/58:
mask = mask[y_min:y_max, x_min:x_max]
mask[mask != 0] = 1
66/59:
mat_A = laplacian_matrix(y_range, x_range)
laplacian = mat_A.tocsc()
66/60:
for y in range(1, y_range - 1):
    for x in range(1, x_range - 1):
        if mask[y, x] == 0:
            k = x + y * x_range
            mat_A[k, k] = 1
            mat_A[k, k + 1] = 0
            mat_A[k, k - 1] = 0
            mat_A[k, k + x_range] = 0
            mat_A[k, k - x_range] = 0
mat_A = mat_A.tocsc()
66/61:
for y in range(1, y_range - 1):
    for x in range(1, x_range - 1):
        if mask[y, x] == 0:
            k = x + y * x_range
            mat_A[k, k] = 1
            mat_A[k, k + 1] = 0
            mat_A[k, k - 1] = 0
            mat_A[k, k + x_range] = 0
            mat_A[k, k - x_range] = 0
mat_A = mat_A.tocsc()
66/62:
for y in range(1, y_range - 1):
    for x in range(1, x_range - 1):
        if mask[y, x] == 0:
            k = x + y * x_range
            mat_A[k, k] = 1
            mat_A[k, k + 1] = 0
            mat_A[k, k - 1] = 0
            mat_A[k, k + x_range] = 0
            mat_A[k, k - x_range] = 0
mat_A = mat_A.tocsc()
66/63:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("source1.jpg") 
target = cv2.imread("target1.jpg")
mask = cv2.imread("mask1.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,)

print('Source image size:', source.shape[:-1])
plt.imshow(sour60ce[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
66/64:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("source1.jpg") 
target = cv2.imread("target1.jpg")
mask = cv2.imread("mask1.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,60)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
67/1:
import scipy.sparse

def laplacian_matrix(n, m):   
    mat_D = scipy.sparse.lil_matrix((m, m))
    mat_D.setdiag(-1, -1)
    mat_D.setdiag(4)
    mat_D.setdiag(-1, 1)
        
    mat_A = scipy.sparse.block_diag([mat_D] * n).tolil()
    
    mat_A.setdiag(-1, 1*m)
    mat_A.setdiag(-1, -1*m)
    
    return mat_A

laplacian_matrix(3, 3).todense()
67/2: import copy
67/3:
import copy
import numpy as np
67/4:
import cv2
import numpy as np
import matplotlib.pyplot as plt
import copy
%matplotlib inline

source = cv2.imread("source1.jpg") 
target = cv2.imread("target1.jpg")
mask = cv2.imread("mask1.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,60)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
   1:
import scipy.sparse

def laplacian_matrix(n, m):   
    mat_D = scipy.sparse.lil_matrix((m, m))
    mat_D.setdiag(-1, -1)
    mat_D.setdiag(4)
    mat_D.setdiag(-1, 1)
        
    mat_A = scipy.sparse.block_diag([mat_D] * n).tolil()
    
    mat_A.setdiag(-1, 1*m)
    mat_A.setdiag(-1, -1*m)
    
    return mat_A

laplacian_matrix(3, 3).todense()
   2:
import cv2
import numpy as np
import matplotlib.pyplot as plt
import copy
%matplotlib inline

source = cv2.imread("source1.jpg") 
target = cv2.imread("target1.jpg")
mask = cv2.imread("mask1.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,60)
   3: New_mask = np.zeros(target.shape,dtype=np.uint8)
   4: target.shape
   5:
for x in range(mask.shape[1]):
    for y in range(mask.shape[0]):
        x_ = x+offset[0]
        y_ = y+offset[1]
        New_mask[y_][x_] = mask[y_][x_]
   6:
import cv2
import numpy as np
import matplotlib.pyplot as plt
import copy
%matplotlib inline

source = cv2.imread("source1.jpg") 
target = cv2.imread("target1.jpg")
mask = cv2.imread("mask1.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,20)
   7:
for x in range(mask.shape[1]):
    for y in range(mask.shape[0]):
        x_ = x+offset[0]
        y_ = y+offset[1]
        New_mask[y_][x_] = mask[y_][x_]
   8:
for x in range(mask.shape[1]):
    for y in range(mask.shape[0]):
        x_ = x+offset[0]
        y_ = y+offset[1]
        New_mask[y_][x_] = mask[y_][x_]
   9: New_mask.shape
  10: mask.shape
  11:
import cv2
import numpy as np
import matplotlib.pyplot as plt
import copy
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("t.png")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,20)
  12: New_mask.shape
  13:
for x in range(mask.shape[1]):
    for y in range(mask.shape[0]):
        x_ = x+offset[0]
        y_ = y+offset[1]
        New_mask[y_][x_] = mask[y_][x_]
  14: New_mask = np.zeros(target.shape,dtype=np.uint8)
  15:
for x in range(mask.shape[1]):
    for y in range(mask.shape[0]):
        x_ = x+offset[0]
        y_ = y+offset[1]
        New_mask[y_][x_] = mask[y_][x_]
  16: mask.shape
  17: New_mask.shape
  18:
import cv2
import numpy as np
import matplotlib.pyplot as plt
import copy
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("t.png")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,0)
  19:
for x in range(mask.shape[1]):
    for y in range(mask.shape[0]):
        x_ = x+offset[0]
        y_ = y+offset[1]
        New_mask[y_][x_] = mask[y_][x_]
  20: plt.imshow(New_mask)
  21: plt.imshow(target)
  22: plt.imshow(source)
  23:
y_max, x_max = resized.shape[:-1]
y_min, x_min = 0, 0
x_range = x_max - x_min
y_range = y_max - y_min

M = np.float32([[1, 0, offset[0]], [0, 1, offset[1]]])
source = cv2.warpAffine(source, M, (x_range, y_range))

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) 
plt.show()
  24:
y_max, x_max = source.shape[:-1]
y_min, x_min = 0, 0
x_range = x_max - x_min
y_range = y_max - y_min

M = np.float32([[1, 0, offset[0]], [0, 1, offset[1]]])
source = cv2.warpAffine(source, M, (x_range, y_range))

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) 
plt.show()
68/1:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("t.png")
mask = cv2.imread("mask.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,0)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
68/2:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("t.png")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,0)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
68/3:
y_max, x_max = resized.shape[:-1]
y_min, x_min = 0, 0
x_range = x_max - x_min
y_range = y_max - y_min

M = np.float32([[1, 0, offset[0]], [0, 1, offset[1]]])
source = cv2.warpAffine(source, M, (x_range, y_range))

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) 
plt.show()
68/4:
y_max, x_max = source.shape[:-1]
y_min, x_min = 0, 0
x_range = x_max - x_min
y_range = y_max - y_min

M = np.float32([[1, 0, offset[0]], [0, 1, offset[1]]])
source = cv2.warpAffine(source, M, (x_range, y_range))

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) 
plt.show()
68/5:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("source1.png") 
target = cv2.imread("target1.png")
mask = cv2.imread("mask1.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,0)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
68/6:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("source1.jpg") 
target = cv2.imread("target1.jpg")
mask = cv2.imread("mask1.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,0)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
68/7:
y_max, x_max = source.shape[:-1]
y_min, x_min = 0, 0
x_range = x_max - x_min
y_range = y_max - y_min

M = np.float32([[1, 0, offset[0]], [0, 1, offset[1]]])
source = cv2.warpAffine(source, M, (x_range, y_range))

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) 
plt.show()
68/8:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("source1.jpg") 
target = cv2.imread("target1.jpg")
mask = cv2.imread("mask1.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,60)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
68/9:
y_max, x_max = source.shape[:-1]
y_min, x_min = 0, 0
x_range = x_max - x_min
y_range = y_max - y_min

M = np.float32([[1, 0, offset[0]], [0, 1, offset[1]]])
source = cv2.warpAffine(source, M, (x_range, y_range))

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) 
plt.show()
  25:
import cv2
import numpy as np
import matplotlib.pyplot as plt
import copy
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("t.png")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,0)
print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
  26: Target = cv2.resize(Target,[500,404])
  27: target = cv2.resize(target,[500,404])
  28: target = cv2.resize(target,[500,404],interpolation = cv2.INTER_AREA)
  29: target = cv2.resize(target,(500,404),interpolation = cv2.INTER_AREA)
  30: target = cv2.resize(target,(337,404),interpolation = cv2.INTER_AREA)
68/10:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("t.png")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,0)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
68/11:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("t.png")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,0)
target = cv2.resize(target,(337,404),interpolation = cv2.INTER_AREA)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
68/12:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("t.png")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,0)
target = cv2.resize(target,(404,337),interpolation = cv2.INTER_AREA)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
68/13:
y_max, x_max = source.shape[:-1]
y_min, x_min = 0, 0
x_range = x_max - x_min
y_range = y_max - y_min

M = np.float32([[1, 0, offset[0]], [0, 1, offset[1]]])
source = cv2.warpAffine(source, M, (x_range, y_range))

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) 
plt.show()
68/14:
mask = mask[y_min:y_max, x_min:x_max]
mask[mask != 0] = 1
68/15:
mat_A = laplacian_matrix(y_range, x_range)
laplacian = mat_A.tocsc()
68/16:
import scipy.sparse

def laplacian_matrix(n, m):   
    mat_D = scipy.sparse.lil_matrix((m, m))
    mat_D.setdiag(-1, -1)
    mat_D.setdiag(4)
    mat_D.setdiag(-1, 1)
        
    mat_A = scipy.sparse.block_diag([mat_D] * n).tolil()
    
    mat_A.setdiag(-1, 1*m)
    mat_A.setdiag(-1, -1*m)
    
    return mat_A

laplacian_matrix(3, 3).todense()
68/17:
mask = mask[y_min:y_max, x_min:x_max]
mask[mask != 0] = 1
68/18:
mat_A = laplacian_matrix(y_range, x_range)
laplacian = mat_A.tocsc()
68/19:
for y in range(1, y_range - 1):
    for x in range(1, x_range - 1):
        if mask[y, x] == 0:
            k = x + y * x_range
            mat_A[k, k] = 1
            mat_A[k, k + 1] = 0
            mat_A[k, k - 1] = 0
            mat_A[k, k + x_range] = 0
            mat_A[k, k - x_range] = 0
mat_A = mat_A.tocsc()
68/20:
from scipy.sparse.linalg import spsolve

mask_flat = mask.flatten()    
for channel in range(source.shape[2]):
    source_flat = source[y_min:y_max, x_min:x_max, channel].flatten()
    target_flat = target[y_min:y_max, x_min:x_max, channel].flatten()        

    # inside the mask:
    # \Delta f = div v = \Delta g       
    alpha = 1
    mat_b = laplacian.dot(source_flat)*alpha

    # outside the mask:
    # f = t
    mat_b[mask_flat == 0] = target_flat[mask_flat == 0]
    
    x = spsolve(mat_A, mat_b)    
    x = x.reshape((y_range, x_range))
    x[x > 255] = 255
    x[x < 0] = 0
    x = x.astype('uint8')
    
    target[y_min:y_max, x_min:x_max, channel] = x
68/21:
plt.imshow(target[:,:,::-1]) 
plt.show()
68/22:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("t.png")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,0)
target = cv2.resize(target,source.shape,interpolation = cv2.INTER_AREA)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
68/23:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("t.png")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,0)
target = cv2.resize(target,source.shape[:1],interpolation = cv2.INTER_AREA)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
68/24:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("t.png")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,0)
target = cv2.resize(target,(source.shape[0],source.shape[1]),interpolation = cv2.INTER_AREA)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
68/25:
import cv2
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

source = cv2.imread("s.png") 
target = cv2.imread("t.png")
mask = cv2.imread("Mask.png", cv2.IMREAD_GRAYSCALE) 
offset = (0,0)
target = cv2.resize(target,(source.shape[1],source.shape[0]),interpolation = cv2.INTER_AREA)

print('Source image size:', source.shape[:-1])
plt.imshow(source[:,:,::-1]) # this is a trick to display the image in here 
plt.show()
print('Target image size:', target.shape[:-1])
plt.imshow(target[:,:,::-1])
plt.show()
print('Mask size:', mask.shape)
plt.imshow(mask, cmap='gray')
plt.show()
68/26:
from scipy.sparse.linalg import cg
x_cg = cg(mat_A, mat_b)
68/27: x_vg
68/28: x_cg
68/29:
import time
from scipy.sparse.linalg import cg
t0 = time.time()
x_cg = cg(mat_A, mat_b)
print time.time() - t0, "seconds wall time"
68/30:
import time
from scipy.sparse.linalg import cg
t0 = time.time()
x_cg = cg(mat_A, mat_b)
print(time.time() - t0)
68/31:
t0 = time.time()
x = spsolve(mat_A, mat_b)
print(time.time() - t0)
69/1:
print(Start_side)
test = np.zeros(Source.shape, dtype=np.uint8)
image = test
O = np.int32([Outline])
I = np.int32([
    Innerline])
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
a = 353
b = 110
image[b][a] = [0,255,0]
Image.fromarray(image)
69/2:
test = np.zeros(Source.shape, dtype=np.uint8)
image = test
O = np.int32([Outline])
I = np.int32([
    Innerline])
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
a = 353
b = 110
image[b][a] = [0,255,0]
Image.fromarray(image)
69/3:
print(Start_side)
test = np.zeros(Source.shape, dtype=np.uint8)
image = test
O = np.int32([Outline])
I = np.int32([
    Innerline])
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
Image.fromarray(image)
69/4:
class bresenham:
    def __init__(self, start, end):
        self.start = list(start)
        self.end = list(end)
        self.path = []
        self.steep = abs(self.end[1]-self.start[1]) > abs(self.end[0]-self.start[0])
        if self.steep:
            self.start = self.swap(self.start[0],self.start[1])
            self.end = self.swap(self.end[0],self.end[1])
        if self.start[0] > self.end[0]:
            _x0 = int(self.start[0])
            _x1 = int(self.end[0])
            self.start[0] = _x1
            self.end[0] = _x0
            _y0 = int(self.start[1])
            _y1 = int(self.end[1])
            self.start[1] = _y1
            self.end[1] = _y0
        dx = self.end[0] - self.start[0]
        dy = abs(self.end[1] - self.start[1])
        error = 0
        derr = dy/float(dx)
        ystep = 0
        y = self.start[1]
        if self.start[1] < self.end[1]: ystep = 1
        else: ystep = -1
        for x in range(self.start[0],self.end[0]+1):
            if self.steep:
                self.path.append((y,x))
            else:
                self.path.append((x,y))
            error += derr
            if error >= 0.5:
                y += ystep
                error -= 1.0
    def swap(self,n1,n2):
        return [n2,n1]
69/5:
import cv2
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
69/6: Source = cv2.imread("s.png")
69/7:
def make_outline(path):
    img = cv2.imread(path)
    Points = []
    def on_EVENT_LBUTTONDOWN(event, x, y, flags, param):
        if event == cv2.EVENT_LBUTTONDOWN:
            xy = "%d,%d" % (x, y)
            Points.append([x,y])
            cv2.circle(img, (x,y), 1, (0, 0, 255), thickness=-1)
            cv2.imshow("image", img)
    cv2.namedWindow("image")
    cv2.setMouseCallback("image", on_EVENT_LBUTTONDOWN)
    cv2.imshow("image", img)
    cv2.waitKey(0)
    cv2.destroyWindow("image")
    return Points
69/8:
def plot_line(K):
    print("The points you chose:")
    plt.scatter([i[0] for i in K],[i[1] for i in K])
    plt.show()
    Path = []
    K.append(K[0])
    for i in range(len(K)-1):
        Path.append(bresenham(K[i],K[i+1]).path)
    print("Line:")
    for P in Path:
        plt.scatter([i[0] for i in P],[i[1] for i in P])
    return Path
69/9:
Outline = make_outline("s.png")
Out = plot_line(Outline)
69/10:
Innerline = make_outline("s.png")
Inner = plot_line(Innerline)
69/11:
def Loss(Line,bias):
    Loss = []
    for i in range(len(Line)-1):
        Loss.append(cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]]))
    return Loss
69/12:
Out_loss = []
for Line in Out:
    Out_loss = Out_loss + Loss(Line,0)
k = np.mean(Out_loss)
k
69/13:
def dedu(Out):
    ALL = []
    for i in Out:
        ALL = ALL+i
    Fill = []
    for i in ALL:
        if i not in Fill:
            Fill.append(i)
    return Fill
69/14:
Set_in = dedu(Inner)
len(Set_in)
69/15:
Set_out = dedu(Out)
len(Set_out)
69/16:
Start = Set_in[0]
End = Set_out[0]
distance = cv2.norm(Start,End)
for i in Set_in:
    for j in Set_out:
        d_temp = cv2.norm(i,j)
        if d_temp < distance:
            distance = d_temp
            Start = i
            End = j
69/17: Start_side = bresenham(Start,End).path
69/18:
Outline = make_outline("s.png")
Out = plot_line(Outline)
69/19:
Innerline = make_outline("s.png")
Inner = plot_line(Innerline)
69/20:
def Loss(Line,bias):
    Loss = []
    for i in range(len(Line)-1):
        Loss.append(cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]]))
    return Loss
69/21:
Out_loss = []
for Line in Out:
    Out_loss = Out_loss + Loss(Line,0)
k = np.mean(Out_loss)
k
69/22:
def dedu(Out):
    ALL = []
    for i in Out:
        ALL = ALL+i
    Fill = []
    for i in ALL:
        if i not in Fill:
            Fill.append(i)
    return Fill
69/23:
Set_in = dedu(Inner)
len(Set_in)
69/24:
Set_out = dedu(Out)
len(Set_out)
69/25:
Start = Set_in[0]
End = Set_out[0]
distance = cv2.norm(Start,End)
for i in Set_in:
    for j in Set_out:
        d_temp = cv2.norm(i,j)
        if d_temp < distance:
            distance = d_temp
            Start = i
            End = j
69/26: Start_side = bresenham(Start,End).path
69/27: plot
69/28:
Start = Set_in[0]
End = Set_out[0]
69/29: Start
69/30: End
69/31: bresenham(Start,End).path
69/32:
Start = Set_in[0]
End = Set_out[0]
distance = cv2.norm(Start,End)
for i in Set_in:
    for j in Set_out:
        d_temp = cv2.norm(i,j)
        if d_temp < distance:
            distance = d_temp
            Start = i
            End = j
69/33: Start
69/34: End
69/35:
Outline = make_outline("s.png")
Out = plot_line(Outline)
69/36:
Innerline = make_outline("s.png")
Inner = plot_line(Innerline)
69/37:
Innerline = make_outline("s.png")
Inner = plot_line(Innerline)
69/38:
def Loss(Line,bias):
    Loss = []
    for i in range(len(Line)-1):
        Loss.append(cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]]))
    return Loss
69/39:
Out_loss = []
for Line in Out:
    Out_loss = Out_loss + Loss(Line,0)
k = np.mean(Out_loss)
k
69/40:
def dedu(Out):
    ALL = []
    for i in Out:
        ALL = ALL+i
    Fill = []
    for i in ALL:
        if i not in Fill:
            Fill.append(i)
    return Fill
69/41:
Set_in = dedu(Inner)
len(Set_in)
69/42:
Set_out = dedu(Out)
len(Set_out)
69/43:
Start = Set_in[0]
End = Set_out[0]
distance = cv2.norm(Start,End)
for i in Set_in:
    for j in Set_out:
        d_temp = cv2.norm(i,j)
        if d_temp < distance:
            distance = d_temp
            Start = i
            End = j
69/44: Start_side = bresenham(Start,End).path
69/45: Start
69/46: End
69/47:
Outline = make_outline("s.png")
Out = plot_line(Outline)
69/48:
Out_loss = []
for Line in Out:
    Out_loss = Out_loss + Loss(Line,0)
k = np.mean(Out_loss)
k
69/49:
def dedu(Out):
    ALL = []
    for i in Out:
        ALL = ALL+i
    Fill = []
    for i in ALL:
        if i not in Fill:
            Fill.append(i)
    return Fill
69/50:
Set_in = dedu(Inner)
len(Set_in)
69/51:
Set_out = dedu(Out)
len(Set_out)
69/52:
Start = Set_in[0]
End = Set_out[0]
distance = cv2.norm(Start,End)
for i in Set_in:
    for j in Set_out:
        d_temp = cv2.norm(i,j)
        if d_temp < distance:
            distance = d_temp
            Start = i
            End = j
69/53: Start
69/54: End
69/55: Start_side = bresenham(Start,End).path
69/56: Start_side
69/57:
def sub(v1,v2):
    return [v1[0]-v2[0],v1[1]-v2[1]]
69/58:
Direction = sub(Start_side[-1],Start_side[0])
Direction
69/59:
def cross_product(p1,p2):
    return p1[0]*p2[1]-p1[1]*p2[0]
69/60:
def if_target(R,image,Direction,S):
    #if in graph
    #x 
    if R[0]>image.shape[1]:
        return False
    #y
    if R[1]>image.shape[0]:
        return False
    #means out of adjust range
    if np.array_equal(image[R[1]][R[0]],[255,0,0]) == False:
        return False
    if cross_product(Direction,sub(R,list(S)))<0:
        return False
    return True
69/61:
def around4(S):
    return [(S[0]-1,S[1]),(S[0]+1,S[1]),(S[0],S[1]-1),(S[0],S[1]+1)]
69/62:
def find_pair(S):
    Reach = around4(S)
    for i in Reach:
        if if_target(i,image,Direction,S):
            return i
    print("fair to pair " + str(S))
    return False
69/63:
def get_pair_list(Search_edge):
    Pair = []
    for s in Search_edge:
        ans = find_pair(s)
        if ans:
            Pair.append(ans)
        else:
            print("Error,need drop")
            Pair.append("DE")
    return Pair
69/64:
print(Start_side)
test = np.zeros(Source.shape, dtype=np.uint8)
image = test
O = np.int32([Outline])
I = np.int32([
    Innerline])
image = cv2.fillPoly(image,O,(255,0,0))
image = cv2.fillPoly(image,I,(0,255,0))
Image.fromarray(image)
69/65:
for i in range(len(Start_side)):
    image[Start_side[i][1]][Start_side[i][0]] = [0,0,255]
Target_side = get_pair_list(Start_side)
Target_side = [tuple(n) for n in Target_side]
Target_side
69/66:
for i in range(len(Target_side)):
    if Target_side[i] != ('D','E'):
        image[Target_side[i][1]][Target_side[i][0]] = [255,255,255]
Image.fromarray(image)
69/67:
def place_to_co(p):
    return [i[0] for i in p],[i[1] for i in p]
69/68:
Node_dic = {}
ID = 0
69/69:
for n in Start_side:
    Node_dic[n] = ID
    ID = ID + 1
69/70:
for n in Target_side:
    Node_dic[n] = ID
    ID = ID + 1
69/71:
Move_area = []
for x in range(image.shape[1]):
    for y in range(image.shape[0]):
        if np.array_equal(image[y][x],[255,0,0]):
            Node_dic[(x,y)] = ID
            Move_area.append((x,y))
            ID = ID + 1
69/72:
def get_color(node,img):
    return img[node[1]][node[0]]
def get_edge(node1,node2,Source):
    return (Node_dic[node1],Node_dic[node2],cv2.norm(get_color(node1,Source),get_color(node2,Source)))
69/73:
Edge = []
for S in Start_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
69/74:
for S in Target_side:
    Reach = around4(S)
    for R in Reach:
        if np.array_equal(get_color(R,image),[255,0,0]):
            #Red is ok
            Edge.append(get_edge(S,R,Source))
69/75:
for i in Start_side:
    print(Node_dic[i])
69/76:
for i in Target_side:
    print(Node_dic[i])
69/77: Edge
69/78:
Normal_edge = []
for node in Move_area:
    #For normal red points, the edge connected to the cut have already added
    #so just consider the red-red edge
    Reach = around4(node)
    for R in Reach:
        #determine that Red-Red
        if np.array_equal(get_color(R,image),[255,0,0]):
            Normal_edge.append(get_edge(R,node,Source))
69/79: len(Normal_edge)
69/80: ID_dic[44573]
69/81:
Node_All = Start_side + Target_side + Move_area
Edge_All = Edge + Normal_edge
69/82:
with open("Edge","w") as f:
    for line in Edge_All:
        f.write(str(line[0])+" "+str(line[1])+" "+("%.2f" % line[2])+"\n")
69/83: Target_side[0]
69/84: Start_side[0]
69/85: Node_dic[Target_side[0]]
69/86:
Node_dic[Start_side[0]]
ID_dic = {v: k for k, v in Node_dic.items()}
69/87: Image.fromarray(image)
69/88: Node_dic[Start_side[0]]
69/89: import copy
69/90:
def read_path_plot(path):
    with open(path) as f:
        p = f.read()
    path = p.split()
    pim = copy.deepcopy(image)
    enclose = []
    for i in path:
        p = ID_dic[int(i)]
        enclose.append(p)
        pim[p[1]][p[0]] = [100,220,220]
    Line = copy.deepcopy(enclose)
    Loss = []
    for i in range(len(Line)-1):
        Loss.append(cv2.norm(Source[Line[i][1]][Line[i][0]],Source[Line[i+1][1]][Line[i+1][0]]))
    print("sum:"+str(sum(Loss)))
    print("k:"+str(sum(Loss)/len(enclose)))
    return Image.fromarray(pim),enclose
69/91: plot,enclose = read_path_plot("path2")
69/92: plot
  31: %notebook Untitled.ipynb
  32: %history -g -f old
